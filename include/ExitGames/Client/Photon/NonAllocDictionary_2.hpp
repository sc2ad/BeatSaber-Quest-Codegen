// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.Collections.Generic.IDictionary`2
#include "System/Collections/Generic/IDictionary_2.hpp"
// Including type: System.Collections.Generic.IEnumerator`1
#include "System/Collections/Generic/IEnumerator_1.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: ExitGames::Client::Photon
namespace ExitGames::Client::Photon {
  // Skipping declaration: KeyIterator because it is already included!
  // Skipping declaration: ValueIterator because it is already included!
  // Skipping declaration: PairIterator because it is already included!
  // Skipping declaration: Node because it is already included!
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: IEquatable`1<T>
  template<typename T>
  class IEquatable_1;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Skipping declaration: ICollection`1 because it is already included!
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Skipping declaration: IEnumerator because it is already included!
}
// Completed forward declares
// Type namespace: ExitGames.Client.Photon
namespace ExitGames::Client::Photon {
  // Forward declaring type: NonAllocDictionary`2<K, V>
  template<typename K, typename V>
  class NonAllocDictionary_2;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE_GENERIC_CLASS(::ExitGames::Client::Photon::NonAllocDictionary_2, "ExitGames.Client.Photon", "NonAllocDictionary`2");
// Type namespace: ExitGames.Client.Photon
namespace ExitGames::Client::Photon {
  // WARNING Size may be invalid!
  // Autogenerated type: ExitGames.Client.Photon.NonAllocDictionary`2
  // [TokenAttribute] Offset: FFFFFFFF
  // [DefaultMemberAttribute] Offset: 94C548
  template<typename K, typename V>
  class NonAllocDictionary_2 : public ::Il2CppObject/*, public ::System::Collections::Generic::IDictionary_2<K, V>*/ {
    public:
    // Nested type: ::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator<K, V>
    struct KeyIterator;
    // Nested type: ::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator<K, V>
    struct ValueIterator;
    // Nested type: ::ExitGames::Client::Photon::NonAllocDictionary_2::PairIterator<K, V>
    struct PairIterator;
    // Nested type: ::ExitGames::Client::Photon::NonAllocDictionary_2::Node<K, V>
    struct Node;
    // WARNING Size may be invalid!
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.KeyIterator
    // [TokenAttribute] Offset: FFFFFFFF
    struct KeyIterator : public ::il2cpp_utils::il2cpp_type_check::NestedType/*, public ::System::ValueType, public ::System::Collections::Generic::IEnumerator_1<K>*/ {
      public:
      using declaring_type = NonAllocDictionary_2<K, V>*;
      static constexpr std::string_view NESTED_NAME = "KeyIterator";
      static constexpr bool IS_VALUE_TYPE = true;
      public:
      // private System.Int32 _index
      // Size: 0x4
      // Offset: 0x0
      int index;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // private ExitGames.Client.Photon.NonAllocDictionary`2<K,V> _dict
      // Size: 0x8
      // Offset: 0x0
      ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>* dict;
      // Field size check
      static_assert(sizeof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*) == 0x8);
      public:
      // Creating value type constructor for type: KeyIterator
      constexpr KeyIterator(int index_ = {}, ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>* dict_ = {}) noexcept : index{index_}, dict{dict_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating interface conversion operator: operator ::System::Collections::Generic::IEnumerator_1<K>
      operator ::System::Collections::Generic::IEnumerator_1<K>() noexcept {
        return *reinterpret_cast<::System::Collections::Generic::IEnumerator_1<K>*>(this);
      }
      // Autogenerated instance field getter
      // Get instance field: private System.Int32 _index
      [[deprecated("Use field access instead!")]] int& dyn__index() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator::dyn__index");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_index"))->offset;
        return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: private ExitGames.Client.Photon.NonAllocDictionary`2<K,V> _dict
      [[deprecated("Use field access instead!")]] ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*& dyn__dict() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator::dyn__dict");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_dict"))->offset;
        return *reinterpret_cast<::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // private System.Object System.Collections.IEnumerator.get_Current()
      // Offset: 0xFFFFFFFFFFFFFFFF
      ::Il2CppObject* System_Collections_IEnumerator_get_Current() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator::System.Collections.IEnumerator.get_Current");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::KeyIterator), -1)));
        return ::il2cpp_utils::RunMethodRethrow<::Il2CppObject*, false>(this, ___internal__method);
      }
      // public K get_Current()
      // Offset: 0xFFFFFFFFFFFFFFFF
      K get_Current() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator::get_Current");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::KeyIterator), -1)));
        return ::il2cpp_utils::RunMethodRethrow<K, false>(this, ___internal__method);
      }
      // public System.Void .ctor(ExitGames.Client.Photon.NonAllocDictionary`2<K,V> dictionary)
      // Offset: 0xFFFFFFFFFFFFFFFF
      KeyIterator(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>* dictionary) {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator::.ctor");
        static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, ".ctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(dictionary)})));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, dictionary);
      }
      // public ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.KeyIterator<K,V> GetEnumerator()
      // Offset: 0xFFFFFFFFFFFFFFFF
      typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::KeyIterator GetEnumerator() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator::GetEnumerator");
        static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "GetEnumerator", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
        return ::il2cpp_utils::RunMethodRethrow<typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::KeyIterator, false>(this, ___internal__method);
      }
      // public System.Void Reset()
      // Offset: 0xFFFFFFFFFFFFFFFF
      void Reset() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator::Reset");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::KeyIterator), -1)));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
      }
      // public System.Boolean MoveNext()
      // Offset: 0xFFFFFFFFFFFFFFFF
      bool MoveNext() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator::MoveNext");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::KeyIterator), -1)));
        return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method);
      }
      // public System.Void Dispose()
      // Offset: 0xFFFFFFFFFFFFFFFF
      void Dispose() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::KeyIterator::Dispose");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::KeyIterator), -1)));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
      }
    }; // ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.KeyIterator
    // Could not write size check! Type: ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.KeyIterator is generic, or has no fields that are valid for size checks!
    // WARNING Size may be invalid!
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.ValueIterator
    // [TokenAttribute] Offset: FFFFFFFF
    struct ValueIterator : public ::il2cpp_utils::il2cpp_type_check::NestedType/*, public ::System::ValueType, public ::System::Collections::Generic::IEnumerator_1<V>*/ {
      public:
      using declaring_type = NonAllocDictionary_2<K, V>*;
      static constexpr std::string_view NESTED_NAME = "ValueIterator";
      static constexpr bool IS_VALUE_TYPE = true;
      public:
      // private System.Int32 _index
      // Size: 0x4
      // Offset: 0x0
      int index;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // private ExitGames.Client.Photon.NonAllocDictionary`2<K,V> _dict
      // Size: 0x8
      // Offset: 0x0
      ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>* dict;
      // Field size check
      static_assert(sizeof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*) == 0x8);
      public:
      // Creating value type constructor for type: ValueIterator
      constexpr ValueIterator(int index_ = {}, ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>* dict_ = {}) noexcept : index{index_}, dict{dict_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating interface conversion operator: operator ::System::Collections::Generic::IEnumerator_1<V>
      operator ::System::Collections::Generic::IEnumerator_1<V>() noexcept {
        return *reinterpret_cast<::System::Collections::Generic::IEnumerator_1<V>*>(this);
      }
      // Autogenerated instance field getter
      // Get instance field: private System.Int32 _index
      [[deprecated("Use field access instead!")]] int& dyn__index() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator::dyn__index");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_index"))->offset;
        return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: private ExitGames.Client.Photon.NonAllocDictionary`2<K,V> _dict
      [[deprecated("Use field access instead!")]] ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*& dyn__dict() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator::dyn__dict");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_dict"))->offset;
        return *reinterpret_cast<::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // public V get_Current()
      // Offset: 0xFFFFFFFFFFFFFFFF
      V get_Current() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator::get_Current");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::ValueIterator), -1)));
        return ::il2cpp_utils::RunMethodRethrow<V, false>(this, ___internal__method);
      }
      // private System.Object System.Collections.IEnumerator.get_Current()
      // Offset: 0xFFFFFFFFFFFFFFFF
      ::Il2CppObject* System_Collections_IEnumerator_get_Current() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator::System.Collections.IEnumerator.get_Current");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::ValueIterator), -1)));
        return ::il2cpp_utils::RunMethodRethrow<::Il2CppObject*, false>(this, ___internal__method);
      }
      // public System.Void .ctor(ExitGames.Client.Photon.NonAllocDictionary`2<K,V> dictionary)
      // Offset: 0xFFFFFFFFFFFFFFFF
      ValueIterator(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>* dictionary) {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator::.ctor");
        static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, ".ctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(dictionary)})));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, dictionary);
      }
      // public ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.ValueIterator<K,V> GetEnumerator()
      // Offset: 0xFFFFFFFFFFFFFFFF
      typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::ValueIterator GetEnumerator() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator::GetEnumerator");
        static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "GetEnumerator", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
        return ::il2cpp_utils::RunMethodRethrow<typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::ValueIterator, false>(this, ___internal__method);
      }
      // public System.Void Reset()
      // Offset: 0xFFFFFFFFFFFFFFFF
      void Reset() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator::Reset");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::ValueIterator), -1)));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
      }
      // public System.Boolean MoveNext()
      // Offset: 0xFFFFFFFFFFFFFFFF
      bool MoveNext() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator::MoveNext");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::ValueIterator), -1)));
        return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method);
      }
      // public System.Void Dispose()
      // Offset: 0xFFFFFFFFFFFFFFFF
      void Dispose() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ValueIterator::Dispose");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::ValueIterator), -1)));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
      }
    }; // ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.ValueIterator
    // Could not write size check! Type: ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.ValueIterator is generic, or has no fields that are valid for size checks!
    // WARNING Size may be invalid!
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.PairIterator
    // [TokenAttribute] Offset: FFFFFFFF
    struct PairIterator : public ::il2cpp_utils::il2cpp_type_check::NestedType/*, public ::System::ValueType, public ::System::Collections::Generic::IEnumerator_1<::System::Collections::Generic::KeyValuePair_2<K, V>>*/ {
      public:
      using declaring_type = NonAllocDictionary_2<K, V>*;
      static constexpr std::string_view NESTED_NAME = "PairIterator";
      static constexpr bool IS_VALUE_TYPE = true;
      public:
      // private System.Int32 _index
      // Size: 0x4
      // Offset: 0x0
      int index;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // private ExitGames.Client.Photon.NonAllocDictionary`2<K,V> _dict
      // Size: 0x8
      // Offset: 0x0
      ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>* dict;
      // Field size check
      static_assert(sizeof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*) == 0x8);
      public:
      // Creating value type constructor for type: PairIterator
      constexpr PairIterator(int index_ = {}, ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>* dict_ = {}) noexcept : index{index_}, dict{dict_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating interface conversion operator: operator ::System::Collections::Generic::IEnumerator_1<::System::Collections::Generic::KeyValuePair_2<K, V>>
      operator ::System::Collections::Generic::IEnumerator_1<::System::Collections::Generic::KeyValuePair_2<K, V>>() noexcept {
        return *reinterpret_cast<::System::Collections::Generic::IEnumerator_1<::System::Collections::Generic::KeyValuePair_2<K, V>>*>(this);
      }
      // Autogenerated instance field getter
      // Get instance field: private System.Int32 _index
      [[deprecated("Use field access instead!")]] int& dyn__index() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::PairIterator::dyn__index");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_index"))->offset;
        return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: private ExitGames.Client.Photon.NonAllocDictionary`2<K,V> _dict
      [[deprecated("Use field access instead!")]] ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*& dyn__dict() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::PairIterator::dyn__dict");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_dict"))->offset;
        return *reinterpret_cast<::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // private System.Object System.Collections.IEnumerator.get_Current()
      // Offset: 0xFFFFFFFFFFFFFFFF
      ::Il2CppObject* System_Collections_IEnumerator_get_Current() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::PairIterator::System.Collections.IEnumerator.get_Current");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::PairIterator), -1)));
        return ::il2cpp_utils::RunMethodRethrow<::Il2CppObject*, false>(this, ___internal__method);
      }
      // public System.Collections.Generic.KeyValuePair`2<K,V> get_Current()
      // Offset: 0xFFFFFFFFFFFFFFFF
      ::System::Collections::Generic::KeyValuePair_2<K, V> get_Current() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::PairIterator::get_Current");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::PairIterator), -1)));
        return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::KeyValuePair_2<K, V>, false>(this, ___internal__method);
      }
      // public System.Void .ctor(ExitGames.Client.Photon.NonAllocDictionary`2<K,V> dictionary)
      // Offset: 0xFFFFFFFFFFFFFFFF
      PairIterator(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>* dictionary) {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::PairIterator::.ctor");
        static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, ".ctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(dictionary)})));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, dictionary);
      }
      // public System.Void Reset()
      // Offset: 0xFFFFFFFFFFFFFFFF
      void Reset() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::PairIterator::Reset");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::PairIterator), -1)));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
      }
      // public System.Boolean MoveNext()
      // Offset: 0xFFFFFFFFFFFFFFFF
      bool MoveNext() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::PairIterator::MoveNext");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::PairIterator), -1)));
        return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method);
      }
      // public System.Void Dispose()
      // Offset: 0xFFFFFFFFFFFFFFFF
      void Dispose() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::PairIterator::Dispose");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::PairIterator), -1)));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
      }
    }; // ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.PairIterator
    // Could not write size check! Type: ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.PairIterator is generic, or has no fields that are valid for size checks!
    // WARNING Size may be invalid!
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.Node
    // [TokenAttribute] Offset: FFFFFFFF
    struct Node : public ::il2cpp_utils::il2cpp_type_check::NestedType/*, public ::System::ValueType*/ {
      public:
      using declaring_type = NonAllocDictionary_2<K, V>*;
      static constexpr std::string_view NESTED_NAME = "Node";
      static constexpr bool IS_VALUE_TYPE = true;
      public:
      // public System.Boolean Used
      // Size: 0x1
      // Offset: 0x0
      bool Used;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // public System.Int32 Next
      // Size: 0x4
      // Offset: 0x0
      int Next;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.UInt32 Hash
      // Size: 0x4
      // Offset: 0x0
      uint Hash;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public K Key
      // Size: 0xFFFFFFFF
      // Offset: 0x0
      K Key;
      // public V Val
      // Size: 0xFFFFFFFF
      // Offset: 0x0
      V Val;
      public:
      // Creating value type constructor for type: Node
      constexpr Node(bool Used_ = {}, int Next_ = {}, uint Hash_ = {}, K Key_ = {}, V Val_ = {}) noexcept : Used{Used_}, Next{Next_}, Hash{Hash_}, Key{Key_}, Val{Val_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Autogenerated instance field getter
      // Get instance field: public System.Boolean Used
      [[deprecated("Use field access instead!")]] bool& dyn_Used() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Node::dyn_Used");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "Used"))->offset;
        return *reinterpret_cast<bool*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: public System.Int32 Next
      [[deprecated("Use field access instead!")]] int& dyn_Next() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Node::dyn_Next");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "Next"))->offset;
        return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: public System.UInt32 Hash
      [[deprecated("Use field access instead!")]] uint& dyn_Hash() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Node::dyn_Hash");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "Hash"))->offset;
        return *reinterpret_cast<uint*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: public K Key
      [[deprecated("Use field access instead!")]] K& dyn_Key() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Node::dyn_Key");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "Key"))->offset;
        return *reinterpret_cast<K*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: public V Val
      [[deprecated("Use field access instead!")]] V& dyn_Val() {
        static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Node::dyn_Val");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "Val"))->offset;
        return *reinterpret_cast<V*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
    }; // ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.Node
    // Could not write size check! Type: ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.Node is generic, or has no fields that are valid for size checks!
    public:
    // private System.Int32 _freeHead
    // Size: 0x4
    // Offset: 0x0
    int freeHead;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _freeCount
    // Size: 0x4
    // Offset: 0x0
    int freeCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _usedCount
    // Size: 0x4
    // Offset: 0x0
    int usedCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.UInt32 _capacity
    // Size: 0x4
    // Offset: 0x0
    uint capacity;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.Int32[] _buckets
    // Size: 0x8
    // Offset: 0x0
    ::ArrayW<int> buckets;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // private ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.Node<K,V>[] _nodes
    // Size: 0x8
    // Offset: 0x0
    ::ArrayW<typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::Node> nodes;
    // Field size check
    static_assert(sizeof(::ArrayW<typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::Node>) == 0x8);
    // private System.Boolean isReadOnly
    // Size: 0x1
    // Offset: 0x0
    bool isReadOnly;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Collections.Generic.ICollection`1<K> keys
    // Size: 0x8
    // Offset: 0x0
    ::System::Collections::Generic::ICollection_1<K>* keys;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::ICollection_1<K>*) == 0x8);
    // private System.Collections.Generic.ICollection`1<V> values
    // Size: 0x8
    // Offset: 0x0
    ::System::Collections::Generic::ICollection_1<V>* values;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::ICollection_1<V>*) == 0x8);
    public:
    // Creating interface conversion operator: operator ::System::Collections::Generic::IDictionary_2<K, V>
    operator ::System::Collections::Generic::IDictionary_2<K, V>() noexcept {
      return *reinterpret_cast<::System::Collections::Generic::IDictionary_2<K, V>*>(this);
    }
    // Autogenerated static field getter
    // Get static field: static private System.UInt32[] _primeTableUInt
    static ::ArrayW<uint> _get__primeTableUInt() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::_get__primeTableUInt");
      return THROW_UNLESS((il2cpp_utils::GetFieldValue<::ArrayW<uint>>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<NonAllocDictionary_2<K, V>*>::get(), "_primeTableUInt")));
    }
    // Autogenerated static field setter
    // Set static field: static private System.UInt32[] _primeTableUInt
    static void _set__primeTableUInt(::ArrayW<uint> value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::_set__primeTableUInt");
      THROW_UNLESS((il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<NonAllocDictionary_2<K, V>*>::get(), "_primeTableUInt", value)));
    }
    // Autogenerated instance field getter
    // Get instance field: private System.Int32 _freeHead
    [[deprecated("Use field access instead!")]] int& dyn__freeHead() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::dyn__freeHead");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_freeHead"))->offset;
      return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.Int32 _freeCount
    [[deprecated("Use field access instead!")]] int& dyn__freeCount() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::dyn__freeCount");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_freeCount"))->offset;
      return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.Int32 _usedCount
    [[deprecated("Use field access instead!")]] int& dyn__usedCount() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::dyn__usedCount");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_usedCount"))->offset;
      return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.UInt32 _capacity
    [[deprecated("Use field access instead!")]] uint& dyn__capacity() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::dyn__capacity");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_capacity"))->offset;
      return *reinterpret_cast<uint*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.Int32[] _buckets
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn__buckets() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::dyn__buckets");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_buckets"))->offset;
      return *reinterpret_cast<::ArrayW<int>*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.Node<K,V>[] _nodes
    [[deprecated("Use field access instead!")]] ::ArrayW<typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::Node>& dyn__nodes() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::dyn__nodes");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_nodes"))->offset;
      return *reinterpret_cast<::ArrayW<typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::Node>*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.Boolean isReadOnly
    [[deprecated("Use field access instead!")]] bool& dyn_isReadOnly() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::dyn_isReadOnly");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "isReadOnly"))->offset;
      return *reinterpret_cast<bool*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.Collections.Generic.ICollection`1<K> keys
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::ICollection_1<K>*& dyn_keys() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::dyn_keys");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "keys"))->offset;
      return *reinterpret_cast<::System::Collections::Generic::ICollection_1<K>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.Collections.Generic.ICollection`1<V> values
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::ICollection_1<V>*& dyn_values() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::dyn_values");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "values"))->offset;
      return *reinterpret_cast<::System::Collections::Generic::ICollection_1<V>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // public ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.KeyIterator<K,V> get_Keys()
    // Offset: 0xFFFFFFFFFFFFFFFF
    typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::KeyIterator get_Keys() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::get_Keys");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "get_Keys", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      return ::il2cpp_utils::RunMethodRethrow<typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::KeyIterator, false>(this, ___internal__method);
    }
    // private System.Collections.Generic.ICollection`1<V> System.Collections.Generic.IDictionary<K,V>.get_Values()
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::System::Collections::Generic::ICollection_1<V>* System_Collections_Generic_IDictionary$K_V$_get_Values() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::System.Collections.Generic.IDictionary<K,V>.get_Values");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::ICollection_1<V>*, false>(this, ___internal__method);
    }
    // private System.Collections.Generic.ICollection`1<K> System.Collections.Generic.IDictionary<K,V>.get_Keys()
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::System::Collections::Generic::ICollection_1<K>* System_Collections_Generic_IDictionary$K_V$_get_Keys() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::System.Collections.Generic.IDictionary<K,V>.get_Keys");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::ICollection_1<K>*, false>(this, ___internal__method);
    }
    // public ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.ValueIterator<K,V> get_Values()
    // Offset: 0xFFFFFFFFFFFFFFFF
    typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::ValueIterator get_Values() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::get_Values");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "get_Values", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      return ::il2cpp_utils::RunMethodRethrow<typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::ValueIterator, false>(this, ___internal__method);
    }
    // public System.Int32 get_Count()
    // Offset: 0xFFFFFFFFFFFFFFFF
    int get_Count() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::get_Count");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<int, false>(this, ___internal__method);
    }
    // public System.Boolean get_IsReadOnly()
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool get_IsReadOnly() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::get_IsReadOnly");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method);
    }
    // public System.UInt32 get_Capacity()
    // Offset: 0xFFFFFFFFFFFFFFFF
    uint get_Capacity() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::get_Capacity");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "get_Capacity", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      return ::il2cpp_utils::RunMethodRethrow<uint, false>(this, ___internal__method);
    }
    // public V get_Item(K key)
    // Offset: 0xFFFFFFFFFFFFFFFF
    V get_Item(K key) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::get_Item");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<V, false>(this, ___internal__method, key);
    }
    // public System.Void set_Item(K key, V value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void set_Item(K key, V value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::set_Item");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, key, value);
    }
    // public System.Void .ctor(System.UInt32 capacity)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NonAllocDictionary_2<K, V>* New_ctor(uint capacity) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NonAllocDictionary_2<K, V>*, creationType>(capacity)));
    }
    // static private System.Void .cctor()
    // Offset: 0xFFFFFFFFFFFFFFFF
    static void _cctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::.cctor");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<NonAllocDictionary_2<K, V>*>::get(), ".cctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(static_cast<Il2CppObject*>(nullptr), ___internal__method);
    }
    // public System.Boolean ContainsKey(K key)
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool ContainsKey(K key) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::ContainsKey");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, key);
    }
    // public System.Boolean Contains(System.Collections.Generic.KeyValuePair`2<K,V> item)
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool Contains(::System::Collections::Generic::KeyValuePair_2<K, V> item) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Contains");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, item);
    }
    // public System.Boolean TryGetValue(K key, out V val)
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool TryGetValue(K key, ByRef<V> val) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::TryGetValue");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, key, byref(val));
    }
    // public System.Void Set(K key, V val)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Set(K key, V val) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Set");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Set", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(key), ::il2cpp_utils::ExtractType(val)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, key, val);
    }
    // public System.Void Add(K key, V val)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Add(K key, V val) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Add");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, key, val);
    }
    // public System.Void Add(System.Collections.Generic.KeyValuePair`2<K,V> item)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Add(::System::Collections::Generic::KeyValuePair_2<K, V> item) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Add");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, item);
    }
    // public System.Boolean Remove(K key)
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool Remove(K key) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Remove");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, key);
    }
    // public System.Boolean Remove(System.Collections.Generic.KeyValuePair`2<K,V> item)
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool Remove(::System::Collections::Generic::KeyValuePair_2<K, V> item) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Remove");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, item);
    }
    // private System.Collections.Generic.IEnumerator`1<System.Collections.Generic.KeyValuePair`2<K,V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator()
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::System::Collections::Generic::IEnumerator_1<::System::Collections::Generic::KeyValuePair_2<K, V>>* System_Collections_Generic_IEnumerable$System_Collections_Generic_KeyValuePair$K_V$$_GetEnumerator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::IEnumerator_1<::System::Collections::Generic::KeyValuePair_2<K, V>>*, false>(this, ___internal__method);
    }
    // public ExitGames.Client.Photon.NonAllocDictionary`2/ExitGames.Client.Photon.PairIterator<K,V> GetEnumerator()
    // Offset: 0xFFFFFFFFFFFFFFFF
    typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::PairIterator GetEnumerator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::GetEnumerator");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "GetEnumerator", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      return ::il2cpp_utils::RunMethodRethrow<typename ::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>::PairIterator, false>(this, ___internal__method);
    }
    // private System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::System::Collections::IEnumerator* System_Collections_IEnumerable_GetEnumerator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::System.Collections.IEnumerable.GetEnumerator");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::IEnumerator*, false>(this, ___internal__method);
    }
    // private System.Int32 FindNode(K key)
    // Offset: 0xFFFFFFFFFFFFFFFF
    int FindNode(K key) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::FindNode");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "FindNode", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(key)})));
      return ::il2cpp_utils::RunMethodRethrow<int, false>(this, ___internal__method, key);
    }
    // private System.Void Insert(K key, V val)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Insert(K key, V val) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Insert");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Insert", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(key), ::il2cpp_utils::ExtractType(val)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, key, val);
    }
    // private System.Void Expand()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Expand() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Expand");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Expand", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
    // public System.Void Clear()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Clear() {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Clear");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
    // private System.Void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.CopyTo(System.Collections.Generic.KeyValuePair`2<K,V>[] array, System.Int32 index)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void System_Collections_Generic_ICollection$System_Collections_Generic_KeyValuePair$K_V$$_CopyTo(::ArrayW<::System::Collections::Generic::KeyValuePair_2<K, V>> array, int index) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.CopyTo");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::ExitGames::Client::Photon::NonAllocDictionary_2<K, V>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, array, index);
    }
    // static private System.Boolean IsPrimeFromList(System.UInt32 value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    static bool IsPrimeFromList(uint value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::IsPrimeFromList");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<NonAllocDictionary_2<K, V>*>::get(), "IsPrimeFromList", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(value)})));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(static_cast<Il2CppObject*>(nullptr), ___internal__method, value);
    }
    // static private System.UInt32 GetNextPrime(System.UInt32 value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    static uint GetNextPrime(uint value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::GetNextPrime");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<NonAllocDictionary_2<K, V>*>::get(), "GetNextPrime", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(value)})));
      return ::il2cpp_utils::RunMethodRethrow<uint, false>(static_cast<Il2CppObject*>(nullptr), ___internal__method, value);
    }
    // static private System.Void Assert(System.Boolean condition)
    // Offset: 0xFFFFFFFFFFFFFFFF
    static void Assert_(bool condition) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::NonAllocDictionary_2::Assert");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<NonAllocDictionary_2<K, V>*>::get(), "Assert", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(condition)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(static_cast<Il2CppObject*>(nullptr), ___internal__method, condition);
    }
  }; // ExitGames.Client.Photon.NonAllocDictionary`2
  // Could not write size check! Type: ExitGames.Client.Photon.NonAllocDictionary`2 is generic, or has no fields that are valid for size checks!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
