// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: ExitGames.Client.Photon.SocketTcpAsync
#include "ExitGames/Client/Photon/SocketTcpAsync.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::Net::Sockets
namespace System::Net::Sockets {
  // Forward declaring type: Socket
  class Socket;
}
// Completed forward declares
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext);
DEFINE_IL2CPP_ARG_TYPE(::ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext*, "ExitGames.Client.Photon", "SocketTcpAsync/ReceiveContext");
// Type namespace: ExitGames.Client.Photon
namespace ExitGames::Client::Photon {
  // Size: 0x38
  #pragma pack(push, 1)
  // Autogenerated type: ExitGames.Client.Photon.SocketTcpAsync/ExitGames.Client.Photon.ReceiveContext
  // [TokenAttribute] Offset: FFFFFFFF
  class SocketTcpAsync::ReceiveContext : public ::Il2CppObject {
    public:
    public:
    // public System.Net.Sockets.Socket workSocket
    // Size: 0x8
    // Offset: 0x10
    ::System::Net::Sockets::Socket* workSocket;
    // Field size check
    static_assert(sizeof(::System::Net::Sockets::Socket*) == 0x8);
    // public System.Int32 ReceivedHeaderBytes
    // Size: 0x4
    // Offset: 0x18
    int ReceivedHeaderBytes;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: ReceivedHeaderBytes and: HeaderBuffer
    char __padding1[0x4] = {};
    // public System.Byte[] HeaderBuffer
    // Size: 0x8
    // Offset: 0x20
    ::ArrayW<uint8_t> HeaderBuffer;
    // Field size check
    static_assert(sizeof(::ArrayW<uint8_t>) == 0x8);
    // public System.Int32 ExpectedMessageBytes
    // Size: 0x4
    // Offset: 0x28
    int ExpectedMessageBytes;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 ReceivedMessageBytes
    // Size: 0x4
    // Offset: 0x2C
    int ReceivedMessageBytes;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Byte[] MessageBuffer
    // Size: 0x8
    // Offset: 0x30
    ::ArrayW<uint8_t> MessageBuffer;
    // Field size check
    static_assert(sizeof(::ArrayW<uint8_t>) == 0x8);
    public:
    // Get instance field reference: public System.Net.Sockets.Socket workSocket
    [[deprecated("Use field access instead!")]] ::System::Net::Sockets::Socket*& dyn_workSocket();
    // Get instance field reference: public System.Int32 ReceivedHeaderBytes
    [[deprecated("Use field access instead!")]] int& dyn_ReceivedHeaderBytes();
    // Get instance field reference: public System.Byte[] HeaderBuffer
    [[deprecated("Use field access instead!")]] ::ArrayW<uint8_t>& dyn_HeaderBuffer();
    // Get instance field reference: public System.Int32 ExpectedMessageBytes
    [[deprecated("Use field access instead!")]] int& dyn_ExpectedMessageBytes();
    // Get instance field reference: public System.Int32 ReceivedMessageBytes
    [[deprecated("Use field access instead!")]] int& dyn_ReceivedMessageBytes();
    // Get instance field reference: public System.Byte[] MessageBuffer
    [[deprecated("Use field access instead!")]] ::ArrayW<uint8_t>& dyn_MessageBuffer();
    // public System.Boolean get_ReadingHeader()
    // Offset: 0x16FF5D0
    bool get_ReadingHeader();
    // public System.Boolean get_ReadingMessage()
    // Offset: 0x16FF5EC
    bool get_ReadingMessage();
    // public System.Byte[] get_CurrentBuffer()
    // Offset: 0x16FECB0
    ::ArrayW<uint8_t> get_CurrentBuffer();
    // public System.Int32 get_CurrentOffset()
    // Offset: 0x16FECCC
    int get_CurrentOffset();
    // public System.Int32 get_CurrentExpected()
    // Offset: 0x16FECE8
    int get_CurrentExpected();
    // public System.Void .ctor(System.Net.Sockets.Socket socket, System.Byte[] headerBuffer, System.Byte[] messageBuffer)
    // Offset: 0x16FEC6C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static SocketTcpAsync::ReceiveContext* New_ctor(::System::Net::Sockets::Socket* socket, ::ArrayW<uint8_t> headerBuffer, ::ArrayW<uint8_t> messageBuffer) {
      static auto ___internal__logger = ::Logger::get().WithContext("::ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<SocketTcpAsync::ReceiveContext*, creationType>(socket, headerBuffer, messageBuffer)));
    }
    // public System.Void Reset()
    // Offset: 0x16FF5E0
    void Reset();
  }; // ExitGames.Client.Photon.SocketTcpAsync/ExitGames.Client.Photon.ReceiveContext
  #pragma pack(pop)
  static check_size<sizeof(SocketTcpAsync::ReceiveContext), 48 + sizeof(::ArrayW<uint8_t>)> __ExitGames_Client_Photon_SocketTcpAsync_ReceiveContextSizeCheck;
  static_assert(sizeof(SocketTcpAsync::ReceiveContext) == 0x38);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_ReadingHeader
// Il2CppName: get_ReadingHeader
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::*)()>(&ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_ReadingHeader)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext*), "get_ReadingHeader", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_ReadingMessage
// Il2CppName: get_ReadingMessage
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::*)()>(&ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_ReadingMessage)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext*), "get_ReadingMessage", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_CurrentBuffer
// Il2CppName: get_CurrentBuffer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<uint8_t> (ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::*)()>(&ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_CurrentBuffer)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext*), "get_CurrentBuffer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_CurrentOffset
// Il2CppName: get_CurrentOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::*)()>(&ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_CurrentOffset)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext*), "get_CurrentOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_CurrentExpected
// Il2CppName: get_CurrentExpected
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::*)()>(&ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::get_CurrentExpected)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext*), "get_CurrentExpected", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::Reset
// Il2CppName: Reset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::*)()>(&ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext::Reset)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(ExitGames::Client::Photon::SocketTcpAsync::ReceiveContext*), "Reset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
