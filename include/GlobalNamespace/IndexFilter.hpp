// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.Collections.Generic.IReadOnlyCollection`1
#include "System/Collections/Generic/IReadOnlyCollection_1.hpp"
// Including type: System.ValueTuple`3
#include "System/ValueTuple_3.hpp"
// Including type: System.Enum
#include "System/Enum.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: IEnumerator`1<T>
  template<typename T>
  class IEnumerator_1;
  // Skipping declaration: IEnumerable`1 because it is already included!
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Skipping declaration: IndexFilterLimitAlsoAffectType because it is already included!
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: IndexFilter
  class IndexFilter;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::IndexFilter);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::IndexFilter*, "", "IndexFilter");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x34
  #pragma pack(push, 1)
  // Autogenerated type: IndexFilter
  // [TokenAttribute] Offset: FFFFFFFF
  class IndexFilter : public ::Il2CppObject/*, public ::System::Collections::Generic::IReadOnlyCollection_1<::System::ValueTuple_3<int, int, int>>*/ {
    public:
    // Nested type: ::GlobalNamespace::IndexFilter::IndexFilterRandomType
    struct IndexFilterRandomType;
    // Nested type: ::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType
    struct IndexFilterLimitAlsoAffectType;
    // Nested type: ::GlobalNamespace::IndexFilter::$GetEnumerator$d__19
    class $GetEnumerator$d__19;
    // Nested type: ::GlobalNamespace::IndexFilter::$GetValues$d__20
    class $GetValues$d__20;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: IndexFilter/IndexFilterRandomType
    // [TokenAttribute] Offset: FFFFFFFF
    // [FlagsAttribute] Offset: FFFFFFFF
    struct IndexFilterRandomType/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: IndexFilterRandomType
      constexpr IndexFilterRandomType(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating interface conversion operator: i_Enum
      inline ::System::Enum* i_Enum() noexcept {
        return reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public IndexFilter/IndexFilterRandomType NoRandom
      static constexpr const int NoRandom = 0;
      // Get static field: static public IndexFilter/IndexFilterRandomType NoRandom
      static ::GlobalNamespace::IndexFilter::IndexFilterRandomType _get_NoRandom();
      // Set static field: static public IndexFilter/IndexFilterRandomType NoRandom
      static void _set_NoRandom(::GlobalNamespace::IndexFilter::IndexFilterRandomType value);
      // static field const value: static public IndexFilter/IndexFilterRandomType KeepOrder
      static constexpr const int KeepOrder = 1;
      // Get static field: static public IndexFilter/IndexFilterRandomType KeepOrder
      static ::GlobalNamespace::IndexFilter::IndexFilterRandomType _get_KeepOrder();
      // Set static field: static public IndexFilter/IndexFilterRandomType KeepOrder
      static void _set_KeepOrder(::GlobalNamespace::IndexFilter::IndexFilterRandomType value);
      // static field const value: static public IndexFilter/IndexFilterRandomType RandomElements
      static constexpr const int RandomElements = 2;
      // Get static field: static public IndexFilter/IndexFilterRandomType RandomElements
      static ::GlobalNamespace::IndexFilter::IndexFilterRandomType _get_RandomElements();
      // Set static field: static public IndexFilter/IndexFilterRandomType RandomElements
      static void _set_RandomElements(::GlobalNamespace::IndexFilter::IndexFilterRandomType value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // IndexFilter/IndexFilterRandomType
    #pragma pack(pop)
    static check_size<sizeof(IndexFilter::IndexFilterRandomType), 0 + sizeof(int)> __GlobalNamespace_IndexFilter_IndexFilterRandomTypeSizeCheck;
    static_assert(sizeof(IndexFilter::IndexFilterRandomType) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: IndexFilter/IndexFilterLimitAlsoAffectType
    // [TokenAttribute] Offset: FFFFFFFF
    // [FlagsAttribute] Offset: FFFFFFFF
    struct IndexFilterLimitAlsoAffectType/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: IndexFilterLimitAlsoAffectType
      constexpr IndexFilterLimitAlsoAffectType(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating interface conversion operator: i_Enum
      inline ::System::Enum* i_Enum() noexcept {
        return reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public IndexFilter/IndexFilterLimitAlsoAffectType None
      static constexpr const int None = 0;
      // Get static field: static public IndexFilter/IndexFilterLimitAlsoAffectType None
      static ::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType _get_None();
      // Set static field: static public IndexFilter/IndexFilterLimitAlsoAffectType None
      static void _set_None(::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType value);
      // static field const value: static public IndexFilter/IndexFilterLimitAlsoAffectType Duration
      static constexpr const int Duration = 1;
      // Get static field: static public IndexFilter/IndexFilterLimitAlsoAffectType Duration
      static ::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType _get_Duration();
      // Set static field: static public IndexFilter/IndexFilterLimitAlsoAffectType Duration
      static void _set_Duration(::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType value);
      // static field const value: static public IndexFilter/IndexFilterLimitAlsoAffectType Distribution
      static constexpr const int Distribution = 2;
      // Get static field: static public IndexFilter/IndexFilterLimitAlsoAffectType Distribution
      static ::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType _get_Distribution();
      // Set static field: static public IndexFilter/IndexFilterLimitAlsoAffectType Distribution
      static void _set_Distribution(::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // IndexFilter/IndexFilterLimitAlsoAffectType
    #pragma pack(pop)
    static check_size<sizeof(IndexFilter::IndexFilterLimitAlsoAffectType), 0 + sizeof(int)> __GlobalNamespace_IndexFilter_IndexFilterLimitAlsoAffectTypeSizeCheck;
    static_assert(sizeof(IndexFilter::IndexFilterLimitAlsoAffectType) == 0x4);
    public:
    // private readonly IndexFilter/IndexFilterRandomType _random
    // Size: 0x4
    // Offset: 0x10
    ::GlobalNamespace::IndexFilter::IndexFilterRandomType random;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::IndexFilter::IndexFilterRandomType) == 0x4);
    // private readonly System.Int32 _seed
    // Size: 0x4
    // Offset: 0x14
    int seed;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private readonly System.Int32 _groupSize
    // Size: 0x4
    // Offset: 0x18
    int groupSize;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private readonly System.Int32 _chunkSize
    // Size: 0x4
    // Offset: 0x1C
    int chunkSize;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private readonly System.Int32 _visibleCount
    // Size: 0x4
    // Offset: 0x20
    int visibleCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private readonly IndexFilter/IndexFilterLimitAlsoAffectType _limitAlsoAffectType
    // Size: 0x4
    // Offset: 0x24
    ::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType limitAlsoAffectType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType) == 0x4);
    // private readonly System.Int32 _start
    // Size: 0x4
    // Offset: 0x28
    int start;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private readonly System.Int32 _step
    // Size: 0x4
    // Offset: 0x2C
    int step;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private readonly System.Int32 _count
    // Size: 0x4
    // Offset: 0x30
    int count;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    public:
    // Creating interface conversion operator: operator ::System::Collections::Generic::IReadOnlyCollection_1<::System::ValueTuple_3<int, int, int>>
    operator ::System::Collections::Generic::IReadOnlyCollection_1<::System::ValueTuple_3<int, int, int>>() noexcept {
      return *reinterpret_cast<::System::Collections::Generic::IReadOnlyCollection_1<::System::ValueTuple_3<int, int, int>>*>(this);
    }
    // Creating interface conversion operator: i_ValueTuple_3_int_int_int
    inline ::System::Collections::Generic::IReadOnlyCollection_1<::System::ValueTuple_3<int, int, int>>* i_ValueTuple_3_int_int_int() noexcept {
      return reinterpret_cast<::System::Collections::Generic::IReadOnlyCollection_1<::System::ValueTuple_3<int, int, int>>*>(this);
    }
    // Get instance field reference: private readonly IndexFilter/IndexFilterRandomType _random
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::IndexFilter::IndexFilterRandomType& dyn__random();
    // Get instance field reference: private readonly System.Int32 _seed
    [[deprecated("Use field access instead!")]] int& dyn__seed();
    // Get instance field reference: private readonly System.Int32 _groupSize
    [[deprecated("Use field access instead!")]] int& dyn__groupSize();
    // Get instance field reference: private readonly System.Int32 _chunkSize
    [[deprecated("Use field access instead!")]] int& dyn__chunkSize();
    // Get instance field reference: private readonly System.Int32 _visibleCount
    [[deprecated("Use field access instead!")]] int& dyn__visibleCount();
    // Get instance field reference: private readonly IndexFilter/IndexFilterLimitAlsoAffectType _limitAlsoAffectType
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType& dyn__limitAlsoAffectType();
    // Get instance field reference: private readonly System.Int32 _start
    [[deprecated("Use field access instead!")]] int& dyn__start();
    // Get instance field reference: private readonly System.Int32 _step
    [[deprecated("Use field access instead!")]] int& dyn__step();
    // Get instance field reference: private readonly System.Int32 _count
    [[deprecated("Use field access instead!")]] int& dyn__count();
    // public System.Int32 get_Count()
    // Offset: 0x139D440
    int get_Count();
    // public System.Int32 get_VisibleCount()
    // Offset: 0x139D448
    int get_VisibleCount();
    // public IndexFilter/IndexFilterLimitAlsoAffectType get_limitAlsoAffectType()
    // Offset: 0x139D450
    ::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType get_limitAlsoAffectType();
    // public System.Void .ctor(System.Int32 start, System.Int32 step, System.Int32 count, System.Int32 groupSize, IndexFilter/IndexFilterRandomType random, System.Int32 seed, System.Int32 chunkSize, System.Single limit, IndexFilter/IndexFilterLimitAlsoAffectType limitAlsoAffectType)
    // Offset: 0x139D458
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static IndexFilter* New_ctor(int start, int step, int count, int groupSize, ::GlobalNamespace::IndexFilter::IndexFilterRandomType random, int seed, int chunkSize, float limit, ::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType limitAlsoAffectType) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::IndexFilter::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<IndexFilter*, creationType>(start, step, count, groupSize, random, seed, chunkSize, limit, limitAlsoAffectType)));
    }
    // public System.Void .ctor(System.Int32 start, System.Int32 end, System.Int32 groupSize, IndexFilter/IndexFilterRandomType random, System.Int32 seed, System.Int32 chunkSize, System.Single limit, IndexFilter/IndexFilterLimitAlsoAffectType limitAlsoAffectType)
    // Offset: 0x139D54C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static IndexFilter* New_ctor(int start, int end, int groupSize, ::GlobalNamespace::IndexFilter::IndexFilterRandomType random, int seed, int chunkSize, float limit, ::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType limitAlsoAffectType) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::IndexFilter::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<IndexFilter*, creationType>(start, end, groupSize, random, seed, chunkSize, limit, limitAlsoAffectType)));
    }
    // public System.Collections.Generic.IEnumerator`1<System.ValueTuple`3<System.Int32,System.Int32,System.Int32>> GetEnumerator()
    // Offset: 0x139D64C
    ::System::Collections::Generic::IEnumerator_1<::System::ValueTuple_3<int, int, int>>* GetEnumerator();
    // private System.Collections.Generic.IEnumerable`1<System.Int32> GetValues()
    // Offset: 0x139D6E8
    ::System::Collections::Generic::IEnumerable_1<int>* GetValues();
    // private System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    // Offset: 0x139D7A0
    ::System::Collections::IEnumerator* System_Collections_IEnumerable_GetEnumerator();
  }; // IndexFilter
  #pragma pack(pop)
  static check_size<sizeof(IndexFilter), 48 + sizeof(int)> __GlobalNamespace_IndexFilterSizeCheck;
  static_assert(sizeof(IndexFilter) == 0x34);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType, "", "IndexFilter/IndexFilterLimitAlsoAffectType");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::IndexFilter::IndexFilterRandomType, "", "IndexFilter/IndexFilterRandomType");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::IndexFilter::get_Count
// Il2CppName: get_Count
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (GlobalNamespace::IndexFilter::*)()>(&GlobalNamespace::IndexFilter::get_Count)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::IndexFilter*), "get_Count", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::IndexFilter::get_VisibleCount
// Il2CppName: get_VisibleCount
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (GlobalNamespace::IndexFilter::*)()>(&GlobalNamespace::IndexFilter::get_VisibleCount)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::IndexFilter*), "get_VisibleCount", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::IndexFilter::get_limitAlsoAffectType
// Il2CppName: get_limitAlsoAffectType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::IndexFilter::IndexFilterLimitAlsoAffectType (GlobalNamespace::IndexFilter::*)()>(&GlobalNamespace::IndexFilter::get_limitAlsoAffectType)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::IndexFilter*), "get_limitAlsoAffectType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::IndexFilter::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GlobalNamespace::IndexFilter::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GlobalNamespace::IndexFilter::GetEnumerator
// Il2CppName: GetEnumerator
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerator_1<::System::ValueTuple_3<int, int, int>>* (GlobalNamespace::IndexFilter::*)()>(&GlobalNamespace::IndexFilter::GetEnumerator)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::IndexFilter*), "GetEnumerator", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::IndexFilter::GetValues
// Il2CppName: GetValues
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerable_1<int>* (GlobalNamespace::IndexFilter::*)()>(&GlobalNamespace::IndexFilter::GetValues)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::IndexFilter*), "GetValues", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::IndexFilter::System_Collections_IEnumerable_GetEnumerator
// Il2CppName: System.Collections.IEnumerable.GetEnumerator
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::IndexFilter::*)()>(&GlobalNamespace::IndexFilter::System_Collections_IEnumerable_GetEnumerator)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::IndexFilter*), "System.Collections.IEnumerable.GetEnumerator", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
