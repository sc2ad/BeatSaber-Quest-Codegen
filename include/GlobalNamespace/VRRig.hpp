// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Photon.Pun.MonoBehaviourPun
#include "Photon/Pun/MonoBehaviourPun.hpp"
// Including type: Photon.Pun.IPunObservable
#include "Photon/Pun/IPunObservable.hpp"
// Including type: Photon.Pun.IPunInstantiateMagicCallback
#include "Photon/Pun/IPunInstantiateMagicCallback.hpp"
// Including type: GorillaNetworking.CosmeticsController/GorillaNetworking.CosmeticItem
#include "GorillaNetworking/CosmeticsController_CosmeticItem.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: VRMap
  class VRMap;
  // Forward declaring type: VRMapThumb
  class VRMapThumb;
  // Forward declaring type: VRMapIndex
  class VRMapIndex;
  // Forward declaring type: VRMapMiddle
  class VRMapMiddle;
  // Forward declaring type: ActionableItem
  class ActionableItem;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: AudioSource
  class AudioSource;
  // Forward declaring type: AudioClip
  class AudioClip;
  // Forward declaring type: SkinnedMeshRenderer
  class SkinnedMeshRenderer;
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: ParticleSystem
  class ParticleSystem;
}
// Forward declaring namespace: Photon::Realtime
namespace Photon::Realtime {
  // Forward declaring type: Player
  class Player;
}
// Forward declaring namespace: UnityEngine::UI
namespace UnityEngine::UI {
  // Forward declaring type: Text
  class Text;
}
// Forward declaring namespace: Photon::Voice::PUN
namespace Photon::Voice::PUN {
  // Forward declaring type: PhotonVoiceView
  class PhotonVoiceView;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Forward declaring namespace: Photon::Pun
namespace Photon::Pun {
  // Forward declaring type: PhotonMessageInfo
  struct PhotonMessageInfo;
  // Forward declaring type: PhotonStream
  class PhotonStream;
}
// Forward declaring namespace: PlayFab::ClientModels
namespace PlayFab::ClientModels {
  // Forward declaring type: GetUserInventoryResult
  class GetUserInventoryResult;
}
// Forward declaring namespace: PlayFab
namespace PlayFab {
  // Forward declaring type: PlayFabError
  class PlayFabError;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: VRRig
  class VRRig;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::VRRig);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::VRRig*, "", "VRRig");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x2D8
  #pragma pack(push, 1)
  // Autogenerated type: VRRig
  // [TokenAttribute] Offset: FFFFFFFF
  class VRRig : public ::Photon::Pun::MonoBehaviourPun/*, public ::Photon::Pun::IPunObservable, public ::Photon::Pun::IPunInstantiateMagicCallback*/ {
    public:
    // Nested type: ::GlobalNamespace::VRRig::$OccasionalUpdate$d__87
    class $OccasionalUpdate$d__87;
    // Nested type: ::GlobalNamespace::VRRig::$$c
    class $$c;
    public:
    // public VRMap head
    // Size: 0x8
    // Offset: 0x20
    ::GlobalNamespace::VRMap* head;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRMap*) == 0x8);
    // public VRMap rightHand
    // Size: 0x8
    // Offset: 0x28
    ::GlobalNamespace::VRMap* rightHand;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRMap*) == 0x8);
    // public VRMap leftHand
    // Size: 0x8
    // Offset: 0x30
    ::GlobalNamespace::VRMap* leftHand;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRMap*) == 0x8);
    // public VRMapThumb leftThumb
    // Size: 0x8
    // Offset: 0x38
    ::GlobalNamespace::VRMapThumb* leftThumb;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRMapThumb*) == 0x8);
    // public VRMapIndex leftIndex
    // Size: 0x8
    // Offset: 0x40
    ::GlobalNamespace::VRMapIndex* leftIndex;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRMapIndex*) == 0x8);
    // public VRMapMiddle leftMiddle
    // Size: 0x8
    // Offset: 0x48
    ::GlobalNamespace::VRMapMiddle* leftMiddle;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRMapMiddle*) == 0x8);
    // public VRMapThumb rightThumb
    // Size: 0x8
    // Offset: 0x50
    ::GlobalNamespace::VRMapThumb* rightThumb;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRMapThumb*) == 0x8);
    // public VRMapIndex rightIndex
    // Size: 0x8
    // Offset: 0x58
    ::GlobalNamespace::VRMapIndex* rightIndex;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRMapIndex*) == 0x8);
    // public VRMapMiddle rightMiddle
    // Size: 0x8
    // Offset: 0x60
    ::GlobalNamespace::VRMapMiddle* rightMiddle;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRMapMiddle*) == 0x8);
    // public System.Boolean isOfflineVRRig
    // Size: 0x1
    // Offset: 0x68
    bool isOfflineVRRig;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isOfflineVRRig and: mainCamera
    char __padding9[0x7] = {};
    // public UnityEngine.GameObject mainCamera
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::GameObject* mainCamera;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public UnityEngine.Transform playerOffsetTransform
    // Size: 0x8
    // Offset: 0x78
    ::UnityEngine::Transform* playerOffsetTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public System.Int32 SDKIndex
    // Size: 0x4
    // Offset: 0x80
    int SDKIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Boolean isMyPlayer
    // Size: 0x1
    // Offset: 0x84
    bool isMyPlayer;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isMyPlayer and: leftHandPlayer
    char __padding13[0x3] = {};
    // public UnityEngine.AudioSource leftHandPlayer
    // Size: 0x8
    // Offset: 0x88
    ::UnityEngine::AudioSource* leftHandPlayer;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // public UnityEngine.AudioSource rightHandPlayer
    // Size: 0x8
    // Offset: 0x90
    ::UnityEngine::AudioSource* rightHandPlayer;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // public UnityEngine.AudioSource tagSound
    // Size: 0x8
    // Offset: 0x98
    ::UnityEngine::AudioSource* tagSound;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private System.Single ratio
    // Size: 0x4
    // Offset: 0xA0
    float ratio;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: ratio and: headConstraint
    char __padding17[0x4] = {};
    // public UnityEngine.Transform headConstraint
    // Size: 0x8
    // Offset: 0xA8
    ::UnityEngine::Transform* headConstraint;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Vector3 headBodyOffset
    // Size: 0xC
    // Offset: 0xB0
    ::UnityEngine::Vector3 headBodyOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // Padding between fields: headBodyOffset and: headMesh
    char __padding19[0x4] = {};
    // public UnityEngine.GameObject headMesh
    // Size: 0x8
    // Offset: 0xC0
    ::UnityEngine::GameObject* headMesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public UnityEngine.Vector3 syncPos
    // Size: 0xC
    // Offset: 0xC8
    ::UnityEngine::Vector3 syncPos;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Quaternion syncRotation
    // Size: 0x10
    // Offset: 0xD4
    ::UnityEngine::Quaternion syncRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // Padding between fields: syncRotation and: clipToPlay
    char __padding22[0x4] = {};
    // public UnityEngine.AudioClip[] clipToPlay
    // Size: 0x8
    // Offset: 0xE8
    ::ArrayW<::UnityEngine::AudioClip*> clipToPlay;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::AudioClip*>) == 0x8);
    // public UnityEngine.AudioClip[] handTapSound
    // Size: 0x8
    // Offset: 0xF0
    ::ArrayW<::UnityEngine::AudioClip*> handTapSound;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::AudioClip*>) == 0x8);
    // public System.Int32 currentMatIndex
    // Size: 0x4
    // Offset: 0xF8
    int currentMatIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 setMatIndex
    // Size: 0x4
    // Offset: 0xFC
    int setMatIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 tempMatIndex
    // Size: 0x4
    // Offset: 0x100
    int tempMatIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Single lerpValueFingers
    // Size: 0x4
    // Offset: 0x104
    float lerpValueFingers;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single lerpValueBody
    // Size: 0x4
    // Offset: 0x108
    float lerpValueBody;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: lerpValueBody and: backpack
    char __padding29[0x4] = {};
    // public UnityEngine.GameObject backpack
    // Size: 0x8
    // Offset: 0x110
    ::UnityEngine::GameObject* backpack;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public UnityEngine.Transform leftHandTransform
    // Size: 0x8
    // Offset: 0x118
    ::UnityEngine::Transform* leftHandTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform rightHandTransform
    // Size: 0x8
    // Offset: 0x120
    ::UnityEngine::Transform* rightHandTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.SkinnedMeshRenderer mainSkin
    // Size: 0x8
    // Offset: 0x128
    ::UnityEngine::SkinnedMeshRenderer* mainSkin;
    // Field size check
    static_assert(sizeof(::UnityEngine::SkinnedMeshRenderer*) == 0x8);
    // public Photon.Realtime.Player myPlayer
    // Size: 0x8
    // Offset: 0x130
    ::Photon::Realtime::Player* myPlayer;
    // Field size check
    static_assert(sizeof(::Photon::Realtime::Player*) == 0x8);
    // public UnityEngine.GameObject spectatorSkin
    // Size: 0x8
    // Offset: 0x138
    ::UnityEngine::GameObject* spectatorSkin;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public System.Int32 handSync
    // Size: 0x4
    // Offset: 0x140
    int handSync;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: handSync and: materialsToChangeTo
    char __padding36[0x4] = {};
    // public UnityEngine.Material[] materialsToChangeTo
    // Size: 0x8
    // Offset: 0x148
    ::ArrayW<::UnityEngine::Material*> materialsToChangeTo;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Material*>) == 0x8);
    // public System.Single red
    // Size: 0x4
    // Offset: 0x150
    float red;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single green
    // Size: 0x4
    // Offset: 0x154
    float green;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single blue
    // Size: 0x4
    // Offset: 0x158
    float blue;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: blue and: playerName
    char __padding40[0x4] = {};
    // public System.String playerName
    // Size: 0x8
    // Offset: 0x160
    ::StringW playerName;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public UnityEngine.UI.Text playerText
    // Size: 0x8
    // Offset: 0x168
    ::UnityEngine::UI::Text* playerText;
    // Field size check
    static_assert(sizeof(::UnityEngine::UI::Text*) == 0x8);
    // public System.Boolean showName
    // Size: 0x1
    // Offset: 0x170
    bool showName;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: showName and: cosmetics
    char __padding43[0x7] = {};
    // public UnityEngine.GameObject[] cosmetics
    // Size: 0x8
    // Offset: 0x178
    ::ArrayW<::UnityEngine::GameObject*> cosmetics;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::GameObject*>) == 0x8);
    // public System.String concatStringOfCosmeticsAllowed
    // Size: 0x8
    // Offset: 0x180
    ::StringW concatStringOfCosmeticsAllowed;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Boolean initializedCosmetics
    // Size: 0x1
    // Offset: 0x188
    bool initializedCosmetics;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: initializedCosmetics and: badge
    char __padding46[0x7] = {};
    // public System.String badge
    // Size: 0x8
    // Offset: 0x190
    ::StringW badge;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String face
    // Size: 0x8
    // Offset: 0x198
    ::StringW face;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String hat
    // Size: 0x8
    // Offset: 0x1A0
    ::StringW hat;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String leftHandHold
    // Size: 0x8
    // Offset: 0x1A8
    ::StringW leftHandHold;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String rightHandHold
    // Size: 0x8
    // Offset: 0x1B0
    ::StringW rightHandHold;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String tryOnRoomBadge
    // Size: 0x8
    // Offset: 0x1B8
    ::StringW tryOnRoomBadge;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String tryOnRoomFace
    // Size: 0x8
    // Offset: 0x1C0
    ::StringW tryOnRoomFace;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String tryOnRoomHat
    // Size: 0x8
    // Offset: 0x1C8
    ::StringW tryOnRoomHat;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String tryOnRoomLeftHandHold
    // Size: 0x8
    // Offset: 0x1D0
    ::StringW tryOnRoomLeftHandHold;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.String tryOnRoomRightHandHold
    // Size: 0x8
    // Offset: 0x1D8
    ::StringW tryOnRoomRightHandHold;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Boolean inTryOnRoom
    // Size: 0x1
    // Offset: 0x1E0
    bool inTryOnRoom;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean muted
    // Size: 0x1
    // Offset: 0x1E1
    bool muted;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: muted and: timeSpawned
    char __padding58[0x2] = {};
    // private System.Single timeSpawned
    // Size: 0x4
    // Offset: 0x1E4
    float timeSpawned;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single doNotLerpConstant
    // Size: 0x4
    // Offset: 0x1E8
    float doNotLerpConstant;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: doNotLerpConstant and: tempString
    char __padding60[0x4] = {};
    // public System.String tempString
    // Size: 0x8
    // Offset: 0x1F0
    ::StringW tempString;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // private Photon.Realtime.Player tempPlayer
    // Size: 0x8
    // Offset: 0x1F8
    ::Photon::Realtime::Player* tempPlayer;
    // Field size check
    static_assert(sizeof(::Photon::Realtime::Player*) == 0x8);
    // private VRRig tempRig
    // Size: 0x8
    // Offset: 0x200
    ::GlobalNamespace::VRRig* tempRig;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRRig*) == 0x8);
    // private System.Single[] speedArray
    // Size: 0x8
    // Offset: 0x208
    ::ArrayW<float> speedArray;
    // Field size check
    static_assert(sizeof(::ArrayW<float>) == 0x8);
    // private System.Double handLerpValues
    // Size: 0x8
    // Offset: 0x210
    double handLerpValues;
    // Field size check
    static_assert(sizeof(double) == 0x8);
    // private System.Boolean initialized
    // Size: 0x1
    // Offset: 0x218
    bool initialized;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: initialized and: lavaParticleSystem
    char __padding66[0x7] = {};
    // public UnityEngine.ParticleSystem lavaParticleSystem
    // Size: 0x8
    // Offset: 0x220
    ::UnityEngine::ParticleSystem* lavaParticleSystem;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem*) == 0x8);
    // public UnityEngine.ParticleSystem rockParticleSystem
    // Size: 0x8
    // Offset: 0x228
    ::UnityEngine::ParticleSystem* rockParticleSystem;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem*) == 0x8);
    // public UnityEngine.ParticleSystem iceParticleSystem
    // Size: 0x8
    // Offset: 0x230
    ::UnityEngine::ParticleSystem* iceParticleSystem;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem*) == 0x8);
    // public System.String tempItemName
    // Size: 0x8
    // Offset: 0x238
    ::StringW tempItemName;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public GorillaNetworking.CosmeticsController/GorillaNetworking.CosmeticItem tempItem
    // Size: 0x32
    // Offset: 0x240
    ::GorillaNetworking::CosmeticsController_CosmeticItem tempItem;
    // Field size check
    static_assert(sizeof(::GorillaNetworking::CosmeticsController_CosmeticItem) == 0x32);
    // Padding between fields: tempItem and: tempItemId
    char __padding71[0x6] = {};
    // public System.String tempItemId
    // Size: 0x8
    // Offset: 0x278
    ::StringW tempItemId;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Int32 tempItemCost
    // Size: 0x4
    // Offset: 0x280
    int tempItemCost;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 leftHandHoldableStatus
    // Size: 0x4
    // Offset: 0x284
    int leftHandHoldableStatus;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 rightHandHoldableStatus
    // Size: 0x4
    // Offset: 0x288
    int rightHandHoldableStatus;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: rightHandHoldableStatus and: musicDrums
    char __padding75[0x4] = {};
    // public UnityEngine.AudioSource[] musicDrums
    // Size: 0x8
    // Offset: 0x290
    ::ArrayW<::UnityEngine::AudioSource*> musicDrums;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::AudioSource*>) == 0x8);
    // public ActionableItem[] instrumentSelfOnly
    // Size: 0x8
    // Offset: 0x298
    ::ArrayW<::GlobalNamespace::ActionableItem*> instrumentSelfOnly;
    // Field size check
    static_assert(sizeof(::ArrayW<::GlobalNamespace::ActionableItem*>) == 0x8);
    // public System.Single bonkTime
    // Size: 0x4
    // Offset: 0x2A0
    float bonkTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single bonkCooldown
    // Size: 0x4
    // Offset: 0x2A4
    float bonkCooldown;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean isQuitting
    // Size: 0x1
    // Offset: 0x2A8
    bool isQuitting;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isQuitting and: tempVRRig
    char __padding80[0x7] = {};
    // private VRRig tempVRRig
    // Size: 0x8
    // Offset: 0x2B0
    ::GlobalNamespace::VRRig* tempVRRig;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRRig*) == 0x8);
    // public UnityEngine.GameObject huntComputer
    // Size: 0x8
    // Offset: 0x2B8
    ::UnityEngine::GameObject* huntComputer;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public System.Boolean kickMe
    // Size: 0x1
    // Offset: 0x2C0
    bool kickMe;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: kickMe and: myPhotonVoiceView
    char __padding83[0x7] = {};
    // private Photon.Voice.PUN.PhotonVoiceView myPhotonVoiceView
    // Size: 0x8
    // Offset: 0x2C8
    ::Photon::Voice::PUN::PhotonVoiceView* myPhotonVoiceView;
    // Field size check
    static_assert(sizeof(::Photon::Voice::PUN::PhotonVoiceView*) == 0x8);
    // private VRRig senderRig
    // Size: 0x8
    // Offset: 0x2D0
    ::GlobalNamespace::VRRig* senderRig;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRRig*) == 0x8);
    public:
    // Creating interface conversion operator: operator ::Photon::Pun::IPunObservable
    operator ::Photon::Pun::IPunObservable() noexcept {
      return *reinterpret_cast<::Photon::Pun::IPunObservable*>(this);
    }
    // Creating interface conversion operator: operator ::Photon::Pun::IPunInstantiateMagicCallback
    operator ::Photon::Pun::IPunInstantiateMagicCallback() noexcept {
      return *reinterpret_cast<::Photon::Pun::IPunInstantiateMagicCallback*>(this);
    }
    // Get instance field reference: public VRMap head
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRMap*& dyn_head();
    // Get instance field reference: public VRMap rightHand
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRMap*& dyn_rightHand();
    // Get instance field reference: public VRMap leftHand
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRMap*& dyn_leftHand();
    // Get instance field reference: public VRMapThumb leftThumb
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRMapThumb*& dyn_leftThumb();
    // Get instance field reference: public VRMapIndex leftIndex
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRMapIndex*& dyn_leftIndex();
    // Get instance field reference: public VRMapMiddle leftMiddle
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRMapMiddle*& dyn_leftMiddle();
    // Get instance field reference: public VRMapThumb rightThumb
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRMapThumb*& dyn_rightThumb();
    // Get instance field reference: public VRMapIndex rightIndex
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRMapIndex*& dyn_rightIndex();
    // Get instance field reference: public VRMapMiddle rightMiddle
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRMapMiddle*& dyn_rightMiddle();
    // Get instance field reference: public System.Boolean isOfflineVRRig
    [[deprecated("Use field access instead!")]] bool& dyn_isOfflineVRRig();
    // Get instance field reference: public UnityEngine.GameObject mainCamera
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_mainCamera();
    // Get instance field reference: public UnityEngine.Transform playerOffsetTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_playerOffsetTransform();
    // Get instance field reference: public System.Int32 SDKIndex
    [[deprecated("Use field access instead!")]] int& dyn_SDKIndex();
    // Get instance field reference: public System.Boolean isMyPlayer
    [[deprecated("Use field access instead!")]] bool& dyn_isMyPlayer();
    // Get instance field reference: public UnityEngine.AudioSource leftHandPlayer
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_leftHandPlayer();
    // Get instance field reference: public UnityEngine.AudioSource rightHandPlayer
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_rightHandPlayer();
    // Get instance field reference: public UnityEngine.AudioSource tagSound
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_tagSound();
    // Get instance field reference: private System.Single ratio
    [[deprecated("Use field access instead!")]] float& dyn_ratio();
    // Get instance field reference: public UnityEngine.Transform headConstraint
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_headConstraint();
    // Get instance field reference: public UnityEngine.Vector3 headBodyOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_headBodyOffset();
    // Get instance field reference: public UnityEngine.GameObject headMesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_headMesh();
    // Get instance field reference: public UnityEngine.Vector3 syncPos
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_syncPos();
    // Get instance field reference: public UnityEngine.Quaternion syncRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_syncRotation();
    // Get instance field reference: public UnityEngine.AudioClip[] clipToPlay
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::AudioClip*>& dyn_clipToPlay();
    // Get instance field reference: public UnityEngine.AudioClip[] handTapSound
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::AudioClip*>& dyn_handTapSound();
    // Get instance field reference: public System.Int32 currentMatIndex
    [[deprecated("Use field access instead!")]] int& dyn_currentMatIndex();
    // Get instance field reference: public System.Int32 setMatIndex
    [[deprecated("Use field access instead!")]] int& dyn_setMatIndex();
    // Get instance field reference: private System.Int32 tempMatIndex
    [[deprecated("Use field access instead!")]] int& dyn_tempMatIndex();
    // Get instance field reference: public System.Single lerpValueFingers
    [[deprecated("Use field access instead!")]] float& dyn_lerpValueFingers();
    // Get instance field reference: public System.Single lerpValueBody
    [[deprecated("Use field access instead!")]] float& dyn_lerpValueBody();
    // Get instance field reference: public UnityEngine.GameObject backpack
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_backpack();
    // Get instance field reference: public UnityEngine.Transform leftHandTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_leftHandTransform();
    // Get instance field reference: public UnityEngine.Transform rightHandTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_rightHandTransform();
    // Get instance field reference: public UnityEngine.SkinnedMeshRenderer mainSkin
    [[deprecated("Use field access instead!")]] ::UnityEngine::SkinnedMeshRenderer*& dyn_mainSkin();
    // Get instance field reference: public Photon.Realtime.Player myPlayer
    [[deprecated("Use field access instead!")]] ::Photon::Realtime::Player*& dyn_myPlayer();
    // Get instance field reference: public UnityEngine.GameObject spectatorSkin
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_spectatorSkin();
    // Get instance field reference: public System.Int32 handSync
    [[deprecated("Use field access instead!")]] int& dyn_handSync();
    // Get instance field reference: public UnityEngine.Material[] materialsToChangeTo
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Material*>& dyn_materialsToChangeTo();
    // Get instance field reference: public System.Single red
    [[deprecated("Use field access instead!")]] float& dyn_red();
    // Get instance field reference: public System.Single green
    [[deprecated("Use field access instead!")]] float& dyn_green();
    // Get instance field reference: public System.Single blue
    [[deprecated("Use field access instead!")]] float& dyn_blue();
    // Get instance field reference: public System.String playerName
    [[deprecated("Use field access instead!")]] ::StringW& dyn_playerName();
    // Get instance field reference: public UnityEngine.UI.Text playerText
    [[deprecated("Use field access instead!")]] ::UnityEngine::UI::Text*& dyn_playerText();
    // Get instance field reference: public System.Boolean showName
    [[deprecated("Use field access instead!")]] bool& dyn_showName();
    // Get instance field reference: public UnityEngine.GameObject[] cosmetics
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::GameObject*>& dyn_cosmetics();
    // Get instance field reference: public System.String concatStringOfCosmeticsAllowed
    [[deprecated("Use field access instead!")]] ::StringW& dyn_concatStringOfCosmeticsAllowed();
    // Get instance field reference: public System.Boolean initializedCosmetics
    [[deprecated("Use field access instead!")]] bool& dyn_initializedCosmetics();
    // Get instance field reference: public System.String badge
    [[deprecated("Use field access instead!")]] ::StringW& dyn_badge();
    // Get instance field reference: public System.String face
    [[deprecated("Use field access instead!")]] ::StringW& dyn_face();
    // Get instance field reference: public System.String hat
    [[deprecated("Use field access instead!")]] ::StringW& dyn_hat();
    // Get instance field reference: public System.String leftHandHold
    [[deprecated("Use field access instead!")]] ::StringW& dyn_leftHandHold();
    // Get instance field reference: public System.String rightHandHold
    [[deprecated("Use field access instead!")]] ::StringW& dyn_rightHandHold();
    // Get instance field reference: public System.String tryOnRoomBadge
    [[deprecated("Use field access instead!")]] ::StringW& dyn_tryOnRoomBadge();
    // Get instance field reference: public System.String tryOnRoomFace
    [[deprecated("Use field access instead!")]] ::StringW& dyn_tryOnRoomFace();
    // Get instance field reference: public System.String tryOnRoomHat
    [[deprecated("Use field access instead!")]] ::StringW& dyn_tryOnRoomHat();
    // Get instance field reference: public System.String tryOnRoomLeftHandHold
    [[deprecated("Use field access instead!")]] ::StringW& dyn_tryOnRoomLeftHandHold();
    // Get instance field reference: public System.String tryOnRoomRightHandHold
    [[deprecated("Use field access instead!")]] ::StringW& dyn_tryOnRoomRightHandHold();
    // Get instance field reference: public System.Boolean inTryOnRoom
    [[deprecated("Use field access instead!")]] bool& dyn_inTryOnRoom();
    // Get instance field reference: public System.Boolean muted
    [[deprecated("Use field access instead!")]] bool& dyn_muted();
    // Get instance field reference: private System.Single timeSpawned
    [[deprecated("Use field access instead!")]] float& dyn_timeSpawned();
    // Get instance field reference: public System.Single doNotLerpConstant
    [[deprecated("Use field access instead!")]] float& dyn_doNotLerpConstant();
    // Get instance field reference: public System.String tempString
    [[deprecated("Use field access instead!")]] ::StringW& dyn_tempString();
    // Get instance field reference: private Photon.Realtime.Player tempPlayer
    [[deprecated("Use field access instead!")]] ::Photon::Realtime::Player*& dyn_tempPlayer();
    // Get instance field reference: private VRRig tempRig
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRRig*& dyn_tempRig();
    // Get instance field reference: private System.Single[] speedArray
    [[deprecated("Use field access instead!")]] ::ArrayW<float>& dyn_speedArray();
    // Get instance field reference: private System.Double handLerpValues
    [[deprecated("Use field access instead!")]] double& dyn_handLerpValues();
    // Get instance field reference: private System.Boolean initialized
    [[deprecated("Use field access instead!")]] bool& dyn_initialized();
    // Get instance field reference: public UnityEngine.ParticleSystem lavaParticleSystem
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem*& dyn_lavaParticleSystem();
    // Get instance field reference: public UnityEngine.ParticleSystem rockParticleSystem
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem*& dyn_rockParticleSystem();
    // Get instance field reference: public UnityEngine.ParticleSystem iceParticleSystem
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem*& dyn_iceParticleSystem();
    // Get instance field reference: public System.String tempItemName
    [[deprecated("Use field access instead!")]] ::StringW& dyn_tempItemName();
    // Get instance field reference: public GorillaNetworking.CosmeticsController/GorillaNetworking.CosmeticItem tempItem
    [[deprecated("Use field access instead!")]] ::GorillaNetworking::CosmeticsController_CosmeticItem& dyn_tempItem();
    // Get instance field reference: public System.String tempItemId
    [[deprecated("Use field access instead!")]] ::StringW& dyn_tempItemId();
    // Get instance field reference: public System.Int32 tempItemCost
    [[deprecated("Use field access instead!")]] int& dyn_tempItemCost();
    // Get instance field reference: public System.Int32 leftHandHoldableStatus
    [[deprecated("Use field access instead!")]] int& dyn_leftHandHoldableStatus();
    // Get instance field reference: public System.Int32 rightHandHoldableStatus
    [[deprecated("Use field access instead!")]] int& dyn_rightHandHoldableStatus();
    // Get instance field reference: public UnityEngine.AudioSource[] musicDrums
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::AudioSource*>& dyn_musicDrums();
    // Get instance field reference: public ActionableItem[] instrumentSelfOnly
    [[deprecated("Use field access instead!")]] ::ArrayW<::GlobalNamespace::ActionableItem*>& dyn_instrumentSelfOnly();
    // Get instance field reference: public System.Single bonkTime
    [[deprecated("Use field access instead!")]] float& dyn_bonkTime();
    // Get instance field reference: public System.Single bonkCooldown
    [[deprecated("Use field access instead!")]] float& dyn_bonkCooldown();
    // Get instance field reference: public System.Boolean isQuitting
    [[deprecated("Use field access instead!")]] bool& dyn_isQuitting();
    // Get instance field reference: private VRRig tempVRRig
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRRig*& dyn_tempVRRig();
    // Get instance field reference: public UnityEngine.GameObject huntComputer
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_huntComputer();
    // Get instance field reference: public System.Boolean kickMe
    [[deprecated("Use field access instead!")]] bool& dyn_kickMe();
    // Get instance field reference: private Photon.Voice.PUN.PhotonVoiceView myPhotonVoiceView
    [[deprecated("Use field access instead!")]] ::Photon::Voice::PUN::PhotonVoiceView*& dyn_myPhotonVoiceView();
    // Get instance field reference: private VRRig senderRig
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRRig*& dyn_senderRig();
    // public System.Void .ctor()
    // Offset: 0xD0339C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static VRRig* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::VRRig::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<VRRig*, creationType>()));
    }
    // private System.Void Start()
    // Offset: 0xCFCC78
    void Start();
    // private System.Collections.IEnumerator OccasionalUpdate()
    // Offset: 0xCFDA3C
    ::System::Collections::IEnumerator* OccasionalUpdate();
    // private System.Void LateUpdate()
    // Offset: 0xCFDAD8
    void LateUpdate();
    // public System.Void OnDestroy()
    // Offset: 0xCFF32C
    void OnDestroy();
    // public System.Void SetHeadBodyOffset()
    // Offset: 0xCFF4D8
    void SetHeadBodyOffset();
    // public System.Void VRRigResize(System.Single ratioVar)
    // Offset: 0xCFF4DC
    void VRRigResize(float ratioVar);
    // public System.Int32 ReturnHandPosition()
    // Offset: 0xCFF4EC
    int ReturnHandPosition();
    // private System.Void Photon.Pun.IPunInstantiateMagicCallback.OnPhotonInstantiate(Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xCFF660
    void Photon_Pun_IPunInstantiateMagicCallback_OnPhotonInstantiate(::Photon::Pun::PhotonMessageInfo info);
    // private System.Void Photon.Pun.IPunObservable.OnPhotonSerializeView(Photon.Pun.PhotonStream stream, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xCFFA18
    void Photon_Pun_IPunObservable_OnPhotonSerializeView(::Photon::Pun::PhotonStream* stream, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void ChangeMaterial(System.Int32 materialIndex, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD00178
    void ChangeMaterial(int materialIndex, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void ChangeMaterialLocal(System.Int32 materialIndex)
    // Offset: 0xCFF0C0
    void ChangeMaterialLocal(int materialIndex);
    // public System.Void InitializeNoobMaterial(System.Single red, System.Single green, System.Single blue, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD00214
    void InitializeNoobMaterial(float red, float green, float blue, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void InitializeNoobMaterialLocal(System.Single red, System.Single green, System.Single blue)
    // Offset: 0xCFD8C0
    void InitializeNoobMaterialLocal(float red, float green, float blue);
    // public System.String NormalizeName(System.Boolean doIt, System.String text)
    // Offset: 0xD00438
    ::StringW NormalizeName(bool doIt, ::StringW text);
    // public System.Void SetJumpLimit(System.Single maxJumpSpeed, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD005D8
    void SetJumpLimit(float maxJumpSpeed, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void SetJumpLimitLocal(System.Single maxJumpSpeed)
    // Offset: 0xD007CC
    void SetJumpLimitLocal(float maxJumpSpeed);
    // public System.Void SetJumpMultiplier(System.Single jumpMultiplier, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD00834
    void SetJumpMultiplier(float jumpMultiplier, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void SetJumpMultiplierLocal(System.Single jumpMultiplier)
    // Offset: 0xD00A28
    void SetJumpMultiplierLocal(float jumpMultiplier);
    // public System.Void SetTaggedTime(Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD00A90
    void SetTaggedTime(::Photon::Pun::PhotonMessageInfo info);
    // public System.Void SetSlowedTime(Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD00CE8
    void SetSlowedTime(::Photon::Pun::PhotonMessageInfo info);
    // public System.Void SetJoinTaggedTime(Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD00F4C
    void SetJoinTaggedTime(::Photon::Pun::PhotonMessageInfo info);
    // public System.Void RequestMaterialColor(Photon.Realtime.Player askingPlayer, System.Boolean noneBool)
    // Offset: 0xD01110
    void RequestMaterialColor(::Photon::Realtime::Player* askingPlayer, bool noneBool);
    // public System.Void RequestCosmetics(Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD012F4
    void RequestCosmetics(::Photon::Pun::PhotonMessageInfo info);
    // public System.Void PlayTagSound(System.Int32 soundIndex, System.Single soundVolume, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD016AC
    void PlayTagSound(int soundIndex, float soundVolume, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void Bonk(System.Int32 soundIndex, System.Single bonkPercent, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD01858
    void Bonk(int soundIndex, float bonkPercent, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void PlayDrum(System.Int32 drumIndex, System.Single drumVolume, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD01AD4
    void PlayDrum(int drumIndex, float drumVolume, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void PlaySelfOnlyInstrument(System.Int32 selfOnlyIndex, System.Int32 noteIndex, System.Single instrumentVol, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD020CC
    void PlaySelfOnlyInstrument(int selfOnlyIndex, int noteIndex, float instrumentVol, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void PlayHandTap(System.Int32 soundIndex, System.Boolean isLeftHand, System.Single tapVolume, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD02378
    void PlayHandTap(int soundIndex, bool isLeftHand, float tapVolume, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void PlayHandTapLocal(System.Int32 soundIndex, System.Boolean isLeftHand, System.Single tapVolume)
    // Offset: 0xCFA3C4
    void PlayHandTapLocal(int soundIndex, bool isLeftHand, float tapVolume);
    // public System.Void UpdateCosmetics(System.String newBadge, System.String newFace, System.String newHat, System.String newLeftHandHold, System.String newRightHandHold, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD02508
    void UpdateCosmetics(::StringW newBadge, ::StringW newFace, ::StringW newHat, ::StringW newLeftHandHold, ::StringW newRightHandHold, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void UpdateCosmeticsWithTryon(System.String newBadge, System.String newFace, System.String newHat, System.String newLeftHandHold, System.String newRightHandHold, System.String tryOnBadge, System.String tryOnFace, System.String tryOnHat, System.String tryOnLeftHandHold, System.String tryOnRightHandHold, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0xD026AC
    void UpdateCosmeticsWithTryon(::StringW newBadge, ::StringW newFace, ::StringW newHat, ::StringW newLeftHandHold, ::StringW newRightHandHold, ::StringW tryOnBadge, ::StringW tryOnFace, ::StringW tryOnHat, ::StringW tryOnLeftHandHold, ::StringW tryOnRightHandHold, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void UpdateAllowedCosmetics()
    // Offset: 0xD028A8
    void UpdateAllowedCosmetics();
    // public System.Void LocalUpdateCosmetics(System.String newBadge, System.String newFace, System.String newHat, System.String newLeftHandHold, System.String newRightHandHold)
    // Offset: 0xD02690
    void LocalUpdateCosmetics(::StringW newBadge, ::StringW newFace, ::StringW newHat, ::StringW newLeftHandHold, ::StringW newRightHandHold);
    // public System.Void LocalUpdateCosmeticsWithTryon(System.String newBadge, System.String newFace, System.String newHat, System.String newLeftHandHold, System.String newRightHandHold, System.String tryOnBadge, System.String tryOnFace, System.String tryOnHat, System.String tryOnLeftHandHold, System.String tryOnRightHandHold)
    // Offset: 0xD02874
    void LocalUpdateCosmeticsWithTryon(::StringW newBadge, ::StringW newFace, ::StringW newHat, ::StringW newLeftHandHold, ::StringW newRightHandHold, ::StringW tryOnBadge, ::StringW tryOnFace, ::StringW tryOnHat, ::StringW tryOnLeftHandHold, ::StringW tryOnRightHandHold);
    // private System.Void CheckForEarlyAccess()
    // Offset: 0xCFE650
    void CheckForEarlyAccess();
    // public System.Void SetCosmeticsActive()
    // Offset: 0xCFE6D4
    void SetCosmeticsActive();
    // public System.Void GetUserCosmeticsAllowed()
    // Offset: 0xD029B0
    void GetUserCosmeticsAllowed();
    // private System.Void Quitting()
    // Offset: 0xD02B10
    void Quitting();
    // public System.Void GenerateFingerAngleLookupTables()
    // Offset: 0xD02B1C
    void GenerateFingerAngleLookupTables();
    // private System.Void GenerateTableThumb(ref VRMapThumb thumb)
    // Offset: 0xD0310C
    void GenerateTableThumb(ByRef<::GlobalNamespace::VRMapThumb*> thumb);
    // private System.Void GenerateTableIndex(ref VRMapIndex index)
    // Offset: 0xD02B64
    void GenerateTableIndex(ByRef<::GlobalNamespace::VRMapIndex*> index);
    // private System.Void GenerateTableMiddle(ref VRMapMiddle middle)
    // Offset: 0xD02E38
    void GenerateTableMiddle(ByRef<::GlobalNamespace::VRMapMiddle*> middle);
    // private UnityEngine.Quaternion SanitizeQuaternion(UnityEngine.Quaternion quat)
    // Offset: 0xCFFF2C
    ::UnityEngine::Quaternion SanitizeQuaternion(::UnityEngine::Quaternion quat);
    // private UnityEngine.Vector3 SanitizeVector3(UnityEngine.Vector3 vec)
    // Offset: 0xD00050
    ::UnityEngine::Vector3 SanitizeVector3(::UnityEngine::Vector3 vec);
    // private System.Void <GetUserCosmeticsAllowed>b__122_0(PlayFab.ClientModels.GetUserInventoryResult result)
    // Offset: 0xD0341C
    void $GetUserCosmeticsAllowed$b__122_0(::PlayFab::ClientModels::GetUserInventoryResult* result);
    // private System.Void <GetUserCosmeticsAllowed>b__122_1(PlayFab.PlayFabError error)
    // Offset: 0xD035D8
    void $GetUserCosmeticsAllowed$b__122_1(::PlayFab::PlayFabError* error);
  }; // VRRig
  #pragma pack(pop)
  static check_size<sizeof(VRRig), 720 + sizeof(::GlobalNamespace::VRRig*)> __GlobalNamespace_VRRigSizeCheck;
  static_assert(sizeof(VRRig) == 0x2D8);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::VRRig::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GlobalNamespace::VRRig::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::OccasionalUpdate
// Il2CppName: OccasionalUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::OccasionalUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "OccasionalUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SetHeadBodyOffset
// Il2CppName: SetHeadBodyOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::SetHeadBodyOffset)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SetHeadBodyOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::VRRigResize
// Il2CppName: VRRigResize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(float)>(&GlobalNamespace::VRRig::VRRigResize)> {
  static const MethodInfo* get() {
    static auto* ratioVar = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "VRRigResize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ratioVar});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::ReturnHandPosition
// Il2CppName: ReturnHandPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::ReturnHandPosition)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "ReturnHandPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::Photon_Pun_IPunInstantiateMagicCallback_OnPhotonInstantiate
// Il2CppName: Photon.Pun.IPunInstantiateMagicCallback.OnPhotonInstantiate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::Photon_Pun_IPunInstantiateMagicCallback_OnPhotonInstantiate)> {
  static const MethodInfo* get() {
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "Photon.Pun.IPunInstantiateMagicCallback.OnPhotonInstantiate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::Photon_Pun_IPunObservable_OnPhotonSerializeView
// Il2CppName: Photon.Pun.IPunObservable.OnPhotonSerializeView
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::Photon::Pun::PhotonStream*, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::Photon_Pun_IPunObservable_OnPhotonSerializeView)> {
  static const MethodInfo* get() {
    static auto* stream = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonStream")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "Photon.Pun.IPunObservable.OnPhotonSerializeView", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{stream, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::ChangeMaterial
// Il2CppName: ChangeMaterial
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(int, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::ChangeMaterial)> {
  static const MethodInfo* get() {
    static auto* materialIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "ChangeMaterial", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{materialIndex, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::ChangeMaterialLocal
// Il2CppName: ChangeMaterialLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(int)>(&GlobalNamespace::VRRig::ChangeMaterialLocal)> {
  static const MethodInfo* get() {
    static auto* materialIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "ChangeMaterialLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{materialIndex});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::InitializeNoobMaterial
// Il2CppName: InitializeNoobMaterial
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(float, float, float, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::InitializeNoobMaterial)> {
  static const MethodInfo* get() {
    static auto* red = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* green = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* blue = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "InitializeNoobMaterial", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{red, green, blue, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::InitializeNoobMaterialLocal
// Il2CppName: InitializeNoobMaterialLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(float, float, float)>(&GlobalNamespace::VRRig::InitializeNoobMaterialLocal)> {
  static const MethodInfo* get() {
    static auto* red = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* green = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* blue = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "InitializeNoobMaterialLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{red, green, blue});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::NormalizeName
// Il2CppName: NormalizeName
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (GlobalNamespace::VRRig::*)(bool, ::StringW)>(&GlobalNamespace::VRRig::NormalizeName)> {
  static const MethodInfo* get() {
    static auto* doIt = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* text = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "NormalizeName", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{doIt, text});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SetJumpLimit
// Il2CppName: SetJumpLimit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(float, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::SetJumpLimit)> {
  static const MethodInfo* get() {
    static auto* maxJumpSpeed = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SetJumpLimit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{maxJumpSpeed, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SetJumpLimitLocal
// Il2CppName: SetJumpLimitLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(float)>(&GlobalNamespace::VRRig::SetJumpLimitLocal)> {
  static const MethodInfo* get() {
    static auto* maxJumpSpeed = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SetJumpLimitLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{maxJumpSpeed});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SetJumpMultiplier
// Il2CppName: SetJumpMultiplier
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(float, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::SetJumpMultiplier)> {
  static const MethodInfo* get() {
    static auto* jumpMultiplier = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SetJumpMultiplier", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{jumpMultiplier, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SetJumpMultiplierLocal
// Il2CppName: SetJumpMultiplierLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(float)>(&GlobalNamespace::VRRig::SetJumpMultiplierLocal)> {
  static const MethodInfo* get() {
    static auto* jumpMultiplier = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SetJumpMultiplierLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{jumpMultiplier});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SetTaggedTime
// Il2CppName: SetTaggedTime
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::SetTaggedTime)> {
  static const MethodInfo* get() {
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SetTaggedTime", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SetSlowedTime
// Il2CppName: SetSlowedTime
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::SetSlowedTime)> {
  static const MethodInfo* get() {
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SetSlowedTime", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SetJoinTaggedTime
// Il2CppName: SetJoinTaggedTime
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::SetJoinTaggedTime)> {
  static const MethodInfo* get() {
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SetJoinTaggedTime", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::RequestMaterialColor
// Il2CppName: RequestMaterialColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::Photon::Realtime::Player*, bool)>(&GlobalNamespace::VRRig::RequestMaterialColor)> {
  static const MethodInfo* get() {
    static auto* askingPlayer = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    static auto* noneBool = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "RequestMaterialColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{askingPlayer, noneBool});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::RequestCosmetics
// Il2CppName: RequestCosmetics
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::RequestCosmetics)> {
  static const MethodInfo* get() {
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "RequestCosmetics", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::PlayTagSound
// Il2CppName: PlayTagSound
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(int, float, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::PlayTagSound)> {
  static const MethodInfo* get() {
    static auto* soundIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* soundVolume = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "PlayTagSound", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{soundIndex, soundVolume, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::Bonk
// Il2CppName: Bonk
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(int, float, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::Bonk)> {
  static const MethodInfo* get() {
    static auto* soundIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* bonkPercent = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "Bonk", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{soundIndex, bonkPercent, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::PlayDrum
// Il2CppName: PlayDrum
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(int, float, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::PlayDrum)> {
  static const MethodInfo* get() {
    static auto* drumIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* drumVolume = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "PlayDrum", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{drumIndex, drumVolume, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::PlaySelfOnlyInstrument
// Il2CppName: PlaySelfOnlyInstrument
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(int, int, float, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::PlaySelfOnlyInstrument)> {
  static const MethodInfo* get() {
    static auto* selfOnlyIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* noteIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* instrumentVol = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "PlaySelfOnlyInstrument", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{selfOnlyIndex, noteIndex, instrumentVol, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::PlayHandTap
// Il2CppName: PlayHandTap
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(int, bool, float, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::PlayHandTap)> {
  static const MethodInfo* get() {
    static auto* soundIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* isLeftHand = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* tapVolume = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "PlayHandTap", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{soundIndex, isLeftHand, tapVolume, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::PlayHandTapLocal
// Il2CppName: PlayHandTapLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(int, bool, float)>(&GlobalNamespace::VRRig::PlayHandTapLocal)> {
  static const MethodInfo* get() {
    static auto* soundIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* isLeftHand = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* tapVolume = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "PlayHandTapLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{soundIndex, isLeftHand, tapVolume});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::UpdateCosmetics
// Il2CppName: UpdateCosmetics
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::UpdateCosmetics)> {
  static const MethodInfo* get() {
    static auto* newBadge = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newFace = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newHat = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newLeftHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newRightHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "UpdateCosmetics", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{newBadge, newFace, newHat, newLeftHandHold, newRightHandHold, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::UpdateCosmeticsWithTryon
// Il2CppName: UpdateCosmeticsWithTryon
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::VRRig::UpdateCosmeticsWithTryon)> {
  static const MethodInfo* get() {
    static auto* newBadge = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newFace = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newHat = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newLeftHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newRightHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnBadge = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnFace = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnHat = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnLeftHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnRightHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "UpdateCosmeticsWithTryon", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{newBadge, newFace, newHat, newLeftHandHold, newRightHandHold, tryOnBadge, tryOnFace, tryOnHat, tryOnLeftHandHold, tryOnRightHandHold, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::UpdateAllowedCosmetics
// Il2CppName: UpdateAllowedCosmetics
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::UpdateAllowedCosmetics)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "UpdateAllowedCosmetics", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::LocalUpdateCosmetics
// Il2CppName: LocalUpdateCosmetics
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::StringW, ::StringW, ::StringW, ::StringW, ::StringW)>(&GlobalNamespace::VRRig::LocalUpdateCosmetics)> {
  static const MethodInfo* get() {
    static auto* newBadge = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newFace = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newHat = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newLeftHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newRightHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "LocalUpdateCosmetics", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{newBadge, newFace, newHat, newLeftHandHold, newRightHandHold});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::LocalUpdateCosmeticsWithTryon
// Il2CppName: LocalUpdateCosmeticsWithTryon
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW, ::StringW)>(&GlobalNamespace::VRRig::LocalUpdateCosmeticsWithTryon)> {
  static const MethodInfo* get() {
    static auto* newBadge = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newFace = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newHat = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newLeftHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* newRightHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnBadge = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnFace = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnHat = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnLeftHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* tryOnRightHandHold = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "LocalUpdateCosmeticsWithTryon", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{newBadge, newFace, newHat, newLeftHandHold, newRightHandHold, tryOnBadge, tryOnFace, tryOnHat, tryOnLeftHandHold, tryOnRightHandHold});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::CheckForEarlyAccess
// Il2CppName: CheckForEarlyAccess
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::CheckForEarlyAccess)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "CheckForEarlyAccess", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SetCosmeticsActive
// Il2CppName: SetCosmeticsActive
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::SetCosmeticsActive)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SetCosmeticsActive", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::GetUserCosmeticsAllowed
// Il2CppName: GetUserCosmeticsAllowed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::GetUserCosmeticsAllowed)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "GetUserCosmeticsAllowed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::Quitting
// Il2CppName: Quitting
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::Quitting)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "Quitting", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::GenerateFingerAngleLookupTables
// Il2CppName: GenerateFingerAngleLookupTables
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)()>(&GlobalNamespace::VRRig::GenerateFingerAngleLookupTables)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "GenerateFingerAngleLookupTables", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::GenerateTableThumb
// Il2CppName: GenerateTableThumb
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(ByRef<::GlobalNamespace::VRMapThumb*>)>(&GlobalNamespace::VRRig::GenerateTableThumb)> {
  static const MethodInfo* get() {
    static auto* thumb = &::il2cpp_utils::GetClassFromName("", "VRMapThumb")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "GenerateTableThumb", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{thumb});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::GenerateTableIndex
// Il2CppName: GenerateTableIndex
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(ByRef<::GlobalNamespace::VRMapIndex*>)>(&GlobalNamespace::VRRig::GenerateTableIndex)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("", "VRMapIndex")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "GenerateTableIndex", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::GenerateTableMiddle
// Il2CppName: GenerateTableMiddle
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(ByRef<::GlobalNamespace::VRMapMiddle*>)>(&GlobalNamespace::VRRig::GenerateTableMiddle)> {
  static const MethodInfo* get() {
    static auto* middle = &::il2cpp_utils::GetClassFromName("", "VRMapMiddle")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "GenerateTableMiddle", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{middle});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SanitizeQuaternion
// Il2CppName: SanitizeQuaternion
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Quaternion (GlobalNamespace::VRRig::*)(::UnityEngine::Quaternion)>(&GlobalNamespace::VRRig::SanitizeQuaternion)> {
  static const MethodInfo* get() {
    static auto* quat = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SanitizeQuaternion", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{quat});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::SanitizeVector3
// Il2CppName: SanitizeVector3
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GlobalNamespace::VRRig::*)(::UnityEngine::Vector3)>(&GlobalNamespace::VRRig::SanitizeVector3)> {
  static const MethodInfo* get() {
    static auto* vec = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "SanitizeVector3", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{vec});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::$GetUserCosmeticsAllowed$b__122_0
// Il2CppName: <GetUserCosmeticsAllowed>b__122_0
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::PlayFab::ClientModels::GetUserInventoryResult*)>(&GlobalNamespace::VRRig::$GetUserCosmeticsAllowed$b__122_0)> {
  static const MethodInfo* get() {
    static auto* result = &::il2cpp_utils::GetClassFromName("PlayFab.ClientModels", "GetUserInventoryResult")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "<GetUserCosmeticsAllowed>b__122_0", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{result});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::VRRig::$GetUserCosmeticsAllowed$b__122_1
// Il2CppName: <GetUserCosmeticsAllowed>b__122_1
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::VRRig::*)(::PlayFab::PlayFabError*)>(&GlobalNamespace::VRRig::$GetUserCosmeticsAllowed$b__122_1)> {
  static const MethodInfo* get() {
    static auto* error = &::il2cpp_utils::GetClassFromName("PlayFab", "PlayFabError")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::VRRig*), "<GetUserCosmeticsAllowed>b__122_1", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{error});
  }
};
