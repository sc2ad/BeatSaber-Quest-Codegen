// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: Unity.Jobs.JobHandle
#include "Unity/Jobs/JobHandle.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
// Including type: Unity.Jobs.IJob
#include "Unity/Jobs/IJob.hpp"
// Including type: Unity.Collections.NativeArray`1
#include "Unity/Collections/NativeArray_1.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: LightmapData
  class LightmapData;
  // Forward declaring type: Texture2D
  class Texture2D;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Skipping declaration: IEnumerator because it is already included!
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: DayNightCycle
  class DayNightCycle;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::DayNightCycle);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::DayNightCycle*, "", "DayNightCycle");
// Type namespace: 
namespace GlobalNamespace {
  // WARNING Size may be invalid!
  // Autogenerated type: DayNightCycle
  // [TokenAttribute] Offset: FFFFFFFF
  class DayNightCycle : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::DayNightCycle::LerpBakedLightingJob
    struct LerpBakedLightingJob;
    // Nested type: ::GlobalNamespace::DayNightCycle::$UpdateWork$d__37
    class $UpdateWork$d__37;
    // WARNING Size may be invalid!
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: DayNightCycle/LerpBakedLightingJob
    // [TokenAttribute] Offset: FFFFFFFF
    struct LerpBakedLightingJob/*, public ::System::ValueType, public ::Unity::Jobs::IJob*/ {
      public:
      public:
      // public Unity.Collections.NativeArray`1<UnityEngine.Color> fromPixels
      // Size: 0xFFFFFFFF
      // Offset: 0x0
      ::Unity::Collections::NativeArray_1<::UnityEngine::Color> fromPixels;
      // public Unity.Collections.NativeArray`1<UnityEngine.Color> toPixels
      // Size: 0xFFFFFFFF
      // Offset: 0x10
      ::Unity::Collections::NativeArray_1<::UnityEngine::Color> toPixels;
      // public Unity.Collections.NativeArray`1<UnityEngine.Color> mixedPixels
      // Size: 0xFFFFFFFF
      // Offset: 0x20
      ::Unity::Collections::NativeArray_1<::UnityEngine::Color> mixedPixels;
      // public System.Single lerpValue
      // Size: 0x4
      // Offset: 0x30
      float lerpValue;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      public:
      // Creating value type constructor for type: LerpBakedLightingJob
      constexpr LerpBakedLightingJob(::Unity::Collections::NativeArray_1<::UnityEngine::Color> fromPixels_ = {}, ::Unity::Collections::NativeArray_1<::UnityEngine::Color> toPixels_ = {}, ::Unity::Collections::NativeArray_1<::UnityEngine::Color> mixedPixels_ = {}, float lerpValue_ = {}) noexcept : fromPixels{fromPixels_}, toPixels{toPixels_}, mixedPixels{mixedPixels_}, lerpValue{lerpValue_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating interface conversion operator: operator ::Unity::Jobs::IJob
      operator ::Unity::Jobs::IJob() noexcept {
        return *reinterpret_cast<::Unity::Jobs::IJob*>(this);
      }
      // Get instance field reference: public Unity.Collections.NativeArray`1<UnityEngine.Color> fromPixels
      [[deprecated("Use field access instead!")]] ::Unity::Collections::NativeArray_1<::UnityEngine::Color>& dyn_fromPixels();
      // Get instance field reference: public Unity.Collections.NativeArray`1<UnityEngine.Color> toPixels
      [[deprecated("Use field access instead!")]] ::Unity::Collections::NativeArray_1<::UnityEngine::Color>& dyn_toPixels();
      // Get instance field reference: public Unity.Collections.NativeArray`1<UnityEngine.Color> mixedPixels
      [[deprecated("Use field access instead!")]] ::Unity::Collections::NativeArray_1<::UnityEngine::Color>& dyn_mixedPixels();
      // Get instance field reference: public System.Single lerpValue
      [[deprecated("Use field access instead!")]] float& dyn_lerpValue();
      // public System.Void Execute()
      // Offset: 0xA3B0E4
      void Execute();
    }; // DayNightCycle/LerpBakedLightingJob
    // WARNING Not writing size check since size may be invalid!
    public:
    // public UnityEngine.Texture2D _dayMap
    // Size: 0x8
    // Offset: 0x18
    ::UnityEngine::Texture2D* dayMap;
    // Field size check
    static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
    // private UnityEngine.Texture2D fromMap
    // Size: 0x8
    // Offset: 0x20
    ::UnityEngine::Texture2D* fromMap;
    // Field size check
    static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
    // public UnityEngine.Texture2D _sunriseMap
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::Texture2D* sunriseMap;
    // Field size check
    static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
    // private UnityEngine.Texture2D toMap
    // Size: 0x8
    // Offset: 0x30
    ::UnityEngine::Texture2D* toMap;
    // Field size check
    static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
    // public DayNightCycle/LerpBakedLightingJob job
    // Size: 0xFFFFFFFF
    // Offset: 0x38
    ::GlobalNamespace::DayNightCycle::LerpBakedLightingJob job;
    // public Unity.Jobs.JobHandle jobHandle
    // Size: 0xC
    // Offset: 0x70
    ::Unity::Jobs::JobHandle jobHandle;
    // Field size check
    static_assert(sizeof(::Unity::Jobs::JobHandle) == 0xC);
    // public System.Boolean isComplete
    // Size: 0x1
    // Offset: 0x80
    bool isComplete;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Single startTime
    // Size: 0x4
    // Offset: 0x84
    float startTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single timeTakenStartingJob
    // Size: 0x4
    // Offset: 0x88
    float timeTakenStartingJob;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single timeTakenPostJob
    // Size: 0x4
    // Offset: 0x8C
    float timeTakenPostJob;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single timeTakenDuringJob
    // Size: 0x4
    // Offset: 0x90
    float timeTakenDuringJob;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.LightmapData newData
    // Size: 0x8
    // Offset: 0x98
    ::UnityEngine::LightmapData* newData;
    // Field size check
    static_assert(sizeof(::UnityEngine::LightmapData*) == 0x8);
    // private UnityEngine.Color[] fromPixels
    // Size: 0x8
    // Offset: 0xA0
    ::ArrayW<::UnityEngine::Color> fromPixels;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Color>) == 0x8);
    // private UnityEngine.Color[] toPixels
    // Size: 0x8
    // Offset: 0xA8
    ::ArrayW<::UnityEngine::Color> toPixels;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Color>) == 0x8);
    // private UnityEngine.Color[] mixedPixels
    // Size: 0x8
    // Offset: 0xB0
    ::ArrayW<::UnityEngine::Color> mixedPixels;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Color>) == 0x8);
    // private UnityEngine.LightmapData[] newDatas
    // Size: 0x8
    // Offset: 0xB8
    ::ArrayW<::UnityEngine::LightmapData*> newDatas;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::LightmapData*>) == 0x8);
    // public UnityEngine.Texture2D newTexture
    // Size: 0x8
    // Offset: 0xC0
    ::UnityEngine::Texture2D* newTexture;
    // Field size check
    static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
    // public System.Int32 textureWidth
    // Size: 0x4
    // Offset: 0xC8
    int textureWidth;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 textureHeight
    // Size: 0x4
    // Offset: 0xCC
    int textureHeight;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private UnityEngine.Color[] workBlockFrom
    // Size: 0x8
    // Offset: 0xD0
    ::ArrayW<::UnityEngine::Color> workBlockFrom;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Color>) == 0x8);
    // private UnityEngine.Color[] workBlockTo
    // Size: 0x8
    // Offset: 0xD8
    ::ArrayW<::UnityEngine::Color> workBlockTo;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Color>) == 0x8);
    // private UnityEngine.Color[] workBlockMix
    // Size: 0x8
    // Offset: 0xE0
    ::ArrayW<::UnityEngine::Color> workBlockMix;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Color>) == 0x8);
    // public System.Int32 subTextureSize
    // Size: 0x4
    // Offset: 0xE8
    int subTextureSize;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public UnityEngine.Texture2D[] subTextureArray
    // Size: 0x8
    // Offset: 0xF0
    ::ArrayW<::UnityEngine::Texture2D*> subTextureArray;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Texture2D*>) == 0x8);
    // public System.Boolean startCoroutine
    // Size: 0x1
    // Offset: 0xF8
    bool startCoroutine;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean startedCoroutine
    // Size: 0x1
    // Offset: 0xF9
    bool startedCoroutine;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean finishedCoroutine
    // Size: 0x1
    // Offset: 0xFA
    bool finishedCoroutine;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean startJob
    // Size: 0x1
    // Offset: 0xFB
    bool startJob;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Single switchTimeTaken
    // Size: 0x4
    // Offset: 0xFC
    float switchTimeTaken;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean jobStarted
    // Size: 0x1
    // Offset: 0x100
    bool jobStarted;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Single lerpAmount
    // Size: 0x4
    // Offset: 0x104
    float lerpAmount;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Int32 currentRow
    // Size: 0x4
    // Offset: 0x108
    int currentRow;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 currentColumn
    // Size: 0x4
    // Offset: 0x10C
    int currentColumn;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 currentSubTexture
    // Size: 0x4
    // Offset: 0x110
    int currentSubTexture;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 currentRowInSubtexture
    // Size: 0x4
    // Offset: 0x114
    int currentRowInSubtexture;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get instance field reference: public UnityEngine.Texture2D _dayMap
    [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn__dayMap();
    // Get instance field reference: private UnityEngine.Texture2D fromMap
    [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn_fromMap();
    // Get instance field reference: public UnityEngine.Texture2D _sunriseMap
    [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn__sunriseMap();
    // Get instance field reference: private UnityEngine.Texture2D toMap
    [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn_toMap();
    // Get instance field reference: public DayNightCycle/LerpBakedLightingJob job
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::DayNightCycle::LerpBakedLightingJob& dyn_job();
    // Get instance field reference: public Unity.Jobs.JobHandle jobHandle
    [[deprecated("Use field access instead!")]] ::Unity::Jobs::JobHandle& dyn_jobHandle();
    // Get instance field reference: public System.Boolean isComplete
    [[deprecated("Use field access instead!")]] bool& dyn_isComplete();
    // Get instance field reference: private System.Single startTime
    [[deprecated("Use field access instead!")]] float& dyn_startTime();
    // Get instance field reference: public System.Single timeTakenStartingJob
    [[deprecated("Use field access instead!")]] float& dyn_timeTakenStartingJob();
    // Get instance field reference: public System.Single timeTakenPostJob
    [[deprecated("Use field access instead!")]] float& dyn_timeTakenPostJob();
    // Get instance field reference: public System.Single timeTakenDuringJob
    [[deprecated("Use field access instead!")]] float& dyn_timeTakenDuringJob();
    // Get instance field reference: public UnityEngine.LightmapData newData
    [[deprecated("Use field access instead!")]] ::UnityEngine::LightmapData*& dyn_newData();
    // Get instance field reference: private UnityEngine.Color[] fromPixels
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Color>& dyn_fromPixels();
    // Get instance field reference: private UnityEngine.Color[] toPixels
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Color>& dyn_toPixels();
    // Get instance field reference: private UnityEngine.Color[] mixedPixels
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Color>& dyn_mixedPixels();
    // Get instance field reference: private UnityEngine.LightmapData[] newDatas
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::LightmapData*>& dyn_newDatas();
    // Get instance field reference: public UnityEngine.Texture2D newTexture
    [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn_newTexture();
    // Get instance field reference: public System.Int32 textureWidth
    [[deprecated("Use field access instead!")]] int& dyn_textureWidth();
    // Get instance field reference: public System.Int32 textureHeight
    [[deprecated("Use field access instead!")]] int& dyn_textureHeight();
    // Get instance field reference: private UnityEngine.Color[] workBlockFrom
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Color>& dyn_workBlockFrom();
    // Get instance field reference: private UnityEngine.Color[] workBlockTo
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Color>& dyn_workBlockTo();
    // Get instance field reference: private UnityEngine.Color[] workBlockMix
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Color>& dyn_workBlockMix();
    // Get instance field reference: public System.Int32 subTextureSize
    [[deprecated("Use field access instead!")]] int& dyn_subTextureSize();
    // Get instance field reference: public UnityEngine.Texture2D[] subTextureArray
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Texture2D*>& dyn_subTextureArray();
    // Get instance field reference: public System.Boolean startCoroutine
    [[deprecated("Use field access instead!")]] bool& dyn_startCoroutine();
    // Get instance field reference: public System.Boolean startedCoroutine
    [[deprecated("Use field access instead!")]] bool& dyn_startedCoroutine();
    // Get instance field reference: public System.Boolean finishedCoroutine
    [[deprecated("Use field access instead!")]] bool& dyn_finishedCoroutine();
    // Get instance field reference: public System.Boolean startJob
    [[deprecated("Use field access instead!")]] bool& dyn_startJob();
    // Get instance field reference: public System.Single switchTimeTaken
    [[deprecated("Use field access instead!")]] float& dyn_switchTimeTaken();
    // Get instance field reference: public System.Boolean jobStarted
    [[deprecated("Use field access instead!")]] bool& dyn_jobStarted();
    // Get instance field reference: public System.Single lerpAmount
    [[deprecated("Use field access instead!")]] float& dyn_lerpAmount();
    // Get instance field reference: public System.Int32 currentRow
    [[deprecated("Use field access instead!")]] int& dyn_currentRow();
    // Get instance field reference: public System.Int32 currentColumn
    [[deprecated("Use field access instead!")]] int& dyn_currentColumn();
    // Get instance field reference: public System.Int32 currentSubTexture
    [[deprecated("Use field access instead!")]] int& dyn_currentSubTexture();
    // Get instance field reference: public System.Int32 currentRowInSubtexture
    [[deprecated("Use field access instead!")]] int& dyn_currentRowInSubtexture();
    // public System.Void .ctor()
    // Offset: 0xC62EA8
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DayNightCycle* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::DayNightCycle::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DayNightCycle*, creationType>()));
    }
    // public System.Void Awake()
    // Offset: 0xC62750
    void Awake();
    // public System.Void Update()
    // Offset: 0xC62AD4
    void Update();
    // public System.Collections.IEnumerator UpdateWork()
    // Offset: 0xC62E0C
    ::System::Collections::IEnumerator* UpdateWork();
  }; // DayNightCycle
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::DayNightCycle::LerpBakedLightingJob, "", "DayNightCycle/LerpBakedLightingJob");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::DayNightCycle::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GlobalNamespace::DayNightCycle::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::DayNightCycle::*)()>(&GlobalNamespace::DayNightCycle::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::DayNightCycle*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::DayNightCycle::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::DayNightCycle::*)()>(&GlobalNamespace::DayNightCycle::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::DayNightCycle*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::DayNightCycle::UpdateWork
// Il2CppName: UpdateWork
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::DayNightCycle::*)()>(&GlobalNamespace::DayNightCycle::UpdateWork)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::DayNightCycle*), "UpdateWork", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
