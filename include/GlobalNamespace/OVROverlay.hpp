// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: UnityEngine.Rect
#include "UnityEngine/Rect.hpp"
// Including type: OVRPlugin/TextureRectMatrixf
#include "GlobalNamespace/OVRPlugin_TextureRectMatrixf.hpp"
// Including type: OVRPlugin/EyeTextureFormat
#include "GlobalNamespace/OVRPlugin_EyeTextureFormat.hpp"
// Including type: OVRPlugin/LayerDesc
#include "GlobalNamespace/OVRPlugin_LayerDesc.hpp"
// Including type: System.Runtime.InteropServices.GCHandle
#include "System/Runtime/InteropServices/GCHandle.hpp"
// Including type: UnityEngine.Vector2
#include "UnityEngine/Vector2.hpp"
// Including type: OVRManager/XRDevice
#include "GlobalNamespace/OVRManager_XRDevice.hpp"
// Including type: System.Int32
#include "System/Int32.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Texture
  class Texture;
  // Forward declaring type: Renderer
  class Renderer;
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: RenderTexture
  class RenderTexture;
  // Skipping declaration: Vector3 because it is already included!
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Skipping declaration: OverlayShape because it is already included!
  // Forward declaring type: OVRPose
  struct OVRPose;
}
// Forward declaring namespace: UnityEngine::XR
namespace UnityEngine::XR {
  // Forward declaring type: XRNode
  struct XRNode;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: OVROverlay
  class OVROverlay;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::OVROverlay);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVROverlay*, "", "OVROverlay");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x1C5
  #pragma pack(push, 1)
  // Autogenerated type: OVROverlay
  // [TokenAttribute] Offset: FFFFFFFF
  // [ExecuteInEditMode] Offset: FFFFFFFF
  class OVROverlay : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::OVROverlay::OverlayShape
    struct OverlayShape;
    // Nested type: ::GlobalNamespace::OVROverlay::OverlayType
    struct OverlayType;
    // Nested type: ::GlobalNamespace::OVROverlay::ExternalSurfaceObjectCreated
    class ExternalSurfaceObjectCreated;
    // Nested type: ::GlobalNamespace::OVROverlay::LayerTexture
    struct LayerTexture;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: OVROverlay/OverlayShape
    // [TokenAttribute] Offset: FFFFFFFF
    struct OverlayShape/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: OverlayShape
      constexpr OverlayShape(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating interface conversion operator: i_Enum
      inline ::System::Enum* i_Enum() noexcept {
        return reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public OVROverlay/OverlayShape Quad
      static constexpr const int Quad = 0;
      // Get static field: static public OVROverlay/OverlayShape Quad
      static ::GlobalNamespace::OVROverlay::OverlayShape _get_Quad();
      // Set static field: static public OVROverlay/OverlayShape Quad
      static void _set_Quad(::GlobalNamespace::OVROverlay::OverlayShape value);
      // static field const value: static public OVROverlay/OverlayShape Cylinder
      static constexpr const int Cylinder = 1;
      // Get static field: static public OVROverlay/OverlayShape Cylinder
      static ::GlobalNamespace::OVROverlay::OverlayShape _get_Cylinder();
      // Set static field: static public OVROverlay/OverlayShape Cylinder
      static void _set_Cylinder(::GlobalNamespace::OVROverlay::OverlayShape value);
      // static field const value: static public OVROverlay/OverlayShape Cubemap
      static constexpr const int Cubemap = 2;
      // Get static field: static public OVROverlay/OverlayShape Cubemap
      static ::GlobalNamespace::OVROverlay::OverlayShape _get_Cubemap();
      // Set static field: static public OVROverlay/OverlayShape Cubemap
      static void _set_Cubemap(::GlobalNamespace::OVROverlay::OverlayShape value);
      // static field const value: static public OVROverlay/OverlayShape OffcenterCubemap
      static constexpr const int OffcenterCubemap = 4;
      // Get static field: static public OVROverlay/OverlayShape OffcenterCubemap
      static ::GlobalNamespace::OVROverlay::OverlayShape _get_OffcenterCubemap();
      // Set static field: static public OVROverlay/OverlayShape OffcenterCubemap
      static void _set_OffcenterCubemap(::GlobalNamespace::OVROverlay::OverlayShape value);
      // static field const value: static public OVROverlay/OverlayShape Equirect
      static constexpr const int Equirect = 5;
      // Get static field: static public OVROverlay/OverlayShape Equirect
      static ::GlobalNamespace::OVROverlay::OverlayShape _get_Equirect();
      // Set static field: static public OVROverlay/OverlayShape Equirect
      static void _set_Equirect(::GlobalNamespace::OVROverlay::OverlayShape value);
      // static field const value: static public OVROverlay/OverlayShape Fisheye
      static constexpr const int Fisheye = 9;
      // Get static field: static public OVROverlay/OverlayShape Fisheye
      static ::GlobalNamespace::OVROverlay::OverlayShape _get_Fisheye();
      // Set static field: static public OVROverlay/OverlayShape Fisheye
      static void _set_Fisheye(::GlobalNamespace::OVROverlay::OverlayShape value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // OVROverlay/OverlayShape
    #pragma pack(pop)
    static check_size<sizeof(OVROverlay::OverlayShape), 0 + sizeof(int)> __GlobalNamespace_OVROverlay_OverlayShapeSizeCheck;
    static_assert(sizeof(OVROverlay::OverlayShape) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: OVROverlay/OverlayType
    // [TokenAttribute] Offset: FFFFFFFF
    struct OverlayType/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: OverlayType
      constexpr OverlayType(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating interface conversion operator: i_Enum
      inline ::System::Enum* i_Enum() noexcept {
        return reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public OVROverlay/OverlayType None
      static constexpr const int None = 0;
      // Get static field: static public OVROverlay/OverlayType None
      static ::GlobalNamespace::OVROverlay::OverlayType _get_None();
      // Set static field: static public OVROverlay/OverlayType None
      static void _set_None(::GlobalNamespace::OVROverlay::OverlayType value);
      // static field const value: static public OVROverlay/OverlayType Underlay
      static constexpr const int Underlay = 1;
      // Get static field: static public OVROverlay/OverlayType Underlay
      static ::GlobalNamespace::OVROverlay::OverlayType _get_Underlay();
      // Set static field: static public OVROverlay/OverlayType Underlay
      static void _set_Underlay(::GlobalNamespace::OVROverlay::OverlayType value);
      // static field const value: static public OVROverlay/OverlayType Overlay
      static constexpr const int Overlay = 2;
      // Get static field: static public OVROverlay/OverlayType Overlay
      static ::GlobalNamespace::OVROverlay::OverlayType _get_Overlay();
      // Set static field: static public OVROverlay/OverlayType Overlay
      static void _set_Overlay(::GlobalNamespace::OVROverlay::OverlayType value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // OVROverlay/OverlayType
    #pragma pack(pop)
    static check_size<sizeof(OVROverlay::OverlayType), 0 + sizeof(int)> __GlobalNamespace_OVROverlay_OverlayTypeSizeCheck;
    static_assert(sizeof(OVROverlay::OverlayType) == 0x4);
    // Size: 0x20
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: OVROverlay/LayerTexture
    // [TokenAttribute] Offset: FFFFFFFF
    struct LayerTexture/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.Texture appTexture
      // Size: 0x8
      // Offset: 0x0
      ::UnityEngine::Texture* appTexture;
      // Field size check
      static_assert(sizeof(::UnityEngine::Texture*) == 0x8);
      // public System.IntPtr appTexturePtr
      // Size: 0x8
      // Offset: 0x8
      ::System::IntPtr appTexturePtr;
      // Field size check
      static_assert(sizeof(::System::IntPtr) == 0x8);
      // public UnityEngine.Texture[] swapChain
      // Size: 0x8
      // Offset: 0x10
      ::ArrayW<::UnityEngine::Texture*> swapChain;
      // Field size check
      static_assert(sizeof(::ArrayW<::UnityEngine::Texture*>) == 0x8);
      // public System.IntPtr[] swapChainPtr
      // Size: 0x8
      // Offset: 0x18
      ::ArrayW<::System::IntPtr> swapChainPtr;
      // Field size check
      static_assert(sizeof(::ArrayW<::System::IntPtr>) == 0x8);
      public:
      // Creating value type constructor for type: LayerTexture
      constexpr LayerTexture(::UnityEngine::Texture* appTexture_ = {}, ::System::IntPtr appTexturePtr_ = {}, ::ArrayW<::UnityEngine::Texture*> swapChain_ = ::ArrayW<::UnityEngine::Texture*>(static_cast<void*>(nullptr)), ::ArrayW<::System::IntPtr> swapChainPtr_ = ::ArrayW<::System::IntPtr>(static_cast<void*>(nullptr))) noexcept : appTexture{appTexture_}, appTexturePtr{appTexturePtr_}, swapChain{swapChain_}, swapChainPtr{swapChainPtr_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating interface conversion operator: i_ValueType
      inline ::System::ValueType* i_ValueType() noexcept {
        return reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.Texture appTexture
      [[deprecated("Use field access instead!")]] ::UnityEngine::Texture*& dyn_appTexture();
      // Get instance field reference: public System.IntPtr appTexturePtr
      [[deprecated("Use field access instead!")]] ::System::IntPtr& dyn_appTexturePtr();
      // Get instance field reference: public UnityEngine.Texture[] swapChain
      [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Texture*>& dyn_swapChain();
      // Get instance field reference: public System.IntPtr[] swapChainPtr
      [[deprecated("Use field access instead!")]] ::ArrayW<::System::IntPtr>& dyn_swapChainPtr();
    }; // OVROverlay/LayerTexture
    #pragma pack(pop)
    static check_size<sizeof(OVROverlay::LayerTexture), 24 + sizeof(::ArrayW<::System::IntPtr>)> __GlobalNamespace_OVROverlay_LayerTextureSizeCheck;
    static_assert(sizeof(OVROverlay::LayerTexture) == 0x20);
    public:
    // [TooltipAttribute] Offset: 0x1095674
    // public OVROverlay/OverlayType currentOverlayType
    // Size: 0x4
    // Offset: 0x18
    ::GlobalNamespace::OVROverlay::OverlayType currentOverlayType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVROverlay::OverlayType) == 0x4);
    // [TooltipAttribute] Offset: 0x10956AC
    // public System.Boolean isDynamic
    // Size: 0x1
    // Offset: 0x1C
    bool isDynamic;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0x10956E4
    // public System.Boolean isProtectedContent
    // Size: 0x1
    // Offset: 0x1D
    bool isProtectedContent;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isProtectedContent and: srcRectLeft
    char __padding2[0x2] = {};
    // public UnityEngine.Rect srcRectLeft
    // Size: 0x10
    // Offset: 0x20
    ::UnityEngine::Rect srcRectLeft;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rect) == 0x10);
    // public UnityEngine.Rect srcRectRight
    // Size: 0x10
    // Offset: 0x30
    ::UnityEngine::Rect srcRectRight;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rect) == 0x10);
    // public UnityEngine.Rect destRectLeft
    // Size: 0x10
    // Offset: 0x40
    ::UnityEngine::Rect destRectLeft;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rect) == 0x10);
    // public UnityEngine.Rect destRectRight
    // Size: 0x10
    // Offset: 0x50
    ::UnityEngine::Rect destRectRight;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rect) == 0x10);
    // public System.Boolean invertTextureRects
    // Size: 0x1
    // Offset: 0x60
    bool invertTextureRects;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: invertTextureRects and: textureRectMatrix
    char __padding7[0x3] = {};
    // private OVRPlugin/TextureRectMatrixf textureRectMatrix
    // Size: 0x40
    // Offset: 0x64
    ::GlobalNamespace::OVRPlugin::TextureRectMatrixf textureRectMatrix;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPlugin::TextureRectMatrixf) == 0x40);
    // public System.Boolean overrideTextureRectMatrix
    // Size: 0x1
    // Offset: 0xA4
    bool overrideTextureRectMatrix;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean overridePerLayerColorScaleAndOffset
    // Size: 0x1
    // Offset: 0xA5
    bool overridePerLayerColorScaleAndOffset;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overridePerLayerColorScaleAndOffset and: colorScale
    char __padding10[0x2] = {};
    // public UnityEngine.Vector4 colorScale
    // Size: 0x10
    // Offset: 0xA8
    ::UnityEngine::Vector4 colorScale;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
    // public UnityEngine.Vector4 colorOffset
    // Size: 0x10
    // Offset: 0xB8
    ::UnityEngine::Vector4 colorOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
    // public System.Boolean useExpensiveSuperSample
    // Size: 0x1
    // Offset: 0xC8
    bool useExpensiveSuperSample;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean hidden
    // Size: 0x1
    // Offset: 0xC9
    bool hidden;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0x109571C
    // public System.Boolean isExternalSurface
    // Size: 0x1
    // Offset: 0xCA
    bool isExternalSurface;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isExternalSurface and: externalSurfaceWidth
    char __padding15[0x1] = {};
    // [TooltipAttribute] Offset: 0x1095754
    // public System.Int32 externalSurfaceWidth
    // Size: 0x4
    // Offset: 0xCC
    int externalSurfaceWidth;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // [TooltipAttribute] Offset: 0x109578C
    // public System.Int32 externalSurfaceHeight
    // Size: 0x4
    // Offset: 0xD0
    int externalSurfaceHeight;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // [TooltipAttribute] Offset: 0x10957C4
    // public System.Int32 compositionDepth
    // Size: 0x4
    // Offset: 0xD4
    int compositionDepth;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 layerCompositionDepth
    // Size: 0x4
    // Offset: 0xD8
    int layerCompositionDepth;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // [TooltipAttribute] Offset: 0x10957FC
    // public System.Boolean noDepthBufferTesting
    // Size: 0x1
    // Offset: 0xDC
    bool noDepthBufferTesting;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: noDepthBufferTesting and: layerTextureFormat
    char __padding20[0x3] = {};
    // public OVRPlugin/EyeTextureFormat layerTextureFormat
    // Size: 0x4
    // Offset: 0xE0
    ::GlobalNamespace::OVRPlugin::EyeTextureFormat layerTextureFormat;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPlugin::EyeTextureFormat) == 0x4);
    // [TooltipAttribute] Offset: 0x1095834
    // public OVROverlay/OverlayShape currentOverlayShape
    // Size: 0x4
    // Offset: 0xE4
    ::GlobalNamespace::OVROverlay::OverlayShape currentOverlayShape;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVROverlay::OverlayShape) == 0x4);
    // private OVROverlay/OverlayShape prevOverlayShape
    // Size: 0x4
    // Offset: 0xE8
    ::GlobalNamespace::OVROverlay::OverlayShape prevOverlayShape;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVROverlay::OverlayShape) == 0x4);
    // Padding between fields: prevOverlayShape and: textures
    char __padding23[0x4] = {};
    // [TooltipAttribute] Offset: 0x109586C
    // public UnityEngine.Texture[] textures
    // Size: 0x8
    // Offset: 0xF0
    ::ArrayW<::UnityEngine::Texture*> textures;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Texture*>) == 0x8);
    // [TooltipAttribute] Offset: 0x10958A4
    // public System.Boolean isAlphaPremultiplied
    // Size: 0x1
    // Offset: 0xF8
    bool isAlphaPremultiplied;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _previewInEditor
    // Size: 0x1
    // Offset: 0xF9
    bool previewInEditor;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: previewInEditor and: texturePtrs
    char __padding26[0x6] = {};
    // protected System.IntPtr[] texturePtrs
    // Size: 0x8
    // Offset: 0x100
    ::ArrayW<::System::IntPtr> texturePtrs;
    // Field size check
    static_assert(sizeof(::ArrayW<::System::IntPtr>) == 0x8);
    // public System.IntPtr externalSurfaceObject
    // Size: 0x8
    // Offset: 0x108
    ::System::IntPtr externalSurfaceObject;
    // Field size check
    static_assert(sizeof(::System::IntPtr) == 0x8);
    // public OVROverlay/ExternalSurfaceObjectCreated externalSurfaceObjectCreated
    // Size: 0x8
    // Offset: 0x110
    ::GlobalNamespace::OVROverlay::ExternalSurfaceObjectCreated* externalSurfaceObjectCreated;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVROverlay::ExternalSurfaceObjectCreated*) == 0x8);
    // protected System.Boolean isOverridePending
    // Size: 0x1
    // Offset: 0x118
    bool isOverridePending;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isOverridePending and: layerTextures
    char __padding30[0x7] = {};
    // private OVROverlay/LayerTexture[] layerTextures
    // Size: 0x8
    // Offset: 0x120
    ::ArrayW<::GlobalNamespace::OVROverlay::LayerTexture> layerTextures;
    // Field size check
    static_assert(sizeof(::ArrayW<::GlobalNamespace::OVROverlay::LayerTexture>) == 0x8);
    // private OVRPlugin/LayerDesc layerDesc
    // Size: 0x4C
    // Offset: 0x128
    ::GlobalNamespace::OVRPlugin::LayerDesc layerDesc;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPlugin::LayerDesc) == 0x4C);
    // Padding between fields: layerDesc and: stageCount
    char __padding32[0x4] = {};
    // private System.Int32 stageCount
    // Size: 0x4
    // Offset: 0x178
    int stageCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 layerIndex
    // Size: 0x4
    // Offset: 0x17C
    int layerIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 layerId
    // Size: 0x4
    // Offset: 0x180
    int layerId;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Runtime.InteropServices.GCHandle layerIdHandle
    // Size: 0x4
    // Offset: 0x184
    ::System::Runtime::InteropServices::GCHandle layerIdHandle;
    // Field size check
    static_assert(sizeof(::System::Runtime::InteropServices::GCHandle) == 0x4);
    // private System.IntPtr layerIdPtr
    // Size: 0x8
    // Offset: 0x188
    ::System::IntPtr layerIdPtr;
    // Field size check
    static_assert(sizeof(::System::IntPtr) == 0x8);
    // private System.Int32 frameIndex
    // Size: 0x4
    // Offset: 0x190
    int frameIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 prevFrameIndex
    // Size: 0x4
    // Offset: 0x194
    int prevFrameIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private UnityEngine.Renderer rend
    // Size: 0x8
    // Offset: 0x198
    ::UnityEngine::Renderer* rend;
    // Field size check
    static_assert(sizeof(::UnityEngine::Renderer*) == 0x8);
    // private System.UInt64 OpenVROverlayHandle
    // Size: 0x8
    // Offset: 0x1A0
    uint64_t OpenVROverlayHandle;
    // Field size check
    static_assert(sizeof(uint64_t) == 0x8);
    // private UnityEngine.Vector4 OpenVRUVOffsetAndScale
    // Size: 0x10
    // Offset: 0x1A8
    ::UnityEngine::Vector4 OpenVRUVOffsetAndScale;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
    // private UnityEngine.Vector2 OpenVRMouseScale
    // Size: 0x8
    // Offset: 0x1B8
    ::UnityEngine::Vector2 OpenVRMouseScale;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private OVRManager/XRDevice constructedOverlayXRDevice
    // Size: 0x4
    // Offset: 0x1C0
    ::GlobalNamespace::OVRManager_XRDevice constructedOverlayXRDevice;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRManager_XRDevice) == 0x4);
    // private System.Boolean xrDeviceConstructed
    // Size: 0x1
    // Offset: 0x1C4
    bool xrDeviceConstructed;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // static field const value: static System.Int32 maxInstances
    static constexpr const int maxInstances = 15;
    // Get static field: static System.Int32 maxInstances
    static int _get_maxInstances();
    // Set static field: static System.Int32 maxInstances
    static void _set_maxInstances(int value);
    // Get static field: static public OVROverlay[] instances
    static ::ArrayW<::GlobalNamespace::OVROverlay*> _get_instances();
    // Set static field: static public OVROverlay[] instances
    static void _set_instances(::ArrayW<::GlobalNamespace::OVROverlay*> value);
    // Get static field: static private UnityEngine.Material tex2DMaterial
    static ::UnityEngine::Material* _get_tex2DMaterial();
    // Set static field: static private UnityEngine.Material tex2DMaterial
    static void _set_tex2DMaterial(::UnityEngine::Material* value);
    // Get static field: static private UnityEngine.Material cubeMaterial
    static ::UnityEngine::Material* _get_cubeMaterial();
    // Set static field: static private UnityEngine.Material cubeMaterial
    static void _set_cubeMaterial(::UnityEngine::Material* value);
    // Get instance field reference: public OVROverlay/OverlayType currentOverlayType
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVROverlay::OverlayType& dyn_currentOverlayType();
    // Get instance field reference: public System.Boolean isDynamic
    [[deprecated("Use field access instead!")]] bool& dyn_isDynamic();
    // Get instance field reference: public System.Boolean isProtectedContent
    [[deprecated("Use field access instead!")]] bool& dyn_isProtectedContent();
    // Get instance field reference: public UnityEngine.Rect srcRectLeft
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rect& dyn_srcRectLeft();
    // Get instance field reference: public UnityEngine.Rect srcRectRight
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rect& dyn_srcRectRight();
    // Get instance field reference: public UnityEngine.Rect destRectLeft
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rect& dyn_destRectLeft();
    // Get instance field reference: public UnityEngine.Rect destRectRight
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rect& dyn_destRectRight();
    // Get instance field reference: public System.Boolean invertTextureRects
    [[deprecated("Use field access instead!")]] bool& dyn_invertTextureRects();
    // Get instance field reference: private OVRPlugin/TextureRectMatrixf textureRectMatrix
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRPlugin::TextureRectMatrixf& dyn_textureRectMatrix();
    // Get instance field reference: public System.Boolean overrideTextureRectMatrix
    [[deprecated("Use field access instead!")]] bool& dyn_overrideTextureRectMatrix();
    // Get instance field reference: public System.Boolean overridePerLayerColorScaleAndOffset
    [[deprecated("Use field access instead!")]] bool& dyn_overridePerLayerColorScaleAndOffset();
    // Get instance field reference: public UnityEngine.Vector4 colorScale
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector4& dyn_colorScale();
    // Get instance field reference: public UnityEngine.Vector4 colorOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector4& dyn_colorOffset();
    // Get instance field reference: public System.Boolean useExpensiveSuperSample
    [[deprecated("Use field access instead!")]] bool& dyn_useExpensiveSuperSample();
    // Get instance field reference: public System.Boolean hidden
    [[deprecated("Use field access instead!")]] bool& dyn_hidden();
    // Get instance field reference: public System.Boolean isExternalSurface
    [[deprecated("Use field access instead!")]] bool& dyn_isExternalSurface();
    // Get instance field reference: public System.Int32 externalSurfaceWidth
    [[deprecated("Use field access instead!")]] int& dyn_externalSurfaceWidth();
    // Get instance field reference: public System.Int32 externalSurfaceHeight
    [[deprecated("Use field access instead!")]] int& dyn_externalSurfaceHeight();
    // Get instance field reference: public System.Int32 compositionDepth
    [[deprecated("Use field access instead!")]] int& dyn_compositionDepth();
    // Get instance field reference: private System.Int32 layerCompositionDepth
    [[deprecated("Use field access instead!")]] int& dyn_layerCompositionDepth();
    // Get instance field reference: public System.Boolean noDepthBufferTesting
    [[deprecated("Use field access instead!")]] bool& dyn_noDepthBufferTesting();
    // Get instance field reference: public OVRPlugin/EyeTextureFormat layerTextureFormat
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRPlugin::EyeTextureFormat& dyn_layerTextureFormat();
    // Get instance field reference: public OVROverlay/OverlayShape currentOverlayShape
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVROverlay::OverlayShape& dyn_currentOverlayShape();
    // Get instance field reference: private OVROverlay/OverlayShape prevOverlayShape
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVROverlay::OverlayShape& dyn_prevOverlayShape();
    // Get instance field reference: public UnityEngine.Texture[] textures
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Texture*>& dyn_textures();
    // Get instance field reference: public System.Boolean isAlphaPremultiplied
    [[deprecated("Use field access instead!")]] bool& dyn_isAlphaPremultiplied();
    // Get instance field reference: private System.Boolean _previewInEditor
    [[deprecated("Use field access instead!")]] bool& dyn__previewInEditor();
    // Get instance field reference: protected System.IntPtr[] texturePtrs
    [[deprecated("Use field access instead!")]] ::ArrayW<::System::IntPtr>& dyn_texturePtrs();
    // Get instance field reference: public System.IntPtr externalSurfaceObject
    [[deprecated("Use field access instead!")]] ::System::IntPtr& dyn_externalSurfaceObject();
    // Get instance field reference: public OVROverlay/ExternalSurfaceObjectCreated externalSurfaceObjectCreated
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVROverlay::ExternalSurfaceObjectCreated*& dyn_externalSurfaceObjectCreated();
    // Get instance field reference: protected System.Boolean isOverridePending
    [[deprecated("Use field access instead!")]] bool& dyn_isOverridePending();
    // Get instance field reference: private OVROverlay/LayerTexture[] layerTextures
    [[deprecated("Use field access instead!")]] ::ArrayW<::GlobalNamespace::OVROverlay::LayerTexture>& dyn_layerTextures();
    // Get instance field reference: private OVRPlugin/LayerDesc layerDesc
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRPlugin::LayerDesc& dyn_layerDesc();
    // Get instance field reference: private System.Int32 stageCount
    [[deprecated("Use field access instead!")]] int& dyn_stageCount();
    // Get instance field reference: private System.Int32 layerIndex
    [[deprecated("Use field access instead!")]] int& dyn_layerIndex();
    // Get instance field reference: private System.Int32 layerId
    [[deprecated("Use field access instead!")]] int& dyn_layerId();
    // Get instance field reference: private System.Runtime.InteropServices.GCHandle layerIdHandle
    [[deprecated("Use field access instead!")]] ::System::Runtime::InteropServices::GCHandle& dyn_layerIdHandle();
    // Get instance field reference: private System.IntPtr layerIdPtr
    [[deprecated("Use field access instead!")]] ::System::IntPtr& dyn_layerIdPtr();
    // Get instance field reference: private System.Int32 frameIndex
    [[deprecated("Use field access instead!")]] int& dyn_frameIndex();
    // Get instance field reference: private System.Int32 prevFrameIndex
    [[deprecated("Use field access instead!")]] int& dyn_prevFrameIndex();
    // Get instance field reference: private UnityEngine.Renderer rend
    [[deprecated("Use field access instead!")]] ::UnityEngine::Renderer*& dyn_rend();
    // Get instance field reference: private System.UInt64 OpenVROverlayHandle
    [[deprecated("Use field access instead!")]] uint64_t& dyn_OpenVROverlayHandle();
    // Get instance field reference: private UnityEngine.Vector4 OpenVRUVOffsetAndScale
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector4& dyn_OpenVRUVOffsetAndScale();
    // Get instance field reference: private UnityEngine.Vector2 OpenVRMouseScale
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_OpenVRMouseScale();
    // Get instance field reference: private OVRManager/XRDevice constructedOverlayXRDevice
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRManager_XRDevice& dyn_constructedOverlayXRDevice();
    // Get instance field reference: private System.Boolean xrDeviceConstructed
    [[deprecated("Use field access instead!")]] bool& dyn_xrDeviceConstructed();
    // public System.Boolean get_previewInEditor()
    // Offset: 0x171DA2C
    bool get_previewInEditor();
    // public System.Void set_previewInEditor(System.Boolean value)
    // Offset: 0x171DA34
    void set_previewInEditor(bool value);
    // private OVRPlugin/LayerLayout get_layout()
    // Offset: 0x171DB20
    ::GlobalNamespace::OVRPlugin::LayerLayout get_layout();
    // private System.Int32 get_texturesPerStage()
    // Offset: 0x171DC14
    int get_texturesPerStage();
    // static public System.String get_OpenVROverlayKey()
    // Offset: 0x1721CC0
    static ::StringW get_OpenVROverlayKey();
    // public System.Void .ctor()
    // Offset: 0x1723070
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static OVROverlay* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::OVROverlay::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<OVROverlay*, creationType>()));
    }
    // static private System.Void .cctor()
    // Offset: 0x1723218
    static void _cctor();
    // public System.Void OverrideOverlayTextureInfo(UnityEngine.Texture srcTexture, System.IntPtr nativePtr, UnityEngine.XR.XRNode node)
    // Offset: 0x171DA58
    void OverrideOverlayTextureInfo(::UnityEngine::Texture* srcTexture, ::System::IntPtr nativePtr, ::UnityEngine::XR::XRNode node);
    // static private System.Boolean NeedsTexturesForShape(OVROverlay/OverlayShape shape)
    // Offset: 0x171DC34
    static bool NeedsTexturesForShape(::GlobalNamespace::OVROverlay::OverlayShape shape);
    // private System.Boolean CreateLayer(System.Int32 mipLevels, System.Int32 sampleCount, OVRPlugin/EyeTextureFormat etFormat, System.Int32 flags, OVRPlugin/Sizei size, OVRPlugin/OverlayShape shape)
    // Offset: 0x171DC3C
    bool CreateLayer(int mipLevels, int sampleCount, ::GlobalNamespace::OVRPlugin::EyeTextureFormat etFormat, int flags, ::GlobalNamespace::OVRPlugin::Sizei size, ::GlobalNamespace::OVRPlugin::OverlayShape shape);
    // private System.Boolean CreateLayerTextures(System.Boolean useMipmaps, OVRPlugin/Sizei size, System.Boolean isHdr)
    // Offset: 0x171E57C
    bool CreateLayerTextures(bool useMipmaps, ::GlobalNamespace::OVRPlugin::Sizei size, bool isHdr);
    // private System.Void DestroyLayerTextures()
    // Offset: 0x171EEF4
    void DestroyLayerTextures();
    // private System.Void DestroyLayer()
    // Offset: 0x171F030
    void DestroyLayer();
    // public System.Void SetSrcDestRects(UnityEngine.Rect srcLeft, UnityEngine.Rect srcRight, UnityEngine.Rect destLeft, UnityEngine.Rect destRight)
    // Offset: 0x171FB1C
    void SetSrcDestRects(::UnityEngine::Rect srcLeft, ::UnityEngine::Rect srcRight, ::UnityEngine::Rect destLeft, ::UnityEngine::Rect destRight);
    // public System.Void UpdateTextureRectMatrix()
    // Offset: 0x171FB38
    void UpdateTextureRectMatrix();
    // public System.Void SetPerLayerColorScaleAndOffset(UnityEngine.Vector4 scale, UnityEngine.Vector4 offset)
    // Offset: 0x171FFD4
    void SetPerLayerColorScaleAndOffset(::UnityEngine::Vector4 scale, ::UnityEngine::Vector4 offset);
    // private System.Boolean LatchLayerTextures()
    // Offset: 0x171FFE8
    bool LatchLayerTextures();
    // private OVRPlugin/LayerDesc GetCurrentLayerDesc()
    // Offset: 0x1720430
    ::GlobalNamespace::OVRPlugin::LayerDesc GetCurrentLayerDesc();
    // private UnityEngine.Rect GetBlitRect(System.Int32 eyeId)
    // Offset: 0x172092C
    ::UnityEngine::Rect GetBlitRect(int eyeId);
    // private System.Void BlitSubImage(UnityEngine.Texture src, UnityEngine.RenderTexture dst, UnityEngine.Material mat, UnityEngine.Rect rect)
    // Offset: 0x1720B30
    void BlitSubImage(::UnityEngine::Texture* src, ::UnityEngine::RenderTexture* dst, ::UnityEngine::Material* mat, ::UnityEngine::Rect rect);
    // private System.Boolean PopulateLayer(System.Int32 mipLevels, System.Boolean isHdr, OVRPlugin/Sizei size, System.Int32 sampleCount, System.Int32 stage)
    // Offset: 0x1720FAC
    bool PopulateLayer(int mipLevels, bool isHdr, ::GlobalNamespace::OVRPlugin::Sizei size, int sampleCount, int stage);
    // private System.Boolean SubmitLayer(System.Boolean overlay, System.Boolean headLocked, System.Boolean noDepthBufferTesting, OVRPose pose, UnityEngine.Vector3 scale, System.Int32 frameIndex)
    // Offset: 0x17216D0
    bool SubmitLayer(bool overlay, bool headLocked, bool noDepthBufferTesting, ::GlobalNamespace::OVRPose pose, ::UnityEngine::Vector3 scale, int frameIndex);
    // private System.Void SetupEditorPreview()
    // Offset: 0x171DA54
    void SetupEditorPreview();
    // private System.Void Awake()
    // Offset: 0x172198C
    void Awake();
    // private System.Void OnEnable()
    // Offset: 0x1721D38
    void OnEnable();
    // private System.Void InitOVROverlay()
    // Offset: 0x1721DB8
    void InitOVROverlay();
    // private System.Void OnDisable()
    // Offset: 0x1721F64
    void OnDisable();
    // private System.Void OnDestroy()
    // Offset: 0x17220D0
    void OnDestroy();
    // private System.Boolean ComputeSubmit(ref OVRPose pose, ref UnityEngine.Vector3 scale, ref System.Boolean overlay, ref System.Boolean headLocked)
    // Offset: 0x17220F4
    bool ComputeSubmit(ByRef<::GlobalNamespace::OVRPose> pose, ByRef<::UnityEngine::Vector3> scale, ByRef<bool> overlay, ByRef<bool> headLocked);
    // private System.Void OpenVROverlayUpdate(UnityEngine.Vector3 scale, OVRPose pose)
    // Offset: 0x17227C4
    void OpenVROverlayUpdate(::UnityEngine::Vector3 scale, ::GlobalNamespace::OVRPose pose);
    // private System.Void LateUpdate()
    // Offset: 0x1722B08
    void LateUpdate();
  }; // OVROverlay
  #pragma pack(pop)
  static check_size<sizeof(OVROverlay), 452 + sizeof(bool)> __GlobalNamespace_OVROverlaySizeCheck;
  static_assert(sizeof(OVROverlay) == 0x1C5);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVROverlay::LayerTexture, "", "OVROverlay/LayerTexture");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVROverlay::OverlayType, "", "OVROverlay/OverlayType");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVROverlay::OverlayShape, "", "OVROverlay/OverlayShape");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::get_previewInEditor
// Il2CppName: get_previewInEditor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::get_previewInEditor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "get_previewInEditor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::set_previewInEditor
// Il2CppName: set_previewInEditor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)(bool)>(&GlobalNamespace::OVROverlay::set_previewInEditor)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "set_previewInEditor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::get_layout
// Il2CppName: get_layout
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::OVRPlugin::LayerLayout (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::get_layout)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "get_layout", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::get_texturesPerStage
// Il2CppName: get_texturesPerStage
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::get_texturesPerStage)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "get_texturesPerStage", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::get_OpenVROverlayKey
// Il2CppName: get_OpenVROverlayKey
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (*)()>(&GlobalNamespace::OVROverlay::get_OpenVROverlayKey)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "get_OpenVROverlayKey", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&GlobalNamespace::OVROverlay::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::OverrideOverlayTextureInfo
// Il2CppName: OverrideOverlayTextureInfo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)(::UnityEngine::Texture*, ::System::IntPtr, ::UnityEngine::XR::XRNode)>(&GlobalNamespace::OVROverlay::OverrideOverlayTextureInfo)> {
  static const MethodInfo* get() {
    static auto* srcTexture = &::il2cpp_utils::GetClassFromName("UnityEngine", "Texture")->byval_arg;
    static auto* nativePtr = &::il2cpp_utils::GetClassFromName("System", "IntPtr")->byval_arg;
    static auto* node = &::il2cpp_utils::GetClassFromName("UnityEngine.XR", "XRNode")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "OverrideOverlayTextureInfo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{srcTexture, nativePtr, node});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::NeedsTexturesForShape
// Il2CppName: NeedsTexturesForShape
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::GlobalNamespace::OVROverlay::OverlayShape)>(&GlobalNamespace::OVROverlay::NeedsTexturesForShape)> {
  static const MethodInfo* get() {
    static auto* shape = &::il2cpp_utils::GetClassFromName("", "OVROverlay/OverlayShape")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "NeedsTexturesForShape", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{shape});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::CreateLayer
// Il2CppName: CreateLayer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVROverlay::*)(int, int, ::GlobalNamespace::OVRPlugin::EyeTextureFormat, int, ::GlobalNamespace::OVRPlugin::Sizei, ::GlobalNamespace::OVRPlugin::OverlayShape)>(&GlobalNamespace::OVROverlay::CreateLayer)> {
  static const MethodInfo* get() {
    static auto* mipLevels = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* sampleCount = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* etFormat = &::il2cpp_utils::GetClassFromName("", "OVRPlugin/EyeTextureFormat")->byval_arg;
    static auto* flags = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* size = &::il2cpp_utils::GetClassFromName("", "OVRPlugin/Sizei")->byval_arg;
    static auto* shape = &::il2cpp_utils::GetClassFromName("", "OVRPlugin/OverlayShape")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "CreateLayer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mipLevels, sampleCount, etFormat, flags, size, shape});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::CreateLayerTextures
// Il2CppName: CreateLayerTextures
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVROverlay::*)(bool, ::GlobalNamespace::OVRPlugin::Sizei, bool)>(&GlobalNamespace::OVROverlay::CreateLayerTextures)> {
  static const MethodInfo* get() {
    static auto* useMipmaps = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* size = &::il2cpp_utils::GetClassFromName("", "OVRPlugin/Sizei")->byval_arg;
    static auto* isHdr = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "CreateLayerTextures", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{useMipmaps, size, isHdr});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::DestroyLayerTextures
// Il2CppName: DestroyLayerTextures
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::DestroyLayerTextures)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "DestroyLayerTextures", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::DestroyLayer
// Il2CppName: DestroyLayer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::DestroyLayer)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "DestroyLayer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::SetSrcDestRects
// Il2CppName: SetSrcDestRects
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)(::UnityEngine::Rect, ::UnityEngine::Rect, ::UnityEngine::Rect, ::UnityEngine::Rect)>(&GlobalNamespace::OVROverlay::SetSrcDestRects)> {
  static const MethodInfo* get() {
    static auto* srcLeft = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rect")->byval_arg;
    static auto* srcRight = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rect")->byval_arg;
    static auto* destLeft = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rect")->byval_arg;
    static auto* destRight = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rect")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "SetSrcDestRects", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{srcLeft, srcRight, destLeft, destRight});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::UpdateTextureRectMatrix
// Il2CppName: UpdateTextureRectMatrix
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::UpdateTextureRectMatrix)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "UpdateTextureRectMatrix", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::SetPerLayerColorScaleAndOffset
// Il2CppName: SetPerLayerColorScaleAndOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)(::UnityEngine::Vector4, ::UnityEngine::Vector4)>(&GlobalNamespace::OVROverlay::SetPerLayerColorScaleAndOffset)> {
  static const MethodInfo* get() {
    static auto* scale = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector4")->byval_arg;
    static auto* offset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector4")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "SetPerLayerColorScaleAndOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scale, offset});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::LatchLayerTextures
// Il2CppName: LatchLayerTextures
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::LatchLayerTextures)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "LatchLayerTextures", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::GetCurrentLayerDesc
// Il2CppName: GetCurrentLayerDesc
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::OVRPlugin::LayerDesc (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::GetCurrentLayerDesc)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "GetCurrentLayerDesc", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::GetBlitRect
// Il2CppName: GetBlitRect
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Rect (GlobalNamespace::OVROverlay::*)(int)>(&GlobalNamespace::OVROverlay::GetBlitRect)> {
  static const MethodInfo* get() {
    static auto* eyeId = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "GetBlitRect", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{eyeId});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::BlitSubImage
// Il2CppName: BlitSubImage
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)(::UnityEngine::Texture*, ::UnityEngine::RenderTexture*, ::UnityEngine::Material*, ::UnityEngine::Rect)>(&GlobalNamespace::OVROverlay::BlitSubImage)> {
  static const MethodInfo* get() {
    static auto* src = &::il2cpp_utils::GetClassFromName("UnityEngine", "Texture")->byval_arg;
    static auto* dst = &::il2cpp_utils::GetClassFromName("UnityEngine", "RenderTexture")->byval_arg;
    static auto* mat = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* rect = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rect")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "BlitSubImage", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{src, dst, mat, rect});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::PopulateLayer
// Il2CppName: PopulateLayer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVROverlay::*)(int, bool, ::GlobalNamespace::OVRPlugin::Sizei, int, int)>(&GlobalNamespace::OVROverlay::PopulateLayer)> {
  static const MethodInfo* get() {
    static auto* mipLevels = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* isHdr = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* size = &::il2cpp_utils::GetClassFromName("", "OVRPlugin/Sizei")->byval_arg;
    static auto* sampleCount = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* stage = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "PopulateLayer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mipLevels, isHdr, size, sampleCount, stage});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::SubmitLayer
// Il2CppName: SubmitLayer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVROverlay::*)(bool, bool, bool, ::GlobalNamespace::OVRPose, ::UnityEngine::Vector3, int)>(&GlobalNamespace::OVROverlay::SubmitLayer)> {
  static const MethodInfo* get() {
    static auto* overlay = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* headLocked = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* noDepthBufferTesting = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* pose = &::il2cpp_utils::GetClassFromName("", "OVRPose")->byval_arg;
    static auto* scale = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* frameIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "SubmitLayer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{overlay, headLocked, noDepthBufferTesting, pose, scale, frameIndex});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::SetupEditorPreview
// Il2CppName: SetupEditorPreview
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::SetupEditorPreview)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "SetupEditorPreview", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::InitOVROverlay
// Il2CppName: InitOVROverlay
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::InitOVROverlay)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "InitOVROverlay", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::ComputeSubmit
// Il2CppName: ComputeSubmit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVROverlay::*)(ByRef<::GlobalNamespace::OVRPose>, ByRef<::UnityEngine::Vector3>, ByRef<bool>, ByRef<bool>)>(&GlobalNamespace::OVROverlay::ComputeSubmit)> {
  static const MethodInfo* get() {
    static auto* pose = &::il2cpp_utils::GetClassFromName("", "OVRPose")->this_arg;
    static auto* scale = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* overlay = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    static auto* headLocked = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "ComputeSubmit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pose, scale, overlay, headLocked});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::OpenVROverlayUpdate
// Il2CppName: OpenVROverlayUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)(::UnityEngine::Vector3, ::GlobalNamespace::OVRPose)>(&GlobalNamespace::OVROverlay::OpenVROverlayUpdate)> {
  static const MethodInfo* get() {
    static auto* scale = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* pose = &::il2cpp_utils::GetClassFromName("", "OVRPose")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "OpenVROverlayUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scale, pose});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVROverlay::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVROverlay::*)()>(&GlobalNamespace::OVROverlay::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVROverlay*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
