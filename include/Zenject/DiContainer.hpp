// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include <initializer_list>
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Zenject.IInstantiator
#include "Zenject/IInstantiator.hpp"
// Including type: Zenject.BindingId
#include "Zenject/BindingId.hpp"
// Including type: Zenject.TypeValuePair
#include "Zenject/TypeValuePair.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Zenject
namespace Zenject {
  // Forward declaring type: LazyInstanceInjector
  class LazyInstanceInjector;
  // Forward declaring type: BindStatement
  class BindStatement;
  // Forward declaring type: IValidatable
  class IValidatable;
  // Forward declaring type: ZenjectSettings
  class ZenjectSettings;
  // Forward declaring type: IProvider
  class IProvider;
  // Forward declaring type: InjectContext
  class InjectContext;
  // Forward declaring type: BindingCondition
  class BindingCondition;
  // Forward declaring type: InjectSources
  struct InjectSources;
  // Forward declaring type: Installer
  class Installer;
  // Forward declaring type: DecoratorToChoiceFromBinder`1<TContract>
  template<typename TContract>
  class DecoratorToChoiceFromBinder_1;
  // Forward declaring type: InjectTypeInfo
  class InjectTypeInfo;
  // Forward declaring type: GameObjectCreationParameters
  class GameObjectCreationParameters;
  // Forward declaring type: ConcreteBinderGeneric`1<TContract>
  template<typename TContract>
  class ConcreteBinderGeneric_1;
  // Forward declaring type: ConcreteBinderNonGeneric
  class ConcreteBinderNonGeneric;
  // Forward declaring type: ConcreteIdBinderGeneric`1<TContract>
  template<typename TContract>
  class ConcreteIdBinderGeneric_1;
  // Forward declaring type: ConcreteIdBinderNonGeneric
  class ConcreteIdBinderNonGeneric;
  // Forward declaring type: BindInfo
  class BindInfo;
  // Forward declaring type: ConventionSelectTypesBinder
  class ConventionSelectTypesBinder;
  // Forward declaring type: FromBinderNonGeneric
  class FromBinderNonGeneric;
  // Forward declaring type: IdScopeConcreteIdArgConditionCopyNonLazyBinder
  class IdScopeConcreteIdArgConditionCopyNonLazyBinder;
  // Forward declaring type: IFactory
  class IFactory;
  // Forward declaring type: FactoryToChoiceIdBinder`1<TContract>
  template<typename TContract>
  class FactoryToChoiceIdBinder_1;
  // Forward declaring type: PlaceholderFactory`1<TValue>
  template<typename TValue>
  class PlaceholderFactory_1;
  // Forward declaring type: MemoryPoolIdInitialSizeMaxSizeBinder`1<TContract>
  template<typename TContract>
  class MemoryPoolIdInitialSizeMaxSizeBinder_1;
  // Forward declaring type: IMemoryPool
  class IMemoryPool;
  // Forward declaring type: FactoryToChoiceIdBinder`2<TParam1, TContract>
  template<typename TParam1, typename TContract>
  class FactoryToChoiceIdBinder_2;
  // Forward declaring type: PlaceholderFactory`2<TParam1, TValue>
  template<typename TParam1, typename TValue>
  class PlaceholderFactory_2;
  // Forward declaring type: FactoryToChoiceIdBinder`3<TParam1, TParam2, TContract>
  template<typename TParam1, typename TParam2, typename TContract>
  class FactoryToChoiceIdBinder_3;
  // Forward declaring type: PlaceholderFactory`3<TParam1, TParam2, TValue>
  template<typename TParam1, typename TParam2, typename TValue>
  class PlaceholderFactory_3;
  // Forward declaring type: FactoryToChoiceIdBinder`4<TParam1, TParam2, TParam3, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TContract>
  class FactoryToChoiceIdBinder_4;
  // Forward declaring type: PlaceholderFactory`4<TParam1, TParam2, TParam3, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TValue>
  class PlaceholderFactory_4;
  // Forward declaring type: FactoryToChoiceIdBinder`5<TParam1, TParam2, TParam3, TParam4, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TContract>
  class FactoryToChoiceIdBinder_5;
  // Forward declaring type: PlaceholderFactory`5<TParam1, TParam2, TParam3, TParam4, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TValue>
  class PlaceholderFactory_5;
  // Forward declaring type: FactoryToChoiceIdBinder`6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TContract>
  class FactoryToChoiceIdBinder_6;
  // Forward declaring type: PlaceholderFactory`6<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TValue>
  class PlaceholderFactory_6;
  // Forward declaring type: FactoryToChoiceIdBinder`7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TParam6, typename TContract>
  class FactoryToChoiceIdBinder_7;
  // Forward declaring type: PlaceholderFactory`7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TParam6, typename TValue>
  class PlaceholderFactory_7;
  // Forward declaring type: FactoryToChoiceIdBinder`11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TParam6, typename TParam7, typename TParam8, typename TParam9, typename TParam10, typename TContract>
  class FactoryToChoiceIdBinder_11;
  // Forward declaring type: PlaceholderFactory`11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TParam6, typename TParam7, typename TParam8, typename TParam9, typename TParam10, typename TValue>
  class PlaceholderFactory_11;
  // Forward declaring type: ITickable
  class ITickable;
  // Forward declaring type: CopyNonLazyBinder
  class CopyNonLazyBinder;
  // Forward declaring type: IInitializable
  class IInitializable;
  // Forward declaring type: ILateDisposable
  class ILateDisposable;
  // Forward declaring type: IFixedTickable
  class IFixedTickable;
  // Forward declaring type: ILateTickable
  class ILateTickable;
  // Forward declaring type: IPoolable
  class IPoolable;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: HashSet`1<T>
  template<typename T>
  class HashSet_1;
  // Forward declaring type: Queue`1<T>
  template<typename T>
  class Queue_1;
  // Forward declaring type: IEnumerable`1<T>
  template<typename T>
  class IEnumerable_1;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Type
  class Type;
  // Forward declaring type: Nullable`1<T>
  template<typename T>
  struct Nullable_1;
  // Forward declaring type: Action`1<T>
  template<typename T>
  class Action_1;
  // Forward declaring type: IDisposable
  class IDisposable;
}
// Forward declaring namespace: Zenject::Internal
namespace Zenject::Internal {
  // Forward declaring type: IDecoratorProvider
  class IDecoratorProvider;
  // Forward declaring type: LookupId
  class LookupId;
  // Forward declaring type: SingletonMarkRegistry
  class SingletonMarkRegistry;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Object
  class Object;
  // Forward declaring type: Component
  class Component;
  // Forward declaring type: ScriptableObject
  class ScriptableObject;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IList
  class IList;
}
// Completed forward declares
// Type namespace: Zenject
namespace Zenject {
  // Forward declaring type: DiContainer
  class DiContainer;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(Zenject::DiContainer);
DEFINE_IL2CPP_ARG_TYPE(Zenject::DiContainer*, "Zenject", "DiContainer");
// Type namespace: Zenject
namespace Zenject {
  // Size: 0x9D
  #pragma pack(push, 1)
  // Autogenerated type: Zenject.DiContainer
  // [TokenAttribute] Offset: FFFFFFFF
  // [NoReflectionBakingAttribute] Offset: FFFFFFFF
  class DiContainer : public ::Il2CppObject/*, public Zenject::IInstantiator*/ {
    public:
    // Nested type: Zenject::DiContainer::ProviderInfo
    class ProviderInfo;
    // Nested type: Zenject::DiContainer::$$c
    class $$c;
    // Nested type: Zenject::DiContainer::$$c__DisplayClass86_0
    class $$c__DisplayClass86_0;
    // Nested type: Zenject::DiContainer::$GetDependencyContracts$d__96
    class $GetDependencyContracts$d__96;
    // Nested type: Zenject::DiContainer::$$c__DisplayClass178_0
    class $$c__DisplayClass178_0;
    // Nested type: Zenject::DiContainer::$$c__DisplayClass203_0_1<TContract>
    template<typename TContract>
    class $$c__DisplayClass203_0_1;
    #ifdef USE_CODEGEN_FIELDS
    public:
    #else
    #ifdef CODEGEN_FIELD_ACCESSIBILITY
    CODEGEN_FIELD_ACCESSIBILITY:
    #else
    protected:
    #endif
    #endif
    // private readonly System.Collections.Generic.Dictionary`2<System.Type,Zenject.Internal.IDecoratorProvider> _decorators
    // Size: 0x8
    // Offset: 0x10
    System::Collections::Generic::Dictionary_2<System::Type*, Zenject::Internal::IDecoratorProvider*>* decorators;
    // Field size check
    static_assert(sizeof(System::Collections::Generic::Dictionary_2<System::Type*, Zenject::Internal::IDecoratorProvider*>*) == 0x8);
    // private readonly System.Collections.Generic.Dictionary`2<Zenject.BindingId,System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo>> _providers
    // Size: 0x8
    // Offset: 0x18
    System::Collections::Generic::Dictionary_2<Zenject::BindingId, System::Collections::Generic::List_1<Zenject::DiContainer::ProviderInfo*>*>* providers;
    // Field size check
    static_assert(sizeof(System::Collections::Generic::Dictionary_2<Zenject::BindingId, System::Collections::Generic::List_1<Zenject::DiContainer::ProviderInfo*>*>*) == 0x8);
    // private readonly Zenject.DiContainer[][] _containerLookups
    // Size: 0x8
    // Offset: 0x20
    ::ArrayW<::ArrayW<Zenject::DiContainer*>> containerLookups;
    // Field size check
    static_assert(sizeof(::ArrayW<::ArrayW<Zenject::DiContainer*>>) == 0x8);
    // private readonly System.Collections.Generic.HashSet`1<Zenject.Internal.LookupId> _resolvesInProgress
    // Size: 0x8
    // Offset: 0x28
    System::Collections::Generic::HashSet_1<Zenject::Internal::LookupId*>* resolvesInProgress;
    // Field size check
    static_assert(sizeof(System::Collections::Generic::HashSet_1<Zenject::Internal::LookupId*>*) == 0x8);
    // private readonly System.Collections.Generic.HashSet`1<Zenject.Internal.LookupId> _resolvesTwiceInProgress
    // Size: 0x8
    // Offset: 0x30
    System::Collections::Generic::HashSet_1<Zenject::Internal::LookupId*>* resolvesTwiceInProgress;
    // Field size check
    static_assert(sizeof(System::Collections::Generic::HashSet_1<Zenject::Internal::LookupId*>*) == 0x8);
    // private readonly Zenject.LazyInstanceInjector _lazyInjector
    // Size: 0x8
    // Offset: 0x38
    Zenject::LazyInstanceInjector* lazyInjector;
    // Field size check
    static_assert(sizeof(Zenject::LazyInstanceInjector*) == 0x8);
    // private readonly Zenject.Internal.SingletonMarkRegistry _singletonMarkRegistry
    // Size: 0x8
    // Offset: 0x40
    Zenject::Internal::SingletonMarkRegistry* singletonMarkRegistry;
    // Field size check
    static_assert(sizeof(Zenject::Internal::SingletonMarkRegistry*) == 0x8);
    // private readonly System.Collections.Generic.Queue`1<Zenject.BindStatement> _currentBindings
    // Size: 0x8
    // Offset: 0x48
    System::Collections::Generic::Queue_1<Zenject::BindStatement*>* currentBindings;
    // Field size check
    static_assert(sizeof(System::Collections::Generic::Queue_1<Zenject::BindStatement*>*) == 0x8);
    // private readonly System.Collections.Generic.List`1<Zenject.BindStatement> _childBindings
    // Size: 0x8
    // Offset: 0x50
    System::Collections::Generic::List_1<Zenject::BindStatement*>* childBindings;
    // Field size check
    static_assert(sizeof(System::Collections::Generic::List_1<Zenject::BindStatement*>*) == 0x8);
    // private readonly System.Collections.Generic.HashSet`1<System.Type> _validatedTypes
    // Size: 0x8
    // Offset: 0x58
    System::Collections::Generic::HashSet_1<System::Type*>* validatedTypes;
    // Field size check
    static_assert(sizeof(System::Collections::Generic::HashSet_1<System::Type*>*) == 0x8);
    // private readonly System.Collections.Generic.List`1<Zenject.IValidatable> _validationQueue
    // Size: 0x8
    // Offset: 0x60
    System::Collections::Generic::List_1<Zenject::IValidatable*>* validationQueue;
    // Field size check
    static_assert(sizeof(System::Collections::Generic::List_1<Zenject::IValidatable*>*) == 0x8);
    // private UnityEngine.Transform _contextTransform
    // Size: 0x8
    // Offset: 0x68
    UnityEngine::Transform* contextTransform;
    // Field size check
    static_assert(sizeof(UnityEngine::Transform*) == 0x8);
    // private System.Boolean _hasLookedUpContextTransform
    // Size: 0x1
    // Offset: 0x70
    bool hasLookedUpContextTransform;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: hasLookedUpContextTransform and: inheritedDefaultParent
    char __padding12[0x7] = {};
    // private UnityEngine.Transform _inheritedDefaultParent
    // Size: 0x8
    // Offset: 0x78
    UnityEngine::Transform* inheritedDefaultParent;
    // Field size check
    static_assert(sizeof(UnityEngine::Transform*) == 0x8);
    // private UnityEngine.Transform _explicitDefaultParent
    // Size: 0x8
    // Offset: 0x80
    UnityEngine::Transform* explicitDefaultParent;
    // Field size check
    static_assert(sizeof(UnityEngine::Transform*) == 0x8);
    // private System.Boolean _hasExplicitDefaultParent
    // Size: 0x1
    // Offset: 0x88
    bool hasExplicitDefaultParent;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: hasExplicitDefaultParent and: settings
    char __padding15[0x7] = {};
    // private Zenject.ZenjectSettings _settings
    // Size: 0x8
    // Offset: 0x90
    Zenject::ZenjectSettings* settings;
    // Field size check
    static_assert(sizeof(Zenject::ZenjectSettings*) == 0x8);
    // private System.Boolean _hasResolvedRoots
    // Size: 0x1
    // Offset: 0x98
    bool hasResolvedRoots;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _isFinalizingBinding
    // Size: 0x1
    // Offset: 0x99
    bool isFinalizingBinding;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _isValidating
    // Size: 0x1
    // Offset: 0x9A
    bool isValidating;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _isInstalling
    // Size: 0x1
    // Offset: 0x9B
    bool isInstalling;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean <AssertOnNewGameObjects>k__BackingField
    // Size: 0x1
    // Offset: 0x9C
    bool AssertOnNewGameObjects;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Creating interface conversion operator: operator Zenject::IInstantiator
    operator Zenject::IInstantiator() noexcept {
      return *reinterpret_cast<Zenject::IInstantiator*>(this);
    }
    // Get instance field reference: private readonly System.Collections.Generic.Dictionary`2<System.Type,Zenject.Internal.IDecoratorProvider> _decorators
    System::Collections::Generic::Dictionary_2<System::Type*, Zenject::Internal::IDecoratorProvider*>*& dyn__decorators();
    // Get instance field reference: private readonly System.Collections.Generic.Dictionary`2<Zenject.BindingId,System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo>> _providers
    System::Collections::Generic::Dictionary_2<Zenject::BindingId, System::Collections::Generic::List_1<Zenject::DiContainer::ProviderInfo*>*>*& dyn__providers();
    // Get instance field reference: private readonly Zenject.DiContainer[][] _containerLookups
    ::ArrayW<::ArrayW<Zenject::DiContainer*>>& dyn__containerLookups();
    // Get instance field reference: private readonly System.Collections.Generic.HashSet`1<Zenject.Internal.LookupId> _resolvesInProgress
    System::Collections::Generic::HashSet_1<Zenject::Internal::LookupId*>*& dyn__resolvesInProgress();
    // Get instance field reference: private readonly System.Collections.Generic.HashSet`1<Zenject.Internal.LookupId> _resolvesTwiceInProgress
    System::Collections::Generic::HashSet_1<Zenject::Internal::LookupId*>*& dyn__resolvesTwiceInProgress();
    // Get instance field reference: private readonly Zenject.LazyInstanceInjector _lazyInjector
    Zenject::LazyInstanceInjector*& dyn__lazyInjector();
    // Get instance field reference: private readonly Zenject.Internal.SingletonMarkRegistry _singletonMarkRegistry
    Zenject::Internal::SingletonMarkRegistry*& dyn__singletonMarkRegistry();
    // Get instance field reference: private readonly System.Collections.Generic.Queue`1<Zenject.BindStatement> _currentBindings
    System::Collections::Generic::Queue_1<Zenject::BindStatement*>*& dyn__currentBindings();
    // Get instance field reference: private readonly System.Collections.Generic.List`1<Zenject.BindStatement> _childBindings
    System::Collections::Generic::List_1<Zenject::BindStatement*>*& dyn__childBindings();
    // Get instance field reference: private readonly System.Collections.Generic.HashSet`1<System.Type> _validatedTypes
    System::Collections::Generic::HashSet_1<System::Type*>*& dyn__validatedTypes();
    // Get instance field reference: private readonly System.Collections.Generic.List`1<Zenject.IValidatable> _validationQueue
    System::Collections::Generic::List_1<Zenject::IValidatable*>*& dyn__validationQueue();
    // Get instance field reference: private UnityEngine.Transform _contextTransform
    UnityEngine::Transform*& dyn__contextTransform();
    // Get instance field reference: private System.Boolean _hasLookedUpContextTransform
    bool& dyn__hasLookedUpContextTransform();
    // Get instance field reference: private UnityEngine.Transform _inheritedDefaultParent
    UnityEngine::Transform*& dyn__inheritedDefaultParent();
    // Get instance field reference: private UnityEngine.Transform _explicitDefaultParent
    UnityEngine::Transform*& dyn__explicitDefaultParent();
    // Get instance field reference: private System.Boolean _hasExplicitDefaultParent
    bool& dyn__hasExplicitDefaultParent();
    // Get instance field reference: private Zenject.ZenjectSettings _settings
    Zenject::ZenjectSettings*& dyn__settings();
    // Get instance field reference: private System.Boolean _hasResolvedRoots
    bool& dyn__hasResolvedRoots();
    // Get instance field reference: private System.Boolean _isFinalizingBinding
    bool& dyn__isFinalizingBinding();
    // Get instance field reference: private System.Boolean _isValidating
    bool& dyn__isValidating();
    // Get instance field reference: private System.Boolean _isInstalling
    bool& dyn__isInstalling();
    // Get instance field reference: private System.Boolean <AssertOnNewGameObjects>k__BackingField
    bool& dyn_$AssertOnNewGameObjects$k__BackingField();
    // public Zenject.ZenjectSettings get_Settings()
    // Offset: 0x1501BF8
    Zenject::ZenjectSettings* get_Settings();
    // public System.Void set_Settings(Zenject.ZenjectSettings value)
    // Offset: 0x1501C00
    void set_Settings(Zenject::ZenjectSettings* value);
    // Zenject.Internal.SingletonMarkRegistry get_SingletonMarkRegistry()
    // Offset: 0x1501C7C
    Zenject::Internal::SingletonMarkRegistry* get_SingletonMarkRegistry();
    // public System.Collections.Generic.IEnumerable`1<Zenject.IProvider> get_AllProviders()
    // Offset: 0x1501C84
    System::Collections::Generic::IEnumerable_1<Zenject::IProvider*>* get_AllProviders();
    // private UnityEngine.Transform get_ContextTransform()
    // Offset: 0x15021C8
    UnityEngine::Transform* get_ContextTransform();
    // public System.Boolean get_AssertOnNewGameObjects()
    // Offset: 0x1502284
    bool get_AssertOnNewGameObjects();
    // public System.Void set_AssertOnNewGameObjects(System.Boolean value)
    // Offset: 0x150228C
    void set_AssertOnNewGameObjects(bool value);
    // public UnityEngine.Transform get_InheritedDefaultParent()
    // Offset: 0x1502298
    UnityEngine::Transform* get_InheritedDefaultParent();
    // public UnityEngine.Transform get_DefaultParent()
    // Offset: 0x15022A0
    UnityEngine::Transform* get_DefaultParent();
    // public System.Void set_DefaultParent(UnityEngine.Transform value)
    // Offset: 0x1500510
    void set_DefaultParent(UnityEngine::Transform* value);
    // public Zenject.DiContainer[] get_ParentContainers()
    // Offset: 0x1502190
    ::ArrayW<Zenject::DiContainer*> get_ParentContainers();
    // public Zenject.DiContainer[] get_AncestorContainers()
    // Offset: 0x15022A8
    ::ArrayW<Zenject::DiContainer*> get_AncestorContainers();
    // public System.Boolean get_ChecksForCircularDependencies()
    // Offset: 0x15022E0
    bool get_ChecksForCircularDependencies();
    // public System.Boolean get_IsValidating()
    // Offset: 0x15022E8
    bool get_IsValidating();
    // public System.Boolean get_IsInstalling()
    // Offset: 0x15022F0
    bool get_IsInstalling();
    // public System.Void set_IsInstalling(System.Boolean value)
    // Offset: 0x15022F8
    void set_IsInstalling(bool value);
    // public System.Collections.Generic.IEnumerable`1<Zenject.BindingId> get_AllContracts()
    // Offset: 0x1502304
    System::Collections::Generic::IEnumerable_1<Zenject::BindingId>* get_AllContracts();
    // public System.Void .ctor(System.Collections.Generic.IEnumerable`1<Zenject.DiContainer> parentContainersEnumerable, System.Boolean isValidating)
    // Offset: 0x1500B60
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(System::Collections::Generic::IEnumerable_1<Zenject::DiContainer*>* parentContainersEnumerable, bool isValidating) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(parentContainersEnumerable, isValidating)));
    }
    // public System.Void .ctor(System.Boolean isValidating)
    // Offset: 0x15018C8
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(bool isValidating) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(isValidating)));
    }
    // public System.Void .ctor(Zenject.DiContainer parentContainer, System.Boolean isValidating)
    // Offset: 0x1501A84
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(Zenject::DiContainer* parentContainer, bool isValidating) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(parentContainer, isValidating)));
    }
    // public System.Void .ctor(Zenject.DiContainer parentContainer)
    // Offset: 0x1501B3C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(Zenject::DiContainer* parentContainer) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(parentContainer)));
    }
    // public System.Void .ctor(System.Collections.Generic.IEnumerable`1<Zenject.DiContainer> parentContainers)
    // Offset: 0x1501BF0
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(System::Collections::Generic::IEnumerable_1<Zenject::DiContainer*>* parentContainers) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(parentContainers)));
    }
    // private System.Void InstallDefaultBindings()
    // Offset: 0x1501338
    void InstallDefaultBindings();
    // private System.Object CreateLazyBinding(Zenject.InjectContext context)
    // Offset: 0x1501E54
    ::Il2CppObject* CreateLazyBinding(Zenject::InjectContext* context);
    // public System.Void QueueForValidate(Zenject.IValidatable validatable)
    // Offset: 0x15020BC
    void QueueForValidate(Zenject::IValidatable* validatable);
    // private System.Boolean ShouldInheritBinding(Zenject.BindStatement binding, Zenject.DiContainer ancestorContainer)
    // Offset: 0x150179C
    bool ShouldInheritBinding(Zenject::BindStatement* binding, Zenject::DiContainer* ancestorContainer);
    // public System.Void ResolveRoots()
    // Offset: 0x1502364
    void ResolveRoots();
    // private System.Void ResolveDependencyRoots()
    // Offset: 0x15023DC
    void ResolveDependencyRoots();
    // private System.Void ValidateFullResolve()
    // Offset: 0x1502E90
    void ValidateFullResolve();
    // private System.Void FlushValidationQueue()
    // Offset: 0x15029AC
    void FlushValidationQueue();
    // public Zenject.DiContainer CreateSubContainer()
    // Offset: 0x1503290
    Zenject::DiContainer* CreateSubContainer();
    // public System.Void QueueForInject(System.Object instance)
    // Offset: 0x1503364
    void QueueForInject(::Il2CppObject* instance);
    // public T LazyInject(T instance)
    // Offset: 0xFFFFFFFF
    template<class T>
    T LazyInject(T instance) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::LazyInject");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "LazyInject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(instance)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, instance)));
    }
    // private Zenject.DiContainer CreateSubContainer(System.Boolean isValidating)
    // Offset: 0x1503298
    Zenject::DiContainer* CreateSubContainer(bool isValidating);
    // public System.Void RegisterProvider(Zenject.BindingId bindingId, Zenject.BindingCondition condition, Zenject.IProvider provider, System.Boolean nonLazy)
    // Offset: 0x1503380
    void RegisterProvider(Zenject::BindingId bindingId, Zenject::BindingCondition* condition, Zenject::IProvider* provider, bool nonLazy);
    // private System.Void GetProviderMatches(Zenject.InjectContext context, System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo> buffer)
    // Offset: 0x15034B0
    void GetProviderMatches(Zenject::InjectContext* context, System::Collections::Generic::List_1<Zenject::DiContainer::ProviderInfo*>* buffer);
    // private Zenject.DiContainer/Zenject.ProviderInfo TryGetUniqueProvider(Zenject.InjectContext context)
    // Offset: 0x1503748
    Zenject::DiContainer::ProviderInfo* TryGetUniqueProvider(Zenject::InjectContext* context);
    // private System.Collections.Generic.List`1<Zenject.DiContainer> FlattenInheritanceChain()
    // Offset: 0x150160C
    System::Collections::Generic::List_1<Zenject::DiContainer*>* FlattenInheritanceChain();
    // private System.Void GetLocalProviders(Zenject.BindingId bindingId, System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo> buffer)
    // Offset: 0x1503CEC
    void GetLocalProviders(Zenject::BindingId bindingId, System::Collections::Generic::List_1<Zenject::DiContainer::ProviderInfo*>* buffer);
    // private System.Void GetProvidersForContract(Zenject.BindingId bindingId, Zenject.InjectSources sourceType, System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo> buffer)
    // Offset: 0x150366C
    void GetProvidersForContract(Zenject::BindingId bindingId, Zenject::InjectSources sourceType, System::Collections::Generic::List_1<Zenject::DiContainer::ProviderInfo*>* buffer);
    // public System.Void Install()
    // Offset: 0xFFFFFFFF
    template<class TInstaller>
    void Install() {
      static_assert(std::is_convertible_v<TInstaller, Zenject::Installer*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Install");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Install", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TInstaller>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TInstaller>::get()}));
      THROW_UNLESS((::il2cpp_utils::RunMethod<Il2CppObject*, false>(this, ___generic__method)));
    }
    // public System.Void Install(System.Object[] extraArgs)
    // Offset: 0xFFFFFFFF
    template<class TInstaller>
    void Install(::ArrayW<::Il2CppObject*> extraArgs) {
      static_assert(std::is_convertible_v<TInstaller, Zenject::Installer*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Install");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Install", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TInstaller>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(extraArgs)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TInstaller>::get()}));
      THROW_UNLESS((::il2cpp_utils::RunMethod<Il2CppObject*, false>(this, ___generic__method, extraArgs)));
    }
    // public System.Collections.IList ResolveAll(Zenject.InjectContext context)
    // Offset: 0x1503170
    System::Collections::IList* ResolveAll(Zenject::InjectContext* context);
    // public System.Void ResolveAll(Zenject.InjectContext context, System.Collections.Generic.List`1<System.Object> buffer)
    // Offset: 0x1503E08
    void ResolveAll(Zenject::InjectContext* context, System::Collections::Generic::List_1<::Il2CppObject*>* buffer);
    // private System.Void CheckForInstallWarning(Zenject.InjectContext context)
    // Offset: 0x15043B0
    void CheckForInstallWarning(Zenject::InjectContext* context);
    // public System.Type ResolveType()
    // Offset: 0xFFFFFFFF
    template<class T>
    System::Type* ResolveType() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::ResolveType");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "ResolveType", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<System::Type*, false>(this, ___generic__method)));
    }
    // public System.Type ResolveType(System.Type type)
    // Offset: 0x15043D8
    System::Type* ResolveType(System::Type* type);
    // public System.Type ResolveType(Zenject.InjectContext context)
    // Offset: 0x1504510
    System::Type* ResolveType(Zenject::InjectContext* context);
    // public System.Collections.Generic.List`1<System.Type> ResolveTypeAll(System.Type type)
    // Offset: 0x15047A4
    System::Collections::Generic::List_1<System::Type*>* ResolveTypeAll(System::Type* type);
    // public System.Collections.Generic.List`1<System.Type> ResolveTypeAll(System.Type type, System.Object identifier)
    // Offset: 0x15047AC
    System::Collections::Generic::List_1<System::Type*>* ResolveTypeAll(System::Type* type, ::Il2CppObject* identifier);
    // public System.Collections.Generic.List`1<System.Type> ResolveTypeAll(Zenject.InjectContext context)
    // Offset: 0x1504900
    System::Collections::Generic::List_1<System::Type*>* ResolveTypeAll(Zenject::InjectContext* context);
    // public System.Object Resolve(Zenject.BindingId id)
    // Offset: 0x1504B9C
    ::Il2CppObject* Resolve(Zenject::BindingId id);
    // public System.Object Resolve(Zenject.InjectContext context)
    // Offset: 0x1504CF0
    ::Il2CppObject* Resolve(Zenject::InjectContext* context);
    // private System.Void SafeGetInstances(Zenject.DiContainer/Zenject.ProviderInfo providerInfo, Zenject.InjectContext context, System.Collections.Generic.List`1<System.Object> instances)
    // Offset: 0x1502B54
    void SafeGetInstances(Zenject::DiContainer::ProviderInfo* providerInfo, Zenject::InjectContext* context, System::Collections::Generic::List_1<::Il2CppObject*>* instances);
    // public Zenject.DecoratorToChoiceFromBinder`1<TContract> Decorate()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    Zenject::DecoratorToChoiceFromBinder_1<TContract>* Decorate() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Decorate");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Decorate", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::DecoratorToChoiceFromBinder_1<TContract>*, false>(this, ___generic__method)));
    }
    // private System.Void GetDecoratedInstances(Zenject.IProvider provider, Zenject.InjectContext context, System.Collections.Generic.List`1<System.Object> buffer)
    // Offset: 0x15058FC
    void GetDecoratedInstances(Zenject::IProvider* provider, Zenject::InjectContext* context, System::Collections::Generic::List_1<::Il2CppObject*>* buffer);
    // private Zenject.Internal.IDecoratorProvider TryGetDecoratorProvider(System.Type contractType)
    // Offset: 0x1505A28
    Zenject::Internal::IDecoratorProvider* TryGetDecoratorProvider(System::Type* contractType);
    // private System.Int32 GetContainerHeirarchyDistance(Zenject.DiContainer container)
    // Offset: 0x1503C78
    int GetContainerHeirarchyDistance(Zenject::DiContainer* container);
    // private System.Nullable`1<System.Int32> GetContainerHeirarchyDistance(Zenject.DiContainer container, System.Int32 depth)
    // Offset: 0x1505B20
    System::Nullable_1<int> GetContainerHeirarchyDistance(Zenject::DiContainer* container, int depth);
    // public System.Collections.Generic.IEnumerable`1<System.Type> GetDependencyContracts()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    System::Collections::Generic::IEnumerable_1<System::Type*>* GetDependencyContracts() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::GetDependencyContracts");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "GetDependencyContracts", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<System::Collections::Generic::IEnumerable_1<System::Type*>*, false>(this, ___generic__method)));
    }
    // public System.Collections.Generic.IEnumerable`1<System.Type> GetDependencyContracts(System.Type contract)
    // Offset: 0x1505C68
    System::Collections::Generic::IEnumerable_1<System::Type*>* GetDependencyContracts(System::Type* contract);
    // private System.Object InstantiateInternal(System.Type concreteType, System.Boolean autoInject, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x1505CE8
    ::Il2CppObject* InstantiateInternal(System::Type* concreteType, bool autoInject, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // public System.Void InjectExplicit(System.Object injectable, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x15066B4
    void InjectExplicit(::Il2CppObject* injectable, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs);
    // public System.Void InjectExplicit(System.Object injectable, System.Type injectableType, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x14F42DC
    void InjectExplicit(::Il2CppObject* injectable, System::Type* injectableType, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // private System.Void CallInjectMethodsTopDown(System.Object injectable, System.Type injectableType, Zenject.InjectTypeInfo typeInfo, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier, System.Boolean isDryRun)
    // Offset: 0x1506BCC
    void CallInjectMethodsTopDown(::Il2CppObject* injectable, System::Type* injectableType, Zenject::InjectTypeInfo* typeInfo, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier, bool isDryRun);
    // private System.Void InjectMembersTopDown(System.Object injectable, System.Type injectableType, Zenject.InjectTypeInfo typeInfo, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier, System.Boolean isDryRun)
    // Offset: 0x15070F4
    void InjectMembersTopDown(::Il2CppObject* injectable, System::Type* injectableType, Zenject::InjectTypeInfo* typeInfo, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier, bool isDryRun);
    // private System.Void InjectExplicitInternal(System.Object injectable, System.Type injectableType, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x15067A0
    void InjectExplicitInternal(::Il2CppObject* injectable, System::Type* injectableType, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // UnityEngine.GameObject CreateAndParentPrefabResource(System.String resourcePath, Zenject.GameObjectCreationParameters gameObjectBindInfo, Zenject.InjectContext context, out System.Boolean shouldMakeActive)
    // Offset: 0x15073B0
    UnityEngine::GameObject* CreateAndParentPrefabResource(::Il2CppString* resourcePath, Zenject::GameObjectCreationParameters* gameObjectBindInfo, Zenject::InjectContext* context, ByRef<bool> shouldMakeActive);
    // private UnityEngine.GameObject GetPrefabAsGameObject(UnityEngine.Object prefab)
    // Offset: 0x15078F0
    UnityEngine::GameObject* GetPrefabAsGameObject(UnityEngine::Object* prefab);
    // UnityEngine.GameObject CreateAndParentPrefab(UnityEngine.Object prefab, Zenject.GameObjectCreationParameters gameObjectBindInfo, Zenject.InjectContext context, out System.Boolean shouldMakeActive)
    // Offset: 0x15074DC
    UnityEngine::GameObject* CreateAndParentPrefab(UnityEngine::Object* prefab, Zenject::GameObjectCreationParameters* gameObjectBindInfo, Zenject::InjectContext* context, ByRef<bool> shouldMakeActive);
    // public UnityEngine.GameObject CreateEmptyGameObject(System.String name)
    // Offset: 0x1507E8C
    UnityEngine::GameObject* CreateEmptyGameObject(::Il2CppString* name);
    // public UnityEngine.GameObject CreateEmptyGameObject(Zenject.GameObjectCreationParameters gameObjectBindInfo, Zenject.InjectContext context)
    // Offset: 0x14F4E94
    UnityEngine::GameObject* CreateEmptyGameObject(Zenject::GameObjectCreationParameters* gameObjectBindInfo, Zenject::InjectContext* context);
    // private UnityEngine.Transform GetTransformGroup(Zenject.GameObjectCreationParameters gameObjectBindInfo, Zenject.InjectContext context)
    // Offset: 0x15079F8
    UnityEngine::Transform* GetTransformGroup(Zenject::GameObjectCreationParameters* gameObjectBindInfo, Zenject::InjectContext* context);
    // private UnityEngine.GameObject CreateTransformGroup(System.String groupName)
    // Offset: 0x1507F0C
    UnityEngine::GameObject* CreateTransformGroup(::Il2CppString* groupName);
    // public T Instantiate()
    // Offset: 0xFFFFFFFF
    template<class T>
    T Instantiate() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Instantiate");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Instantiate", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method)));
    }
    // public T Instantiate(System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T Instantiate(System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Instantiate");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Instantiate", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, extraArgs)));
    }
    // public System.Object Instantiate(System.Type concreteType)
    // Offset: 0x14FB938
    ::Il2CppObject* Instantiate(System::Type* concreteType);
    // public System.Object Instantiate(System.Type concreteType, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x1507FD4
    ::Il2CppObject* Instantiate(System::Type* concreteType, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public TContract InstantiateComponent(UnityEngine.GameObject gameObject)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    TContract InstantiateComponent(UnityEngine::GameObject* gameObject) {
      static_assert(std::is_convertible_v<TContract, UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiateComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObject)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<TContract, false>(this, ___generic__method, gameObject)));
    }
    // public TContract InstantiateComponent(UnityEngine.GameObject gameObject, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    TContract InstantiateComponent(UnityEngine::GameObject* gameObject, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<TContract, UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiateComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObject), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<TContract, false>(this, ___generic__method, gameObject, extraArgs)));
    }
    // public UnityEngine.Component InstantiateComponent(System.Type componentType, UnityEngine.GameObject gameObject)
    // Offset: 0x1508100
    UnityEngine::Component* InstantiateComponent(System::Type* componentType, UnityEngine::GameObject* gameObject);
    // public UnityEngine.Component InstantiateComponent(System.Type componentType, UnityEngine.GameObject gameObject, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x150817C
    UnityEngine::Component* InstantiateComponent(System::Type* componentType, UnityEngine::GameObject* gameObject, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public T InstantiateComponentOnNewGameObject()
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiateComponentOnNewGameObject() {
      static_assert(std::is_convertible_v<T, UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiateComponentOnNewGameObject");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponentOnNewGameObject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method)));
    }
    // public T InstantiateComponentOnNewGameObject(System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiateComponentOnNewGameObject(System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<T, UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiateComponentOnNewGameObject");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponentOnNewGameObject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, extraArgs)));
    }
    // public T InstantiateComponentOnNewGameObject(System.String gameObjectName)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiateComponentOnNewGameObject(::Il2CppString* gameObjectName) {
      static_assert(std::is_convertible_v<T, UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiateComponentOnNewGameObject");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponentOnNewGameObject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObjectName)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, gameObjectName)));
    }
    // public T InstantiateComponentOnNewGameObject(System.String gameObjectName, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiateComponentOnNewGameObject(::Il2CppString* gameObjectName, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<T, UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiateComponentOnNewGameObject");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponentOnNewGameObject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObjectName), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, gameObjectName, extraArgs)));
    }
    // public UnityEngine.GameObject InstantiatePrefab(UnityEngine.Object prefab)
    // Offset: 0x1508294
    UnityEngine::GameObject* InstantiatePrefab(UnityEngine::Object* prefab);
    // public UnityEngine.GameObject InstantiatePrefab(UnityEngine.Object prefab, UnityEngine.Transform parentTransform)
    // Offset: 0x150839C
    UnityEngine::GameObject* InstantiatePrefab(UnityEngine::Object* prefab, UnityEngine::Transform* parentTransform);
    // public UnityEngine.GameObject InstantiatePrefab(UnityEngine.Object prefab, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform)
    // Offset: 0x1508420
    UnityEngine::GameObject* InstantiatePrefab(UnityEngine::Object* prefab, UnityEngine::Vector3 position, UnityEngine::Quaternion rotation, UnityEngine::Transform* parentTransform);
    // public UnityEngine.GameObject InstantiatePrefab(UnityEngine.Object prefab, Zenject.GameObjectCreationParameters gameObjectBindInfo)
    // Offset: 0x1508314
    UnityEngine::GameObject* InstantiatePrefab(UnityEngine::Object* prefab, Zenject::GameObjectCreationParameters* gameObjectBindInfo);
    // public UnityEngine.GameObject InstantiatePrefabResource(System.String resourcePath)
    // Offset: 0x15086A8
    UnityEngine::GameObject* InstantiatePrefabResource(::Il2CppString* resourcePath);
    // public UnityEngine.GameObject InstantiatePrefabResource(System.String resourcePath, UnityEngine.Transform parentTransform)
    // Offset: 0x150883C
    UnityEngine::GameObject* InstantiatePrefabResource(::Il2CppString* resourcePath, UnityEngine::Transform* parentTransform);
    // public UnityEngine.GameObject InstantiatePrefabResource(System.String resourcePath, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform)
    // Offset: 0x15088C0
    UnityEngine::GameObject* InstantiatePrefabResource(::Il2CppString* resourcePath, UnityEngine::Vector3 position, UnityEngine::Quaternion rotation, UnityEngine::Transform* parentTransform);
    // public UnityEngine.GameObject InstantiatePrefabResource(System.String resourcePath, Zenject.GameObjectCreationParameters creationInfo)
    // Offset: 0x1508728
    UnityEngine::GameObject* InstantiatePrefabResource(::Il2CppString* resourcePath, Zenject::GameObjectCreationParameters* creationInfo);
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(UnityEngine::Object* prefab) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, prefab)));
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(UnityEngine::Object* prefab, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, prefab, extraArgs)));
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, UnityEngine.Transform parentTransform)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(UnityEngine::Object* prefab, UnityEngine::Transform* parentTransform) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(parentTransform)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, prefab, parentTransform)));
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(UnityEngine::Object* prefab, UnityEngine::Transform* parentTransform, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(parentTransform), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, prefab, parentTransform, extraArgs)));
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(UnityEngine::Object* prefab, UnityEngine::Vector3 position, UnityEngine::Quaternion rotation, UnityEngine::Transform* parentTransform) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(position), ::il2cpp_utils::ExtractType(rotation), ::il2cpp_utils::ExtractType(parentTransform)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, prefab, position, rotation, parentTransform)));
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(UnityEngine::Object* prefab, UnityEngine::Vector3 position, UnityEngine::Quaternion rotation, UnityEngine::Transform* parentTransform, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(position), ::il2cpp_utils::ExtractType(rotation), ::il2cpp_utils::ExtractType(parentTransform), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, prefab, position, rotation, parentTransform, extraArgs)));
    }
    // public System.Object InstantiatePrefabForComponent(System.Type concreteType, UnityEngine.Object prefab, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x15089F4
    ::Il2CppObject* InstantiatePrefabForComponent(System::Type* concreteType, UnityEngine::Object* prefab, UnityEngine::Transform* parentTransform, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public System.Object InstantiatePrefabForComponent(System.Type concreteType, UnityEngine.Object prefab, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs, Zenject.GameObjectCreationParameters creationInfo)
    // Offset: 0x1508A9C
    ::Il2CppObject* InstantiatePrefabForComponent(System::Type* concreteType, UnityEngine::Object* prefab, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs, Zenject::GameObjectCreationParameters* creationInfo);
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::Il2CppString* resourcePath) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, resourcePath)));
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::Il2CppString* resourcePath, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, resourcePath, extraArgs)));
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, UnityEngine.Transform parentTransform)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::Il2CppString* resourcePath, UnityEngine::Transform* parentTransform) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(parentTransform)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, resourcePath, parentTransform)));
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::Il2CppString* resourcePath, UnityEngine::Transform* parentTransform, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(parentTransform), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, resourcePath, parentTransform, extraArgs)));
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::Il2CppString* resourcePath, UnityEngine::Vector3 position, UnityEngine::Quaternion rotation, UnityEngine::Transform* parentTransform) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(position), ::il2cpp_utils::ExtractType(rotation), ::il2cpp_utils::ExtractType(parentTransform)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, resourcePath, position, rotation, parentTransform)));
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::Il2CppString* resourcePath, UnityEngine::Vector3 position, UnityEngine::Quaternion rotation, UnityEngine::Transform* parentTransform, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(position), ::il2cpp_utils::ExtractType(rotation), ::il2cpp_utils::ExtractType(parentTransform), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, resourcePath, position, rotation, parentTransform, extraArgs)));
    }
    // public System.Object InstantiatePrefabResourceForComponent(System.Type concreteType, System.String resourcePath, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x1508B90
    ::Il2CppObject* InstantiatePrefabResourceForComponent(System::Type* concreteType, ::Il2CppString* resourcePath, UnityEngine::Transform* parentTransform, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public T InstantiateScriptableObjectResource(System.String resourcePath)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiateScriptableObjectResource(::Il2CppString* resourcePath) {
      static_assert(std::is_convertible_v<T, UnityEngine::ScriptableObject*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiateScriptableObjectResource");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateScriptableObjectResource", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, resourcePath)));
    }
    // public T InstantiateScriptableObjectResource(System.String resourcePath, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiateScriptableObjectResource(::Il2CppString* resourcePath, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<T, UnityEngine::ScriptableObject*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiateScriptableObjectResource");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateScriptableObjectResource", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, resourcePath, extraArgs)));
    }
    // public System.Object InstantiateScriptableObjectResource(System.Type scriptableObjectType, System.String resourcePath)
    // Offset: 0x1508D18
    ::Il2CppObject* InstantiateScriptableObjectResource(System::Type* scriptableObjectType, ::Il2CppString* resourcePath);
    // public System.Object InstantiateScriptableObjectResource(System.Type scriptableObjectType, System.String resourcePath, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x1508D8C
    ::Il2CppObject* InstantiateScriptableObjectResource(System::Type* scriptableObjectType, ::Il2CppString* resourcePath, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public System.Void InjectGameObject(UnityEngine.GameObject gameObject)
    // Offset: 0x1508554
    void InjectGameObject(UnityEngine::GameObject* gameObject);
    // public T InjectGameObjectForComponent(UnityEngine.GameObject gameObject)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InjectGameObjectForComponent(UnityEngine::GameObject* gameObject) {
      static_assert(std::is_convertible_v<T, UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InjectGameObjectForComponent");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InjectGameObjectForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObject)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, gameObject)));
    }
    // public T InjectGameObjectForComponent(UnityEngine.GameObject gameObject, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InjectGameObjectForComponent(UnityEngine::GameObject* gameObject, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<T, UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InjectGameObjectForComponent");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InjectGameObjectForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObject), ::il2cpp_utils::ExtractType(extraArgs)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, gameObject, extraArgs)));
    }
    // public System.Object InjectGameObjectForComponent(UnityEngine.GameObject gameObject, System.Type componentType, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x1508F38
    ::Il2CppObject* InjectGameObjectForComponent(UnityEngine::GameObject* gameObject, System::Type* componentType, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public UnityEngine.Component InjectGameObjectForComponentExplicit(UnityEngine.GameObject gameObject, System.Type componentType, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x1508FE8
    UnityEngine::Component* InjectGameObjectForComponentExplicit(UnityEngine::GameObject* gameObject, System::Type* componentType, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // public System.Void Inject(System.Object injectable)
    // Offset: 0x14FB9A4
    void Inject(::Il2CppObject* injectable);
    // public System.Void Inject(System.Object injectable, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x150930C
    void Inject(::Il2CppObject* injectable, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public TContract Resolve()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    TContract Resolve() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Resolve");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Resolve", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<TContract, false>(this, ___generic__method)));
    }
    // public System.Object Resolve(System.Type contractType)
    // Offset: 0x1509344
    ::Il2CppObject* Resolve(System::Type* contractType);
    // public TContract ResolveId(System.Object identifier)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    TContract ResolveId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::ResolveId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "ResolveId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<TContract, false>(this, ___generic__method, identifier)));
    }
    // public System.Object ResolveId(System.Type contractType, System.Object identifier)
    // Offset: 0x150934C
    ::Il2CppObject* ResolveId(System::Type* contractType, ::Il2CppObject* identifier);
    // public TContract TryResolve()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    TContract TryResolve() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::TryResolve");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "TryResolve", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<TContract, false>(this, ___generic__method)));
    }
    // public System.Object TryResolve(System.Type contractType)
    // Offset: 0x15094A0
    ::Il2CppObject* TryResolve(System::Type* contractType);
    // public TContract TryResolveId(System.Object identifier)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    TContract TryResolveId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::TryResolveId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "TryResolveId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<TContract, false>(this, ___generic__method, identifier)));
    }
    // public System.Object TryResolveId(System.Type contractType, System.Object identifier)
    // Offset: 0x15094A8
    ::Il2CppObject* TryResolveId(System::Type* contractType, ::Il2CppObject* identifier);
    // public System.Collections.Generic.List`1<TContract> ResolveAll()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    System::Collections::Generic::List_1<TContract>* ResolveAll() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::ResolveAll");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "ResolveAll", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<System::Collections::Generic::List_1<TContract>*, false>(this, ___generic__method)));
    }
    // public System.Collections.IList ResolveAll(System.Type contractType)
    // Offset: 0x1509604
    System::Collections::IList* ResolveAll(System::Type* contractType);
    // public System.Collections.Generic.List`1<TContract> ResolveIdAll(System.Object identifier)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    System::Collections::Generic::List_1<TContract>* ResolveIdAll(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::ResolveIdAll");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "ResolveIdAll", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<System::Collections::Generic::List_1<TContract>*, false>(this, ___generic__method, identifier)));
    }
    // public System.Collections.IList ResolveIdAll(System.Type contractType, System.Object identifier)
    // Offset: 0x150960C
    System::Collections::IList* ResolveIdAll(System::Type* contractType, ::Il2CppObject* identifier);
    // public System.Void UnbindAll()
    // Offset: 0x1509768
    void UnbindAll();
    // public System.Boolean Unbind()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    bool Unbind() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Unbind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Unbind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<bool, false>(this, ___generic__method)));
    }
    // public System.Boolean Unbind(System.Type contractType)
    // Offset: 0x15097C8
    bool Unbind(System::Type* contractType);
    // public System.Boolean UnbindId(System.Object identifier)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    bool UnbindId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::UnbindId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "UnbindId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<bool, false>(this, ___generic__method, identifier)));
    }
    // public System.Boolean UnbindId(System.Type contractType, System.Object identifier)
    // Offset: 0x15097D0
    bool UnbindId(System::Type* contractType, ::Il2CppObject* identifier);
    // public System.Void UnbindInterfacesTo()
    // Offset: 0xFFFFFFFF
    template<class TConcrete>
    void UnbindInterfacesTo() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::UnbindInterfacesTo");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "UnbindInterfacesTo", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()}));
      THROW_UNLESS((::il2cpp_utils::RunMethod<Il2CppObject*, false>(this, ___generic__method)));
    }
    // public System.Void UnbindInterfacesTo(System.Type concreteType)
    // Offset: 0x1509848
    void UnbindInterfacesTo(System::Type* concreteType);
    // public System.Boolean Unbind()
    // Offset: 0xFFFFFFFF
    template<class TContract, class TConcrete>
    bool Unbind() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Unbind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Unbind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<bool, false>(this, ___generic__method)));
    }
    // public System.Boolean Unbind(System.Type contractType, System.Type concreteType)
    // Offset: 0x1509920
    bool Unbind(System::Type* contractType, System::Type* concreteType);
    // public System.Boolean UnbindId(System.Object identifier)
    // Offset: 0xFFFFFFFF
    template<class TContract, class TConcrete>
    bool UnbindId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::UnbindId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "UnbindId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<bool, false>(this, ___generic__method, identifier)));
    }
    // public System.Boolean UnbindId(System.Type contractType, System.Type concreteType, System.Object identifier)
    // Offset: 0x1509928
    bool UnbindId(System::Type* contractType, System::Type* concreteType, ::Il2CppObject* identifier);
    // public System.Boolean HasBinding()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    bool HasBinding() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::HasBinding");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "HasBinding", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<bool, false>(this, ___generic__method)));
    }
    // public System.Boolean HasBinding(System.Type contractType)
    // Offset: 0x1509B18
    bool HasBinding(System::Type* contractType);
    // public System.Boolean HasBindingId(System.Object identifier)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    bool HasBindingId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::HasBindingId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "HasBindingId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<bool, false>(this, ___generic__method, identifier)));
    }
    // public System.Boolean HasBindingId(System.Type contractType, System.Object identifier)
    // Offset: 0x1509B24
    bool HasBindingId(System::Type* contractType, ::Il2CppObject* identifier);
    // public System.Boolean HasBindingId(System.Type contractType, System.Object identifier, Zenject.InjectSources sourceType)
    // Offset: 0x1509B2C
    bool HasBindingId(System::Type* contractType, ::Il2CppObject* identifier, Zenject::InjectSources sourceType);
    // public System.Boolean HasBinding(Zenject.InjectContext context)
    // Offset: 0x1509C90
    bool HasBinding(Zenject::InjectContext* context);
    // public System.Void FlushBindings()
    // Offset: 0x1501530
    void FlushBindings();
    // private System.Void FinalizeBinding(Zenject.BindStatement binding)
    // Offset: 0x1501860
    void FinalizeBinding(Zenject::BindStatement* binding);
    // public Zenject.BindStatement StartBinding(System.Boolean flush)
    // Offset: 0x1509DAC
    Zenject::BindStatement* StartBinding(bool flush);
    // public Zenject.ConcreteBinderGeneric`1<TContract> Rebind()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    Zenject::ConcreteBinderGeneric_1<TContract>* Rebind() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Rebind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Rebind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::ConcreteBinderGeneric_1<TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.ConcreteBinderGeneric`1<TContract> RebindId(System.Object identifier)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    Zenject::ConcreteBinderGeneric_1<TContract>* RebindId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::RebindId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "RebindId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::ConcreteBinderGeneric_1<TContract>*, false>(this, ___generic__method, identifier)));
    }
    // public Zenject.ConcreteBinderNonGeneric Rebind(System.Type contractType)
    // Offset: 0x1509E74
    Zenject::ConcreteBinderNonGeneric* Rebind(System::Type* contractType);
    // public Zenject.ConcreteBinderNonGeneric RebindId(System.Type contractType, System.Object identifier)
    // Offset: 0x1509E7C
    Zenject::ConcreteBinderNonGeneric* RebindId(System::Type* contractType, ::Il2CppObject* identifier);
    // public Zenject.ConcreteIdBinderGeneric`1<TContract> Bind()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    Zenject::ConcreteIdBinderGeneric_1<TContract>* Bind() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Bind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Bind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::ConcreteIdBinderGeneric_1<TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.ConcreteIdBinderGeneric`1<TContract> BindNoFlush()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    Zenject::ConcreteIdBinderGeneric_1<TContract>* BindNoFlush() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindNoFlush");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindNoFlush", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::ConcreteIdBinderGeneric_1<TContract>*, false>(this, ___generic__method)));
    }
    // private Zenject.ConcreteIdBinderGeneric`1<TContract> Bind(Zenject.BindStatement bindStatement)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    Zenject::ConcreteIdBinderGeneric_1<TContract>* Bind(Zenject::BindStatement* bindStatement) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::Bind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Bind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(bindStatement)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::ConcreteIdBinderGeneric_1<TContract>*, false>(this, ___generic__method, bindStatement)));
    }
    // public Zenject.ConcreteIdBinderNonGeneric Bind(params System.Type[] contractTypes)
    // Offset: 0x14FC5AC
    Zenject::ConcreteIdBinderNonGeneric* Bind(::ArrayW<System::Type*> contractTypes);
    // public Zenject.ConcreteIdBinderNonGeneric Bind(System.Collections.Generic.IEnumerable`1<System.Type> contractTypes)
    // Offset: 0x150A0B0
    Zenject::ConcreteIdBinderNonGeneric* Bind(System::Collections::Generic::IEnumerable_1<System::Type*>* contractTypes);
    // private Zenject.ConcreteIdBinderNonGeneric BindInternal(Zenject.BindInfo bindInfo, Zenject.BindStatement bindingFinalizer)
    // Offset: 0x1509F54
    Zenject::ConcreteIdBinderNonGeneric* BindInternal(Zenject::BindInfo* bindInfo, Zenject::BindStatement* bindingFinalizer);
    // public Zenject.ConcreteIdBinderNonGeneric Bind(System.Action`1<Zenject.ConventionSelectTypesBinder> generator)
    // Offset: 0x150A148
    Zenject::ConcreteIdBinderNonGeneric* Bind(System::Action_1<Zenject::ConventionSelectTypesBinder*>* generator);
    // public Zenject.FromBinderNonGeneric BindInterfacesTo()
    // Offset: 0xFFFFFFFF
    template<class T>
    Zenject::FromBinderNonGeneric* BindInterfacesTo() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindInterfacesTo");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindInterfacesTo", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FromBinderNonGeneric*, false>(this, ___generic__method)));
    }
    // public Zenject.FromBinderNonGeneric BindInterfacesTo(System.Type type)
    // Offset: 0x150A33C
    Zenject::FromBinderNonGeneric* BindInterfacesTo(System::Type* type);
    // public Zenject.FromBinderNonGeneric BindInterfacesAndSelfTo()
    // Offset: 0xFFFFFFFF
    template<class T>
    Zenject::FromBinderNonGeneric* BindInterfacesAndSelfTo() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindInterfacesAndSelfTo");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindInterfacesAndSelfTo", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FromBinderNonGeneric*, false>(this, ___generic__method)));
    }
    // public Zenject.FromBinderNonGeneric BindInterfacesAndSelfTo(System.Type type)
    // Offset: 0x150A4E0
    Zenject::FromBinderNonGeneric* BindInterfacesAndSelfTo(System::Type* type);
    // public Zenject.IdScopeConcreteIdArgConditionCopyNonLazyBinder BindInstance(TContract instance)
    // Offset: 0xFFFFFFFF
    template<class TContract>
    Zenject::IdScopeConcreteIdArgConditionCopyNonLazyBinder* BindInstance(TContract instance) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindInstance");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindInstance", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(instance)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::IdScopeConcreteIdArgConditionCopyNonLazyBinder*, false>(this, ___generic__method, instance)));
    }
    // public System.Void BindInstances(params System.Object[] instances)
    // Offset: 0x150A63C
    void BindInstances(::ArrayW<::Il2CppObject*> instances);
    // private Zenject.FactoryToChoiceIdBinder`1<TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFF
    template<class TContract, class TFactoryContract, class TFactoryConcrete>
    Zenject::FactoryToChoiceIdBinder_1<TContract>* BindFactoryInternal() {
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryConcrete>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_1<TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`1<TContract> BindIFactory()
    // Offset: 0xFFFFFFFF
    template<class TContract>
    Zenject::FactoryToChoiceIdBinder_1<TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_1<TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`1<TContract> BindFactory()
    // Offset: 0xFFFFFFFF
    template<class TContract, class TFactory>
    Zenject::FactoryToChoiceIdBinder_1<TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, Zenject::PlaceholderFactory_1<TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_1<TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`1<TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFF
    template<class TContract, class TFactoryConcrete, class TFactoryContract>
    Zenject::FactoryToChoiceIdBinder_1<TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, Zenject::PlaceholderFactory_1<TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_1<TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPool()
    // Offset: 0xFFFFFFFF
    template<class TItemContract>
    Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPool() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindMemoryPool");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPool", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPool()
    // Offset: 0xFFFFFFFF
    template<class TItemContract, class TPool>
    Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPool() {
      static_assert(std::is_base_of_v<Zenject::IMemoryPool, std::remove_pointer_t<TPool>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindMemoryPool");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPool", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPool>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPool>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPoolCustomInterface(System.Boolean includeConcreteType)
    // Offset: 0xFFFFFFFF
    template<class TItemContract, class TPoolConcrete, class TPoolContract>
    Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPoolCustomInterface(bool includeConcreteType) {
      static_assert(std::is_convertible_v<TPoolConcrete, TPoolContract> && std::is_base_of_v<Zenject::IMemoryPool, std::remove_pointer_t<TPoolConcrete>>);
      static_assert(std::is_base_of_v<Zenject::IMemoryPool, std::remove_pointer_t<TPoolContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindMemoryPoolCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPoolCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(includeConcreteType)})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method, includeConcreteType)));
    }
    // Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPoolCustomInterfaceNoFlush(System.Boolean includeConcreteType)
    // Offset: 0xFFFFFFFF
    template<class TItemContract, class TPoolConcrete, class TPoolContract>
    Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPoolCustomInterfaceNoFlush(bool includeConcreteType) {
      static_assert(std::is_convertible_v<TPoolConcrete, TPoolContract> && std::is_base_of_v<Zenject::IMemoryPool, std::remove_pointer_t<TPoolConcrete>>);
      static_assert(std::is_base_of_v<Zenject::IMemoryPool, std::remove_pointer_t<TPoolContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindMemoryPoolCustomInterfaceNoFlush");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPoolCustomInterfaceNoFlush", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(includeConcreteType)})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method, includeConcreteType)));
    }
    // private Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPoolCustomInterfaceInternal(System.Boolean includeConcreteType, Zenject.BindStatement statement)
    // Offset: 0xFFFFFFFF
    template<class TItemContract, class TPoolConcrete, class TPoolContract>
    Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPoolCustomInterfaceInternal(bool includeConcreteType, Zenject::BindStatement* statement) {
      static_assert(std::is_convertible_v<TPoolConcrete, TPoolContract> && std::is_base_of_v<Zenject::IMemoryPool, std::remove_pointer_t<TPoolConcrete>>);
      static_assert(std::is_base_of_v<Zenject::IMemoryPool, std::remove_pointer_t<TPoolContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindMemoryPoolCustomInterfaceInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPoolCustomInterfaceInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(includeConcreteType), ::il2cpp_utils::ExtractType(statement)})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method, includeConcreteType, statement)));
    }
    // private Zenject.FactoryToChoiceIdBinder`2<TParam1,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TContract, class TFactoryContract, class TFactoryConcrete>
    Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>* BindFactoryInternal() {
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryConcrete>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`2<TParam1,TContract> BindIFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TContract>
    Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`2<TParam1,TContract> BindFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TContract, class TFactory>
    Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, Zenject::PlaceholderFactory_2<TParam1, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`2<TParam1,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TContract, class TFactoryConcrete, class TFactoryContract>
    Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, Zenject::PlaceholderFactory_2<TParam1, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>*, false>(this, ___generic__method)));
    }
    // private Zenject.FactoryToChoiceIdBinder`3<TParam1,TParam2,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TContract, class TFactoryContract, class TFactoryConcrete>
    Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>* BindFactoryInternal() {
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryConcrete>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`3<TParam1,TParam2,TContract> BindIFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TContract>
    Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`3<TParam1,TParam2,TContract> BindFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TContract, class TFactory>
    Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, Zenject::PlaceholderFactory_3<TParam1, TParam2, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`3<TParam1,TParam2,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TContract, class TFactoryConcrete, class TFactoryContract>
    Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, Zenject::PlaceholderFactory_3<TParam1, TParam2, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>*, false>(this, ___generic__method)));
    }
    // private Zenject.FactoryToChoiceIdBinder`4<TParam1,TParam2,TParam3,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TContract, class TFactoryContract, class TFactoryConcrete>
    Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>* BindFactoryInternal() {
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryConcrete>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`4<TParam1,TParam2,TParam3,TContract> BindIFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TContract>
    Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`4<TParam1,TParam2,TParam3,TContract> BindFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TContract, class TFactory>
    Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, Zenject::PlaceholderFactory_4<TParam1, TParam2, TParam3, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`4<TParam1,TParam2,TParam3,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TContract, class TFactoryConcrete, class TFactoryContract>
    Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, Zenject::PlaceholderFactory_4<TParam1, TParam2, TParam3, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>*, false>(this, ___generic__method)));
    }
    // private Zenject.FactoryToChoiceIdBinder`5<TParam1,TParam2,TParam3,TParam4,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TContract, class TFactoryContract, class TFactoryConcrete>
    Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>* BindFactoryInternal() {
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryConcrete>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`5<TParam1,TParam2,TParam3,TParam4,TContract> BindIFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TContract>
    Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`5<TParam1,TParam2,TParam3,TParam4,TContract> BindFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TContract, class TFactory>
    Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, Zenject::PlaceholderFactory_5<TParam1, TParam2, TParam3, TParam4, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`5<TParam1,TParam2,TParam3,TParam4,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TContract, class TFactoryConcrete, class TFactoryContract>
    Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, Zenject::PlaceholderFactory_5<TParam1, TParam2, TParam3, TParam4, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>*, false>(this, ___generic__method)));
    }
    // private Zenject.FactoryToChoiceIdBinder`6<TParam1,TParam2,TParam3,TParam4,TParam5,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TContract, class TFactoryContract, class TFactoryConcrete>
    Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>* BindFactoryInternal() {
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryConcrete>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`6<TParam1,TParam2,TParam3,TParam4,TParam5,TContract> BindIFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TContract>
    Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`6<TParam1,TParam2,TParam3,TParam4,TParam5,TContract> BindFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TContract, class TFactory>
    Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, Zenject::PlaceholderFactory_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`6<TParam1,TParam2,TParam3,TParam4,TParam5,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TContract, class TFactoryConcrete, class TFactoryContract>
    Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, Zenject::PlaceholderFactory_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*, false>(this, ___generic__method)));
    }
    // private Zenject.FactoryToChoiceIdBinder`7<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TContract, class TFactoryContract, class TFactoryConcrete>
    Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>* BindFactoryInternal() {
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryConcrete>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`7<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TContract> BindIFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TContract>
    Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`7<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TContract> BindFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TContract, class TFactory>
    Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, Zenject::PlaceholderFactory_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`7<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TContract, class TFactoryConcrete, class TFactoryContract>
    Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, Zenject::PlaceholderFactory_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*, false>(this, ___generic__method)));
    }
    // private Zenject.FactoryToChoiceIdBinder`11<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TParam7,TParam8,TParam9,TParam10,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TParam7, class TParam8, class TParam9, class TParam10, class TContract, class TFactoryContract, class TFactoryConcrete>
    Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>* BindFactoryInternal() {
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryConcrete>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`11<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TParam7,TParam8,TParam9,TParam10,TContract> BindIFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TParam7, class TParam8, class TParam9, class TParam10, class TContract>
    Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`11<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TParam7,TParam8,TParam9,TParam10,TContract> BindFactory()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TParam7, class TParam8, class TParam9, class TParam10, class TContract, class TFactory>
    Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, Zenject::PlaceholderFactory_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*, false>(this, ___generic__method)));
    }
    // public Zenject.FactoryToChoiceIdBinder`11<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TParam7,TParam8,TParam9,TParam10,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TParam7, class TParam8, class TParam9, class TParam10, class TContract, class TFactoryConcrete, class TFactoryContract>
    Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, Zenject::PlaceholderFactory_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_base_of_v<Zenject::IFactory, std::remove_pointer_t<TFactoryContract>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*, false>(this, ___generic__method)));
    }
    // public T InstantiateExplicit(System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0xFFFFFFFF
    template<class T>
    T InstantiateExplicit(System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::InstantiateExplicit");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateExplicit", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(extraArgs)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<T, false>(this, ___generic__method, extraArgs)));
    }
    // public System.Object InstantiateExplicit(System.Type concreteType, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x1508070
    ::Il2CppObject* InstantiateExplicit(System::Type* concreteType, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs);
    // public System.Object InstantiateExplicit(System.Type concreteType, System.Boolean autoInject, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x150A77C
    ::Il2CppObject* InstantiateExplicit(System::Type* concreteType, bool autoInject, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // public UnityEngine.Component InstantiateComponentExplicit(System.Type componentType, UnityEngine.GameObject gameObject, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x15081C4
    UnityEngine::Component* InstantiateComponentExplicit(System::Type* componentType, UnityEngine::GameObject* gameObject, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs);
    // public System.Object InstantiateScriptableObjectResourceExplicit(System.Type scriptableObjectType, System.String resourcePath, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x1508E18
    ::Il2CppObject* InstantiateScriptableObjectResourceExplicit(System::Type* scriptableObjectType, ::Il2CppString* resourcePath, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs);
    // public System.Object InstantiatePrefabResourceForComponentExplicit(System.Type componentType, System.String resourcePath, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.GameObjectCreationParameters creationInfo)
    // Offset: 0x1508C74
    ::Il2CppObject* InstantiatePrefabResourceForComponentExplicit(System::Type* componentType, ::Il2CppString* resourcePath, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::GameObjectCreationParameters* creationInfo);
    // public System.Object InstantiatePrefabResourceForComponentExplicit(System.Type componentType, System.String resourcePath, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier, Zenject.GameObjectCreationParameters creationInfo)
    // Offset: 0x150A8F8
    ::Il2CppObject* InstantiatePrefabResourceForComponentExplicit(System::Type* componentType, ::Il2CppString* resourcePath, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier, Zenject::GameObjectCreationParameters* creationInfo);
    // public System.Object InstantiatePrefabForComponentExplicit(System.Type componentType, UnityEngine.Object prefab, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x150ABC4
    ::Il2CppObject* InstantiatePrefabForComponentExplicit(System::Type* componentType, UnityEngine::Object* prefab, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs);
    // public System.Object InstantiatePrefabForComponentExplicit(System.Type componentType, UnityEngine.Object prefab, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.GameObjectCreationParameters gameObjectBindInfo)
    // Offset: 0x1508AEC
    ::Il2CppObject* InstantiatePrefabForComponentExplicit(System::Type* componentType, UnityEngine::Object* prefab, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::GameObjectCreationParameters* gameObjectBindInfo);
    // public System.Object InstantiatePrefabForComponentExplicit(System.Type componentType, UnityEngine.Object prefab, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier, Zenject.GameObjectCreationParameters gameObjectBindInfo)
    // Offset: 0x150AA3C
    ::Il2CppObject* InstantiatePrefabForComponentExplicit(System::Type* componentType, UnityEngine::Object* prefab, System::Collections::Generic::List_1<Zenject::TypeValuePair>* extraArgs, Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier, Zenject::GameObjectCreationParameters* gameObjectBindInfo);
    // public System.Void BindExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFF
    template<class T>
    void BindExecutionOrder(int order) {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      THROW_UNLESS((::il2cpp_utils::RunMethod<Il2CppObject*, false>(this, ___generic__method, order)));
    }
    // public System.Void BindExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x150AC5C
    void BindExecutionOrder(System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindTickableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFF
    template<class T>
    Zenject::CopyNonLazyBinder* BindTickableExecutionOrder(int order) {
      static_assert(std::is_base_of_v<Zenject::ITickable, std::remove_pointer_t<T>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindTickableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindTickableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order)));
    }
    // public Zenject.CopyNonLazyBinder BindTickableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x150AFF0
    Zenject::CopyNonLazyBinder* BindTickableExecutionOrder(System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindInitializableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFF
    template<class T>
    Zenject::CopyNonLazyBinder* BindInitializableExecutionOrder(int order) {
      static_assert(std::is_base_of_v<Zenject::IInitializable, std::remove_pointer_t<T>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindInitializableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindInitializableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order)));
    }
    // public Zenject.CopyNonLazyBinder BindInitializableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x150B0D0
    Zenject::CopyNonLazyBinder* BindInitializableExecutionOrder(System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindDisposableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFF
    template<class T>
    Zenject::CopyNonLazyBinder* BindDisposableExecutionOrder(int order) {
      static_assert(std::is_base_of_v<System::IDisposable, std::remove_pointer_t<T>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindDisposableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindDisposableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order)));
    }
    // public Zenject.CopyNonLazyBinder BindLateDisposableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFF
    template<class T>
    Zenject::CopyNonLazyBinder* BindLateDisposableExecutionOrder(int order) {
      static_assert(std::is_base_of_v<Zenject::ILateDisposable, std::remove_pointer_t<T>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindLateDisposableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindLateDisposableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order)));
    }
    // public Zenject.CopyNonLazyBinder BindDisposableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x150B1B0
    Zenject::CopyNonLazyBinder* BindDisposableExecutionOrder(System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindLateDisposableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x150B290
    Zenject::CopyNonLazyBinder* BindLateDisposableExecutionOrder(System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindFixedTickableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFF
    template<class T>
    Zenject::CopyNonLazyBinder* BindFixedTickableExecutionOrder(int order) {
      static_assert(std::is_base_of_v<Zenject::IFixedTickable, std::remove_pointer_t<T>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindFixedTickableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFixedTickableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order)));
    }
    // public Zenject.CopyNonLazyBinder BindFixedTickableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x150B388
    Zenject::CopyNonLazyBinder* BindFixedTickableExecutionOrder(System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindLateTickableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFF
    template<class T>
    Zenject::CopyNonLazyBinder* BindLateTickableExecutionOrder(int order) {
      static_assert(std::is_base_of_v<Zenject::ILateTickable, std::remove_pointer_t<T>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindLateTickableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindLateTickableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order)));
    }
    // public Zenject.CopyNonLazyBinder BindLateTickableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x150B4A4
    Zenject::CopyNonLazyBinder* BindLateTickableExecutionOrder(System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindPoolableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFF
    template<class T>
    Zenject::CopyNonLazyBinder* BindPoolableExecutionOrder(int order) {
      static_assert(std::is_base_of_v<Zenject::IPoolable, std::remove_pointer_t<T>>);
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::BindPoolableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindPoolableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return THROW_UNLESS((::il2cpp_utils::RunMethod<Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order)));
    }
    // public Zenject.CopyNonLazyBinder BindPoolableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x150B5C0
    Zenject::CopyNonLazyBinder* BindPoolableExecutionOrder(System::Type* type, int order);
    // public System.Void .ctor()
    // Offset: 0x15019A8
    // Implemented from: System.Object
    // Base method: System.Void Object::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>()));
    }
  }; // Zenject.DiContainer
  #pragma pack(pop)
  static check_size<sizeof(DiContainer), 156 + sizeof(bool)> __Zenject_DiContainerSizeCheck;
  static_assert(sizeof(DiContainer) == 0x9D);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Zenject::DiContainer::get_Settings
// Il2CppName: get_Settings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::ZenjectSettings* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_Settings)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_Settings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::set_Settings
// Il2CppName: set_Settings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::ZenjectSettings*)>(&Zenject::DiContainer::set_Settings)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("Zenject", "ZenjectSettings")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "set_Settings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_SingletonMarkRegistry
// Il2CppName: get_SingletonMarkRegistry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::Internal::SingletonMarkRegistry* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_SingletonMarkRegistry)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_SingletonMarkRegistry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_AllProviders
// Il2CppName: get_AllProviders
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::IEnumerable_1<Zenject::IProvider*>* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_AllProviders)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_AllProviders", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_ContextTransform
// Il2CppName: get_ContextTransform
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Transform* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_ContextTransform)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_ContextTransform", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_AssertOnNewGameObjects
// Il2CppName: get_AssertOnNewGameObjects
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_AssertOnNewGameObjects)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_AssertOnNewGameObjects", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::set_AssertOnNewGameObjects
// Il2CppName: set_AssertOnNewGameObjects
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(bool)>(&Zenject::DiContainer::set_AssertOnNewGameObjects)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "set_AssertOnNewGameObjects", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_InheritedDefaultParent
// Il2CppName: get_InheritedDefaultParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Transform* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_InheritedDefaultParent)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_InheritedDefaultParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_DefaultParent
// Il2CppName: get_DefaultParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Transform* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_DefaultParent)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_DefaultParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::set_DefaultParent
// Il2CppName: set_DefaultParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(UnityEngine::Transform*)>(&Zenject::DiContainer::set_DefaultParent)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "set_DefaultParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_ParentContainers
// Il2CppName: get_ParentContainers
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<Zenject::DiContainer*> (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_ParentContainers)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_ParentContainers", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_AncestorContainers
// Il2CppName: get_AncestorContainers
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<Zenject::DiContainer*> (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_AncestorContainers)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_AncestorContainers", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_ChecksForCircularDependencies
// Il2CppName: get_ChecksForCircularDependencies
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_ChecksForCircularDependencies)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_ChecksForCircularDependencies", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_IsValidating
// Il2CppName: get_IsValidating
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_IsValidating)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_IsValidating", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_IsInstalling
// Il2CppName: get_IsInstalling
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_IsInstalling)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_IsInstalling", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::set_IsInstalling
// Il2CppName: set_IsInstalling
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(bool)>(&Zenject::DiContainer::set_IsInstalling)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "set_IsInstalling", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_AllContracts
// Il2CppName: get_AllContracts
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::IEnumerable_1<Zenject::BindingId>* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_AllContracts)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_AllContracts", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::InstallDefaultBindings
// Il2CppName: InstallDefaultBindings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::InstallDefaultBindings)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstallDefaultBindings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateLazyBinding
// Il2CppName: CreateLazyBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(Zenject::InjectContext*)>(&Zenject::DiContainer::CreateLazyBinding)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateLazyBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::QueueForValidate
// Il2CppName: QueueForValidate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::IValidatable*)>(&Zenject::DiContainer::QueueForValidate)> {
  static const MethodInfo* get() {
    static auto* validatable = &::il2cpp_utils::GetClassFromName("Zenject", "IValidatable")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "QueueForValidate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{validatable});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ShouldInheritBinding
// Il2CppName: ShouldInheritBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(Zenject::BindStatement*, Zenject::DiContainer*)>(&Zenject::DiContainer::ShouldInheritBinding)> {
  static const MethodInfo* get() {
    static auto* binding = &::il2cpp_utils::GetClassFromName("Zenject", "BindStatement")->byval_arg;
    static auto* ancestorContainer = &::il2cpp_utils::GetClassFromName("Zenject", "DiContainer")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ShouldInheritBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{binding, ancestorContainer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveRoots
// Il2CppName: ResolveRoots
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::ResolveRoots)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveRoots", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveDependencyRoots
// Il2CppName: ResolveDependencyRoots
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::ResolveDependencyRoots)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveDependencyRoots", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ValidateFullResolve
// Il2CppName: ValidateFullResolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::ValidateFullResolve)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ValidateFullResolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::FlushValidationQueue
// Il2CppName: FlushValidationQueue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::FlushValidationQueue)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "FlushValidationQueue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateSubContainer
// Il2CppName: CreateSubContainer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::DiContainer* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::CreateSubContainer)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateSubContainer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::QueueForInject
// Il2CppName: QueueForInject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*)>(&Zenject::DiContainer::QueueForInject)> {
  static const MethodInfo* get() {
    static auto* instance = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "QueueForInject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{instance});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::LazyInject
// Il2CppName: LazyInject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::CreateSubContainer
// Il2CppName: CreateSubContainer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::DiContainer* (Zenject::DiContainer::*)(bool)>(&Zenject::DiContainer::CreateSubContainer)> {
  static const MethodInfo* get() {
    static auto* isValidating = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateSubContainer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{isValidating});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::RegisterProvider
// Il2CppName: RegisterProvider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::BindingId, Zenject::BindingCondition*, Zenject::IProvider*, bool)>(&Zenject::DiContainer::RegisterProvider)> {
  static const MethodInfo* get() {
    static auto* bindingId = &::il2cpp_utils::GetClassFromName("Zenject", "BindingId")->byval_arg;
    static auto* condition = &::il2cpp_utils::GetClassFromName("Zenject", "BindingCondition")->byval_arg;
    static auto* provider = &::il2cpp_utils::GetClassFromName("Zenject", "IProvider")->byval_arg;
    static auto* nonLazy = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "RegisterProvider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bindingId, condition, provider, nonLazy});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetProviderMatches
// Il2CppName: GetProviderMatches
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::InjectContext*, System::Collections::Generic::List_1<Zenject::DiContainer::ProviderInfo*>*)>(&Zenject::DiContainer::GetProviderMatches)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "DiContainer/ProviderInfo")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetProviderMatches", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::TryGetUniqueProvider
// Il2CppName: TryGetUniqueProvider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::DiContainer::ProviderInfo* (Zenject::DiContainer::*)(Zenject::InjectContext*)>(&Zenject::DiContainer::TryGetUniqueProvider)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "TryGetUniqueProvider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::FlattenInheritanceChain
// Il2CppName: FlattenInheritanceChain
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::List_1<Zenject::DiContainer*>* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::FlattenInheritanceChain)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "FlattenInheritanceChain", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetLocalProviders
// Il2CppName: GetLocalProviders
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::BindingId, System::Collections::Generic::List_1<Zenject::DiContainer::ProviderInfo*>*)>(&Zenject::DiContainer::GetLocalProviders)> {
  static const MethodInfo* get() {
    static auto* bindingId = &::il2cpp_utils::GetClassFromName("Zenject", "BindingId")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "DiContainer/ProviderInfo")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetLocalProviders", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bindingId, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetProvidersForContract
// Il2CppName: GetProvidersForContract
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::BindingId, Zenject::InjectSources, System::Collections::Generic::List_1<Zenject::DiContainer::ProviderInfo*>*)>(&Zenject::DiContainer::GetProvidersForContract)> {
  static const MethodInfo* get() {
    static auto* bindingId = &::il2cpp_utils::GetClassFromName("Zenject", "BindingId")->byval_arg;
    static auto* sourceType = &::il2cpp_utils::GetClassFromName("Zenject", "InjectSources")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "DiContainer/ProviderInfo")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetProvidersForContract", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bindingId, sourceType, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Install
// Il2CppName: Install
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Install
// Il2CppName: Install
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveAll
// Il2CppName: ResolveAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::IList* (Zenject::DiContainer::*)(Zenject::InjectContext*)>(&Zenject::DiContainer::ResolveAll)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveAll
// Il2CppName: ResolveAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::InjectContext*, System::Collections::Generic::List_1<::Il2CppObject*>*)>(&Zenject::DiContainer::ResolveAll)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CheckForInstallWarning
// Il2CppName: CheckForInstallWarning
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::InjectContext*)>(&Zenject::DiContainer::CheckForInstallWarning)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CheckForInstallWarning", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveType
// Il2CppName: ResolveType
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveType
// Il2CppName: ResolveType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Type* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::ResolveType)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveType
// Il2CppName: ResolveType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Type* (Zenject::DiContainer::*)(Zenject::InjectContext*)>(&Zenject::DiContainer::ResolveType)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveTypeAll
// Il2CppName: ResolveTypeAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::List_1<System::Type*>* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::ResolveTypeAll)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveTypeAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveTypeAll
// Il2CppName: ResolveTypeAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::List_1<System::Type*>* (Zenject::DiContainer::*)(System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::ResolveTypeAll)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveTypeAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveTypeAll
// Il2CppName: ResolveTypeAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::List_1<System::Type*>* (Zenject::DiContainer::*)(Zenject::InjectContext*)>(&Zenject::DiContainer::ResolveTypeAll)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveTypeAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Resolve
// Il2CppName: Resolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(Zenject::BindingId)>(&Zenject::DiContainer::Resolve)> {
  static const MethodInfo* get() {
    static auto* id = &::il2cpp_utils::GetClassFromName("Zenject", "BindingId")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Resolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{id});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Resolve
// Il2CppName: Resolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(Zenject::InjectContext*)>(&Zenject::DiContainer::Resolve)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Resolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::SafeGetInstances
// Il2CppName: SafeGetInstances
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::DiContainer::ProviderInfo*, Zenject::InjectContext*, System::Collections::Generic::List_1<::Il2CppObject*>*)>(&Zenject::DiContainer::SafeGetInstances)> {
  static const MethodInfo* get() {
    static auto* providerInfo = &::il2cpp_utils::GetClassFromName("Zenject", "DiContainer/ProviderInfo")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* instances = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "SafeGetInstances", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{providerInfo, context, instances});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Decorate
// Il2CppName: Decorate
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::GetDecoratedInstances
// Il2CppName: GetDecoratedInstances
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::IProvider*, Zenject::InjectContext*, System::Collections::Generic::List_1<::Il2CppObject*>*)>(&Zenject::DiContainer::GetDecoratedInstances)> {
  static const MethodInfo* get() {
    static auto* provider = &::il2cpp_utils::GetClassFromName("Zenject", "IProvider")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetDecoratedInstances", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{provider, context, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::TryGetDecoratorProvider
// Il2CppName: TryGetDecoratorProvider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::Internal::IDecoratorProvider* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::TryGetDecoratorProvider)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "TryGetDecoratorProvider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetContainerHeirarchyDistance
// Il2CppName: GetContainerHeirarchyDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Zenject::DiContainer::*)(Zenject::DiContainer*)>(&Zenject::DiContainer::GetContainerHeirarchyDistance)> {
  static const MethodInfo* get() {
    static auto* container = &::il2cpp_utils::GetClassFromName("Zenject", "DiContainer")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetContainerHeirarchyDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{container});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetContainerHeirarchyDistance
// Il2CppName: GetContainerHeirarchyDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Nullable_1<int> (Zenject::DiContainer::*)(Zenject::DiContainer*, int)>(&Zenject::DiContainer::GetContainerHeirarchyDistance)> {
  static const MethodInfo* get() {
    static auto* container = &::il2cpp_utils::GetClassFromName("Zenject", "DiContainer")->byval_arg;
    static auto* depth = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetContainerHeirarchyDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{container, depth});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetDependencyContracts
// Il2CppName: GetDependencyContracts
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::GetDependencyContracts
// Il2CppName: GetDependencyContracts
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::IEnumerable_1<System::Type*>* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::GetDependencyContracts)> {
  static const MethodInfo* get() {
    static auto* contract = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetDependencyContracts", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contract});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateInternal
// Il2CppName: InstantiateInternal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, bool, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InstantiateInternal)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* autoInject = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateInternal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, autoInject, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectExplicit
// Il2CppName: InjectExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InjectExplicit)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectExplicit
// Il2CppName: InjectExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, System::Type*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InjectExplicit)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* injectableType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, injectableType, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CallInjectMethodsTopDown
// Il2CppName: CallInjectMethodsTopDown
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, System::Type*, Zenject::InjectTypeInfo*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::InjectContext*, ::Il2CppObject*, bool)>(&Zenject::DiContainer::CallInjectMethodsTopDown)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* injectableType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* typeInfo = &::il2cpp_utils::GetClassFromName("Zenject", "InjectTypeInfo")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* isDryRun = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CallInjectMethodsTopDown", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, injectableType, typeInfo, extraArgs, context, concreteIdentifier, isDryRun});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectMembersTopDown
// Il2CppName: InjectMembersTopDown
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, System::Type*, Zenject::InjectTypeInfo*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::InjectContext*, ::Il2CppObject*, bool)>(&Zenject::DiContainer::InjectMembersTopDown)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* injectableType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* typeInfo = &::il2cpp_utils::GetClassFromName("Zenject", "InjectTypeInfo")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* isDryRun = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectMembersTopDown", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, injectableType, typeInfo, extraArgs, context, concreteIdentifier, isDryRun});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectExplicitInternal
// Il2CppName: InjectExplicitInternal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, System::Type*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InjectExplicitInternal)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* injectableType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectExplicitInternal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, injectableType, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateAndParentPrefabResource
// Il2CppName: CreateAndParentPrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(::Il2CppString*, Zenject::GameObjectCreationParameters*, Zenject::InjectContext*, ByRef<bool>)>(&Zenject::DiContainer::CreateAndParentPrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* shouldMakeActive = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateAndParentPrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath, gameObjectBindInfo, context, shouldMakeActive});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetPrefabAsGameObject
// Il2CppName: GetPrefabAsGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(UnityEngine::Object*)>(&Zenject::DiContainer::GetPrefabAsGameObject)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetPrefabAsGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateAndParentPrefab
// Il2CppName: CreateAndParentPrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(UnityEngine::Object*, Zenject::GameObjectCreationParameters*, Zenject::InjectContext*, ByRef<bool>)>(&Zenject::DiContainer::CreateAndParentPrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* shouldMakeActive = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateAndParentPrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab, gameObjectBindInfo, context, shouldMakeActive});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateEmptyGameObject
// Il2CppName: CreateEmptyGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(::Il2CppString*)>(&Zenject::DiContainer::CreateEmptyGameObject)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateEmptyGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateEmptyGameObject
// Il2CppName: CreateEmptyGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(Zenject::GameObjectCreationParameters*, Zenject::InjectContext*)>(&Zenject::DiContainer::CreateEmptyGameObject)> {
  static const MethodInfo* get() {
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateEmptyGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObjectBindInfo, context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetTransformGroup
// Il2CppName: GetTransformGroup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Transform* (Zenject::DiContainer::*)(Zenject::GameObjectCreationParameters*, Zenject::InjectContext*)>(&Zenject::DiContainer::GetTransformGroup)> {
  static const MethodInfo* get() {
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetTransformGroup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObjectBindInfo, context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateTransformGroup
// Il2CppName: CreateTransformGroup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(::Il2CppString*)>(&Zenject::DiContainer::CreateTransformGroup)> {
  static const MethodInfo* get() {
    static auto* groupName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateTransformGroup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{groupName});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Instantiate
// Il2CppName: Instantiate
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Instantiate
// Il2CppName: Instantiate
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Instantiate
// Il2CppName: Instantiate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::Instantiate)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Instantiate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Instantiate
// Il2CppName: Instantiate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::Instantiate)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Instantiate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponent
// Il2CppName: InstantiateComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponent
// Il2CppName: InstantiateComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponent
// Il2CppName: InstantiateComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Component* (Zenject::DiContainer::*)(System::Type*, UnityEngine::GameObject*)>(&Zenject::DiContainer::InstantiateComponent)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, gameObject});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponent
// Il2CppName: InstantiateComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Component* (Zenject::DiContainer::*)(System::Type*, UnityEngine::GameObject*, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InstantiateComponent)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, gameObject, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentOnNewGameObject
// Il2CppName: InstantiateComponentOnNewGameObject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentOnNewGameObject
// Il2CppName: InstantiateComponentOnNewGameObject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentOnNewGameObject
// Il2CppName: InstantiateComponentOnNewGameObject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentOnNewGameObject
// Il2CppName: InstantiateComponentOnNewGameObject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefab
// Il2CppName: InstantiatePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(UnityEngine::Object*)>(&Zenject::DiContainer::InstantiatePrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefab
// Il2CppName: InstantiatePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(UnityEngine::Object*, UnityEngine::Transform*)>(&Zenject::DiContainer::InstantiatePrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab, parentTransform});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefab
// Il2CppName: InstantiatePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(UnityEngine::Object*, UnityEngine::Vector3, UnityEngine::Quaternion, UnityEngine::Transform*)>(&Zenject::DiContainer::InstantiatePrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* rotation = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab, position, rotation, parentTransform});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefab
// Il2CppName: InstantiatePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(UnityEngine::Object*, Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab, gameObjectBindInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResource
// Il2CppName: InstantiatePrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(::Il2CppString*)>(&Zenject::DiContainer::InstantiatePrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResource
// Il2CppName: InstantiatePrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(::Il2CppString*, UnityEngine::Transform*)>(&Zenject::DiContainer::InstantiatePrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath, parentTransform});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResource
// Il2CppName: InstantiatePrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(::Il2CppString*, UnityEngine::Vector3, UnityEngine::Quaternion, UnityEngine::Transform*)>(&Zenject::DiContainer::InstantiatePrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* rotation = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath, position, rotation, parentTransform});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResource
// Il2CppName: InstantiatePrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::GameObject* (Zenject::DiContainer::*)(::Il2CppString*, Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* creationInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath, creationInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, UnityEngine::Object*, UnityEngine::Transform*, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InstantiatePrefabForComponent)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, prefab, parentTransform, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, UnityEngine::Object*, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*, Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabForComponent)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    static auto* creationInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, prefab, extraArgs, creationInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, ::Il2CppString*, UnityEngine::Transform*, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InstantiatePrefabResourceForComponent)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, resourcePath, parentTransform, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResource
// Il2CppName: InstantiateScriptableObjectResource
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResource
// Il2CppName: InstantiateScriptableObjectResource
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResource
// Il2CppName: InstantiateScriptableObjectResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, ::Il2CppString*)>(&Zenject::DiContainer::InstantiateScriptableObjectResource)> {
  static const MethodInfo* get() {
    static auto* scriptableObjectType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateScriptableObjectResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scriptableObjectType, resourcePath});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResource
// Il2CppName: InstantiateScriptableObjectResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, ::Il2CppString*, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InstantiateScriptableObjectResource)> {
  static const MethodInfo* get() {
    static auto* scriptableObjectType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateScriptableObjectResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scriptableObjectType, resourcePath, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObject
// Il2CppName: InjectGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(UnityEngine::GameObject*)>(&Zenject::DiContainer::InjectGameObject)> {
  static const MethodInfo* get() {
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObject});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObjectForComponent
// Il2CppName: InjectGameObjectForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObjectForComponent
// Il2CppName: InjectGameObjectForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObjectForComponent
// Il2CppName: InjectGameObjectForComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(UnityEngine::GameObject*, System::Type*, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InjectGameObjectForComponent)> {
  static const MethodInfo* get() {
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectGameObjectForComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObject, componentType, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObjectForComponentExplicit
// Il2CppName: InjectGameObjectForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Component* (Zenject::DiContainer::*)(UnityEngine::GameObject*, System::Type*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InjectGameObjectForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectGameObjectForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObject, componentType, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Inject
// Il2CppName: Inject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*)>(&Zenject::DiContainer::Inject)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Inject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Inject
// Il2CppName: Inject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::Inject)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Inject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Resolve
// Il2CppName: Resolve
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Resolve
// Il2CppName: Resolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::Resolve)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Resolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveId
// Il2CppName: ResolveId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveId
// Il2CppName: ResolveId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::ResolveId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::TryResolve
// Il2CppName: TryResolve
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::TryResolve
// Il2CppName: TryResolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::TryResolve)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "TryResolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::TryResolveId
// Il2CppName: TryResolveId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::TryResolveId
// Il2CppName: TryResolveId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::TryResolveId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "TryResolveId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveAll
// Il2CppName: ResolveAll
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveAll
// Il2CppName: ResolveAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::IList* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::ResolveAll)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveIdAll
// Il2CppName: ResolveIdAll
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveIdAll
// Il2CppName: ResolveIdAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::IList* (Zenject::DiContainer::*)(System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::ResolveIdAll)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveIdAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindAll
// Il2CppName: UnbindAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::UnbindAll)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "UnbindAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Unbind
// Il2CppName: Unbind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Unbind
// Il2CppName: Unbind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::Unbind)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Unbind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindId
// Il2CppName: UnbindId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindId
// Il2CppName: UnbindId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::UnbindId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "UnbindId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindInterfacesTo
// Il2CppName: UnbindInterfacesTo
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindInterfacesTo
// Il2CppName: UnbindInterfacesTo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::UnbindInterfacesTo)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "UnbindInterfacesTo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Unbind
// Il2CppName: Unbind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Unbind
// Il2CppName: Unbind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(System::Type*, System::Type*)>(&Zenject::DiContainer::Unbind)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Unbind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, concreteType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindId
// Il2CppName: UnbindId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindId
// Il2CppName: UnbindId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(System::Type*, System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::UnbindId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "UnbindId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, concreteType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::HasBinding
// Il2CppName: HasBinding
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::HasBinding
// Il2CppName: HasBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::HasBinding)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "HasBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::HasBindingId
// Il2CppName: HasBindingId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::HasBindingId
// Il2CppName: HasBindingId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::HasBindingId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "HasBindingId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::HasBindingId
// Il2CppName: HasBindingId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(System::Type*, ::Il2CppObject*, Zenject::InjectSources)>(&Zenject::DiContainer::HasBindingId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* sourceType = &::il2cpp_utils::GetClassFromName("Zenject", "InjectSources")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "HasBindingId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier, sourceType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::HasBinding
// Il2CppName: HasBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(Zenject::InjectContext*)>(&Zenject::DiContainer::HasBinding)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "HasBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::FlushBindings
// Il2CppName: FlushBindings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::FlushBindings)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "FlushBindings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::FinalizeBinding
// Il2CppName: FinalizeBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(Zenject::BindStatement*)>(&Zenject::DiContainer::FinalizeBinding)> {
  static const MethodInfo* get() {
    static auto* binding = &::il2cpp_utils::GetClassFromName("Zenject", "BindStatement")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "FinalizeBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{binding});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::StartBinding
// Il2CppName: StartBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::BindStatement* (Zenject::DiContainer::*)(bool)>(&Zenject::DiContainer::StartBinding)> {
  static const MethodInfo* get() {
    static auto* flush = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "StartBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{flush});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Rebind
// Il2CppName: Rebind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::RebindId
// Il2CppName: RebindId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Rebind
// Il2CppName: Rebind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::ConcreteBinderNonGeneric* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::Rebind)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Rebind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::RebindId
// Il2CppName: RebindId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::ConcreteBinderNonGeneric* (Zenject::DiContainer::*)(System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::RebindId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "RebindId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindNoFlush
// Il2CppName: BindNoFlush
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::ConcreteIdBinderNonGeneric* (Zenject::DiContainer::*)(::ArrayW<System::Type*>)>(&Zenject::DiContainer::Bind)> {
  static const MethodInfo* get() {
    static auto* contractTypes = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Bind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractTypes});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::ConcreteIdBinderNonGeneric* (Zenject::DiContainer::*)(System::Collections::Generic::IEnumerable_1<System::Type*>*)>(&Zenject::DiContainer::Bind)> {
  static const MethodInfo* get() {
    static auto* contractTypes = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Type")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Bind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractTypes});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInternal
// Il2CppName: BindInternal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::ConcreteIdBinderNonGeneric* (Zenject::DiContainer::*)(Zenject::BindInfo*, Zenject::BindStatement*)>(&Zenject::DiContainer::BindInternal)> {
  static const MethodInfo* get() {
    static auto* bindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "BindInfo")->byval_arg;
    static auto* bindingFinalizer = &::il2cpp_utils::GetClassFromName("Zenject", "BindStatement")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInternal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bindInfo, bindingFinalizer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::ConcreteIdBinderNonGeneric* (Zenject::DiContainer::*)(System::Action_1<Zenject::ConventionSelectTypesBinder*>*)>(&Zenject::DiContainer::Bind)> {
  static const MethodInfo* get() {
    static auto* generator = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "ConventionSelectTypesBinder")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Bind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{generator});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInterfacesTo
// Il2CppName: BindInterfacesTo
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindInterfacesTo
// Il2CppName: BindInterfacesTo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::FromBinderNonGeneric* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::BindInterfacesTo)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInterfacesTo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInterfacesAndSelfTo
// Il2CppName: BindInterfacesAndSelfTo
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindInterfacesAndSelfTo
// Il2CppName: BindInterfacesAndSelfTo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::FromBinderNonGeneric* (Zenject::DiContainer::*)(System::Type*)>(&Zenject::DiContainer::BindInterfacesAndSelfTo)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInterfacesAndSelfTo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInstance
// Il2CppName: BindInstance
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindInstances
// Il2CppName: BindInstances
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::ArrayW<::Il2CppObject*>)>(&Zenject::DiContainer::BindInstances)> {
  static const MethodInfo* get() {
    static auto* instances = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Object"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInstances", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{instances});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPool
// Il2CppName: BindMemoryPool
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPool
// Il2CppName: BindMemoryPool
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPoolCustomInterface
// Il2CppName: BindMemoryPoolCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPoolCustomInterfaceNoFlush
// Il2CppName: BindMemoryPoolCustomInterfaceNoFlush
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPoolCustomInterfaceInternal
// Il2CppName: BindMemoryPoolCustomInterfaceInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateExplicit
// Il2CppName: InstantiateExplicit
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateExplicit
// Il2CppName: InstantiateExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InstantiateExplicit)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateExplicit
// Il2CppName: InstantiateExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, bool, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InstantiateExplicit)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* autoInject = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, autoInject, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentExplicit
// Il2CppName: InstantiateComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Component* (Zenject::DiContainer::*)(System::Type*, UnityEngine::GameObject*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InstantiateComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, gameObject, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResourceExplicit
// Il2CppName: InstantiateScriptableObjectResourceExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, ::Il2CppString*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InstantiateScriptableObjectResourceExplicit)> {
  static const MethodInfo* get() {
    static auto* scriptableObjectType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateScriptableObjectResourceExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scriptableObjectType, resourcePath, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponentExplicit
// Il2CppName: InstantiatePrefabResourceForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, ::Il2CppString*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabResourceForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* creationInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResourceForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, resourcePath, extraArgs, creationInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponentExplicit
// Il2CppName: InstantiatePrefabResourceForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, ::Il2CppString*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::InjectContext*, ::Il2CppObject*, Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabResourceForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* creationInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResourceForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, resourcePath, extraArgs, context, concreteIdentifier, creationInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponentExplicit
// Il2CppName: InstantiatePrefabForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, UnityEngine::Object*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InstantiatePrefabForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, prefab, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponentExplicit
// Il2CppName: InstantiatePrefabForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, UnityEngine::Object*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, prefab, extraArgs, gameObjectBindInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponentExplicit
// Il2CppName: InstantiatePrefabForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(System::Type*, UnityEngine::Object*, System::Collections::Generic::List_1<Zenject::TypeValuePair>*, Zenject::InjectContext*, ::Il2CppObject*, Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, prefab, extraArgs, context, concreteIdentifier, gameObjectBindInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindExecutionOrder
// Il2CppName: BindExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindExecutionOrder
// Il2CppName: BindExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(System::Type*, int)>(&Zenject::DiContainer::BindExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindTickableExecutionOrder
// Il2CppName: BindTickableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindTickableExecutionOrder
// Il2CppName: BindTickableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(System::Type*, int)>(&Zenject::DiContainer::BindTickableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindTickableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInitializableExecutionOrder
// Il2CppName: BindInitializableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindInitializableExecutionOrder
// Il2CppName: BindInitializableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(System::Type*, int)>(&Zenject::DiContainer::BindInitializableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInitializableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindDisposableExecutionOrder
// Il2CppName: BindDisposableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindLateDisposableExecutionOrder
// Il2CppName: BindLateDisposableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindDisposableExecutionOrder
// Il2CppName: BindDisposableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(System::Type*, int)>(&Zenject::DiContainer::BindDisposableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindDisposableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindLateDisposableExecutionOrder
// Il2CppName: BindLateDisposableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(System::Type*, int)>(&Zenject::DiContainer::BindLateDisposableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindLateDisposableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindFixedTickableExecutionOrder
// Il2CppName: BindFixedTickableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFixedTickableExecutionOrder
// Il2CppName: BindFixedTickableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(System::Type*, int)>(&Zenject::DiContainer::BindFixedTickableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindFixedTickableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindLateTickableExecutionOrder
// Il2CppName: BindLateTickableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindLateTickableExecutionOrder
// Il2CppName: BindLateTickableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(System::Type*, int)>(&Zenject::DiContainer::BindLateTickableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindLateTickableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindPoolableExecutionOrder
// Il2CppName: BindPoolableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindPoolableExecutionOrder
// Il2CppName: BindPoolableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(System::Type*, int)>(&Zenject::DiContainer::BindPoolableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindPoolableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
