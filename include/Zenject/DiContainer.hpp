// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include <initializer_list>
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Zenject.IInstantiator
#include "Zenject/IInstantiator.hpp"
// Including type: Zenject.BindingId
#include "Zenject/BindingId.hpp"
// Including type: Zenject.TypeValuePair
#include "Zenject/TypeValuePair.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Zenject
namespace Zenject {
  // Forward declaring type: LazyInstanceInjector
  class LazyInstanceInjector;
  // Forward declaring type: BindStatement
  class BindStatement;
  // Forward declaring type: IValidatable
  class IValidatable;
  // Forward declaring type: ZenjectSettings
  class ZenjectSettings;
  // Forward declaring type: IProvider
  class IProvider;
  // Forward declaring type: InjectContext
  class InjectContext;
  // Forward declaring type: BindingCondition
  class BindingCondition;
  // Forward declaring type: InjectSources
  struct InjectSources;
  // Forward declaring type: Installer
  class Installer;
  // Forward declaring type: DecoratorToChoiceFromBinder`1<TContract>
  template<typename TContract>
  class DecoratorToChoiceFromBinder_1;
  // Forward declaring type: InjectTypeInfo
  class InjectTypeInfo;
  // Forward declaring type: GameObjectCreationParameters
  class GameObjectCreationParameters;
  // Forward declaring type: ConcreteBinderGeneric`1<TContract>
  template<typename TContract>
  class ConcreteBinderGeneric_1;
  // Forward declaring type: ConcreteBinderNonGeneric
  class ConcreteBinderNonGeneric;
  // Forward declaring type: ConcreteIdBinderGeneric`1<TContract>
  template<typename TContract>
  class ConcreteIdBinderGeneric_1;
  // Forward declaring type: ConcreteIdBinderNonGeneric
  class ConcreteIdBinderNonGeneric;
  // Forward declaring type: BindInfo
  class BindInfo;
  // Forward declaring type: ConventionSelectTypesBinder
  class ConventionSelectTypesBinder;
  // Forward declaring type: FromBinderNonGeneric
  class FromBinderNonGeneric;
  // Forward declaring type: IdScopeConcreteIdArgConditionCopyNonLazyBinder
  class IdScopeConcreteIdArgConditionCopyNonLazyBinder;
  // Forward declaring type: IFactory
  class IFactory;
  // Forward declaring type: FactoryToChoiceIdBinder`1<TContract>
  template<typename TContract>
  class FactoryToChoiceIdBinder_1;
  // Forward declaring type: PlaceholderFactory`1<TValue>
  template<typename TValue>
  class PlaceholderFactory_1;
  // Forward declaring type: MemoryPoolIdInitialSizeMaxSizeBinder`1<TContract>
  template<typename TContract>
  class MemoryPoolIdInitialSizeMaxSizeBinder_1;
  // Forward declaring type: IMemoryPool
  class IMemoryPool;
  // Forward declaring type: FactoryToChoiceIdBinder`2<TParam1, TContract>
  template<typename TParam1, typename TContract>
  class FactoryToChoiceIdBinder_2;
  // Forward declaring type: PlaceholderFactory`2<TParam1, TValue>
  template<typename TParam1, typename TValue>
  class PlaceholderFactory_2;
  // Forward declaring type: FactoryToChoiceIdBinder`3<TParam1, TParam2, TContract>
  template<typename TParam1, typename TParam2, typename TContract>
  class FactoryToChoiceIdBinder_3;
  // Forward declaring type: PlaceholderFactory`3<TParam1, TParam2, TValue>
  template<typename TParam1, typename TParam2, typename TValue>
  class PlaceholderFactory_3;
  // Forward declaring type: FactoryToChoiceIdBinder`4<TParam1, TParam2, TParam3, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TContract>
  class FactoryToChoiceIdBinder_4;
  // Forward declaring type: PlaceholderFactory`4<TParam1, TParam2, TParam3, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TValue>
  class PlaceholderFactory_4;
  // Forward declaring type: FactoryToChoiceIdBinder`5<TParam1, TParam2, TParam3, TParam4, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TContract>
  class FactoryToChoiceIdBinder_5;
  // Forward declaring type: PlaceholderFactory`5<TParam1, TParam2, TParam3, TParam4, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TValue>
  class PlaceholderFactory_5;
  // Forward declaring type: FactoryToChoiceIdBinder`6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TContract>
  class FactoryToChoiceIdBinder_6;
  // Forward declaring type: PlaceholderFactory`6<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TValue>
  class PlaceholderFactory_6;
  // Forward declaring type: FactoryToChoiceIdBinder`7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TParam6, typename TContract>
  class FactoryToChoiceIdBinder_7;
  // Forward declaring type: PlaceholderFactory`7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TParam6, typename TValue>
  class PlaceholderFactory_7;
  // Forward declaring type: FactoryToChoiceIdBinder`11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TParam6, typename TParam7, typename TParam8, typename TParam9, typename TParam10, typename TContract>
  class FactoryToChoiceIdBinder_11;
  // Forward declaring type: PlaceholderFactory`11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TValue>
  template<typename TParam1, typename TParam2, typename TParam3, typename TParam4, typename TParam5, typename TParam6, typename TParam7, typename TParam8, typename TParam9, typename TParam10, typename TValue>
  class PlaceholderFactory_11;
  // Forward declaring type: ITickable
  class ITickable;
  // Forward declaring type: CopyNonLazyBinder
  class CopyNonLazyBinder;
  // Forward declaring type: IInitializable
  class IInitializable;
  // Forward declaring type: ILateDisposable
  class ILateDisposable;
  // Forward declaring type: IFixedTickable
  class IFixedTickable;
  // Forward declaring type: ILateTickable
  class ILateTickable;
  // Forward declaring type: IPoolable
  class IPoolable;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: HashSet`1<T>
  template<typename T>
  class HashSet_1;
  // Forward declaring type: Queue`1<T>
  template<typename T>
  class Queue_1;
  // Forward declaring type: IEnumerable`1<T>
  template<typename T>
  class IEnumerable_1;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Type
  class Type;
  // Forward declaring type: Nullable`1<T>
  template<typename T>
  struct Nullable_1;
  // Forward declaring type: Action`1<T>
  template<typename T>
  class Action_1;
  // Forward declaring type: IDisposable
  class IDisposable;
}
// Forward declaring namespace: Zenject::Internal
namespace Zenject::Internal {
  // Forward declaring type: IDecoratorProvider
  class IDecoratorProvider;
  // Forward declaring type: LookupId
  class LookupId;
  // Forward declaring type: SingletonMarkRegistry
  class SingletonMarkRegistry;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Object
  class Object;
  // Forward declaring type: Component
  class Component;
  // Forward declaring type: ScriptableObject
  class ScriptableObject;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IList
  class IList;
}
// Completed forward declares
// Type namespace: Zenject
namespace Zenject {
  // Forward declaring type: DiContainer
  class DiContainer;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Zenject::DiContainer);
DEFINE_IL2CPP_ARG_TYPE(::Zenject::DiContainer*, "Zenject", "DiContainer");
// Type namespace: Zenject
namespace Zenject {
  // Size: 0x9D
  #pragma pack(push, 1)
  // Autogenerated type: Zenject.DiContainer
  // [TokenAttribute] Offset: FFFFFFFF
  // [NoReflectionBakingAttribute] Offset: FFFFFFFF
  class DiContainer : public ::Il2CppObject/*, public ::Zenject::IInstantiator*/ {
    public:
    // Nested type: ::Zenject::DiContainer::ProviderInfo
    class ProviderInfo;
    // Nested type: ::Zenject::DiContainer::$$c
    class $$c;
    // Nested type: ::Zenject::DiContainer::$$c__DisplayClass86_0
    class $$c__DisplayClass86_0;
    // Nested type: ::Zenject::DiContainer::$GetDependencyContracts$d__96
    class $GetDependencyContracts$d__96;
    // Nested type: ::Zenject::DiContainer::$$c__DisplayClass178_0
    class $$c__DisplayClass178_0;
    // Nested type: ::Zenject::DiContainer::$$c__DisplayClass203_0_1<TContract>
    template<typename TContract>
    class $$c__DisplayClass203_0_1;
    public:
    // private readonly System.Collections.Generic.Dictionary`2<System.Type,Zenject.Internal.IDecoratorProvider> _decorators
    // Size: 0x8
    // Offset: 0x10
    ::System::Collections::Generic::Dictionary_2<::System::Type*, ::Zenject::Internal::IDecoratorProvider*>* decorators;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::System::Type*, ::Zenject::Internal::IDecoratorProvider*>*) == 0x8);
    // private readonly System.Collections.Generic.Dictionary`2<Zenject.BindingId,System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo>> _providers
    // Size: 0x8
    // Offset: 0x18
    ::System::Collections::Generic::Dictionary_2<::Zenject::BindingId, ::System::Collections::Generic::List_1<::Zenject::DiContainer::ProviderInfo*>*>* providers;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::Zenject::BindingId, ::System::Collections::Generic::List_1<::Zenject::DiContainer::ProviderInfo*>*>*) == 0x8);
    // private readonly Zenject.DiContainer[][] _containerLookups
    // Size: 0x8
    // Offset: 0x20
    ::ArrayW<::ArrayW<::Zenject::DiContainer*>> containerLookups;
    // Field size check
    static_assert(sizeof(::ArrayW<::ArrayW<::Zenject::DiContainer*>>) == 0x8);
    // private readonly System.Collections.Generic.HashSet`1<Zenject.Internal.LookupId> _resolvesInProgress
    // Size: 0x8
    // Offset: 0x28
    ::System::Collections::Generic::HashSet_1<::Zenject::Internal::LookupId*>* resolvesInProgress;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::HashSet_1<::Zenject::Internal::LookupId*>*) == 0x8);
    // private readonly System.Collections.Generic.HashSet`1<Zenject.Internal.LookupId> _resolvesTwiceInProgress
    // Size: 0x8
    // Offset: 0x30
    ::System::Collections::Generic::HashSet_1<::Zenject::Internal::LookupId*>* resolvesTwiceInProgress;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::HashSet_1<::Zenject::Internal::LookupId*>*) == 0x8);
    // private readonly Zenject.LazyInstanceInjector _lazyInjector
    // Size: 0x8
    // Offset: 0x38
    ::Zenject::LazyInstanceInjector* lazyInjector;
    // Field size check
    static_assert(sizeof(::Zenject::LazyInstanceInjector*) == 0x8);
    // private readonly Zenject.Internal.SingletonMarkRegistry _singletonMarkRegistry
    // Size: 0x8
    // Offset: 0x40
    ::Zenject::Internal::SingletonMarkRegistry* singletonMarkRegistry;
    // Field size check
    static_assert(sizeof(::Zenject::Internal::SingletonMarkRegistry*) == 0x8);
    // private readonly System.Collections.Generic.Queue`1<Zenject.BindStatement> _currentBindings
    // Size: 0x8
    // Offset: 0x48
    ::System::Collections::Generic::Queue_1<::Zenject::BindStatement*>* currentBindings;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Queue_1<::Zenject::BindStatement*>*) == 0x8);
    // private readonly System.Collections.Generic.List`1<Zenject.BindStatement> _childBindings
    // Size: 0x8
    // Offset: 0x50
    ::System::Collections::Generic::List_1<::Zenject::BindStatement*>* childBindings;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::Zenject::BindStatement*>*) == 0x8);
    // private readonly System.Collections.Generic.HashSet`1<System.Type> _validatedTypes
    // Size: 0x8
    // Offset: 0x58
    ::System::Collections::Generic::HashSet_1<::System::Type*>* validatedTypes;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::HashSet_1<::System::Type*>*) == 0x8);
    // private readonly System.Collections.Generic.List`1<Zenject.IValidatable> _validationQueue
    // Size: 0x8
    // Offset: 0x60
    ::System::Collections::Generic::List_1<::Zenject::IValidatable*>* validationQueue;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::Zenject::IValidatable*>*) == 0x8);
    // private UnityEngine.Transform _contextTransform
    // Size: 0x8
    // Offset: 0x68
    ::UnityEngine::Transform* contextTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private System.Boolean _hasLookedUpContextTransform
    // Size: 0x1
    // Offset: 0x70
    bool hasLookedUpContextTransform;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: hasLookedUpContextTransform and: inheritedDefaultParent
    char __padding12[0x7] = {};
    // private UnityEngine.Transform _inheritedDefaultParent
    // Size: 0x8
    // Offset: 0x78
    ::UnityEngine::Transform* inheritedDefaultParent;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private UnityEngine.Transform _explicitDefaultParent
    // Size: 0x8
    // Offset: 0x80
    ::UnityEngine::Transform* explicitDefaultParent;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private System.Boolean _hasExplicitDefaultParent
    // Size: 0x1
    // Offset: 0x88
    bool hasExplicitDefaultParent;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: hasExplicitDefaultParent and: settings
    char __padding15[0x7] = {};
    // private Zenject.ZenjectSettings _settings
    // Size: 0x8
    // Offset: 0x90
    ::Zenject::ZenjectSettings* settings;
    // Field size check
    static_assert(sizeof(::Zenject::ZenjectSettings*) == 0x8);
    // private System.Boolean _hasResolvedRoots
    // Size: 0x1
    // Offset: 0x98
    bool hasResolvedRoots;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _isFinalizingBinding
    // Size: 0x1
    // Offset: 0x99
    bool isFinalizingBinding;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _isValidating
    // Size: 0x1
    // Offset: 0x9A
    bool isValidating;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _isInstalling
    // Size: 0x1
    // Offset: 0x9B
    bool isInstalling;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean <AssertOnNewGameObjects>k__BackingField
    // Size: 0x1
    // Offset: 0x9C
    bool AssertOnNewGameObjects;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Creating interface conversion operator: operator ::Zenject::IInstantiator
    operator ::Zenject::IInstantiator() noexcept {
      return *reinterpret_cast<::Zenject::IInstantiator*>(this);
    }
    // Creating interface conversion operator: i_IInstantiator
    inline ::Zenject::IInstantiator* i_IInstantiator() noexcept {
      return reinterpret_cast<::Zenject::IInstantiator*>(this);
    }
    // Get instance field reference: private readonly System.Collections.Generic.Dictionary`2<System.Type,Zenject.Internal.IDecoratorProvider> _decorators
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::System::Type*, ::Zenject::Internal::IDecoratorProvider*>*& dyn__decorators();
    // Get instance field reference: private readonly System.Collections.Generic.Dictionary`2<Zenject.BindingId,System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo>> _providers
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::Zenject::BindingId, ::System::Collections::Generic::List_1<::Zenject::DiContainer::ProviderInfo*>*>*& dyn__providers();
    // Get instance field reference: private readonly Zenject.DiContainer[][] _containerLookups
    [[deprecated("Use field access instead!")]] ::ArrayW<::ArrayW<::Zenject::DiContainer*>>& dyn__containerLookups();
    // Get instance field reference: private readonly System.Collections.Generic.HashSet`1<Zenject.Internal.LookupId> _resolvesInProgress
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::HashSet_1<::Zenject::Internal::LookupId*>*& dyn__resolvesInProgress();
    // Get instance field reference: private readonly System.Collections.Generic.HashSet`1<Zenject.Internal.LookupId> _resolvesTwiceInProgress
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::HashSet_1<::Zenject::Internal::LookupId*>*& dyn__resolvesTwiceInProgress();
    // Get instance field reference: private readonly Zenject.LazyInstanceInjector _lazyInjector
    [[deprecated("Use field access instead!")]] ::Zenject::LazyInstanceInjector*& dyn__lazyInjector();
    // Get instance field reference: private readonly Zenject.Internal.SingletonMarkRegistry _singletonMarkRegistry
    [[deprecated("Use field access instead!")]] ::Zenject::Internal::SingletonMarkRegistry*& dyn__singletonMarkRegistry();
    // Get instance field reference: private readonly System.Collections.Generic.Queue`1<Zenject.BindStatement> _currentBindings
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Queue_1<::Zenject::BindStatement*>*& dyn__currentBindings();
    // Get instance field reference: private readonly System.Collections.Generic.List`1<Zenject.BindStatement> _childBindings
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::Zenject::BindStatement*>*& dyn__childBindings();
    // Get instance field reference: private readonly System.Collections.Generic.HashSet`1<System.Type> _validatedTypes
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::HashSet_1<::System::Type*>*& dyn__validatedTypes();
    // Get instance field reference: private readonly System.Collections.Generic.List`1<Zenject.IValidatable> _validationQueue
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::Zenject::IValidatable*>*& dyn__validationQueue();
    // Get instance field reference: private UnityEngine.Transform _contextTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn__contextTransform();
    // Get instance field reference: private System.Boolean _hasLookedUpContextTransform
    [[deprecated("Use field access instead!")]] bool& dyn__hasLookedUpContextTransform();
    // Get instance field reference: private UnityEngine.Transform _inheritedDefaultParent
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn__inheritedDefaultParent();
    // Get instance field reference: private UnityEngine.Transform _explicitDefaultParent
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn__explicitDefaultParent();
    // Get instance field reference: private System.Boolean _hasExplicitDefaultParent
    [[deprecated("Use field access instead!")]] bool& dyn__hasExplicitDefaultParent();
    // Get instance field reference: private Zenject.ZenjectSettings _settings
    [[deprecated("Use field access instead!")]] ::Zenject::ZenjectSettings*& dyn__settings();
    // Get instance field reference: private System.Boolean _hasResolvedRoots
    [[deprecated("Use field access instead!")]] bool& dyn__hasResolvedRoots();
    // Get instance field reference: private System.Boolean _isFinalizingBinding
    [[deprecated("Use field access instead!")]] bool& dyn__isFinalizingBinding();
    // Get instance field reference: private System.Boolean _isValidating
    [[deprecated("Use field access instead!")]] bool& dyn__isValidating();
    // Get instance field reference: private System.Boolean _isInstalling
    [[deprecated("Use field access instead!")]] bool& dyn__isInstalling();
    // Get instance field reference: private System.Boolean <AssertOnNewGameObjects>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$AssertOnNewGameObjects$k__BackingField();
    // public Zenject.ZenjectSettings get_Settings()
    // Offset: 0x17C617C
    ::Zenject::ZenjectSettings* get_Settings();
    // public System.Void set_Settings(Zenject.ZenjectSettings value)
    // Offset: 0x17C6184
    void set_Settings(::Zenject::ZenjectSettings* value);
    // Zenject.Internal.SingletonMarkRegistry get_SingletonMarkRegistry()
    // Offset: 0x17C6200
    ::Zenject::Internal::SingletonMarkRegistry* get_SingletonMarkRegistry();
    // public System.Collections.Generic.IEnumerable`1<Zenject.IProvider> get_AllProviders()
    // Offset: 0x17C6208
    ::System::Collections::Generic::IEnumerable_1<::Zenject::IProvider*>* get_AllProviders();
    // private UnityEngine.Transform get_ContextTransform()
    // Offset: 0x17C674C
    ::UnityEngine::Transform* get_ContextTransform();
    // public System.Boolean get_AssertOnNewGameObjects()
    // Offset: 0x17C6808
    bool get_AssertOnNewGameObjects();
    // public System.Void set_AssertOnNewGameObjects(System.Boolean value)
    // Offset: 0x17C6810
    void set_AssertOnNewGameObjects(bool value);
    // public UnityEngine.Transform get_InheritedDefaultParent()
    // Offset: 0x17C681C
    ::UnityEngine::Transform* get_InheritedDefaultParent();
    // public UnityEngine.Transform get_DefaultParent()
    // Offset: 0x17C6824
    ::UnityEngine::Transform* get_DefaultParent();
    // public System.Void set_DefaultParent(UnityEngine.Transform value)
    // Offset: 0x17C4A94
    void set_DefaultParent(::UnityEngine::Transform* value);
    // public Zenject.DiContainer[] get_ParentContainers()
    // Offset: 0x17C6714
    ::ArrayW<::Zenject::DiContainer*> get_ParentContainers();
    // public Zenject.DiContainer[] get_AncestorContainers()
    // Offset: 0x17C682C
    ::ArrayW<::Zenject::DiContainer*> get_AncestorContainers();
    // public System.Boolean get_ChecksForCircularDependencies()
    // Offset: 0x17C6864
    bool get_ChecksForCircularDependencies();
    // public System.Boolean get_IsValidating()
    // Offset: 0x17C686C
    bool get_IsValidating();
    // public System.Boolean get_IsInstalling()
    // Offset: 0x17C6874
    bool get_IsInstalling();
    // public System.Void set_IsInstalling(System.Boolean value)
    // Offset: 0x17C687C
    void set_IsInstalling(bool value);
    // public System.Collections.Generic.IEnumerable`1<Zenject.BindingId> get_AllContracts()
    // Offset: 0x17C6888
    ::System::Collections::Generic::IEnumerable_1<::Zenject::BindingId>* get_AllContracts();
    // public System.Void .ctor(System.Collections.Generic.IEnumerable`1<Zenject.DiContainer> parentContainersEnumerable, System.Boolean isValidating)
    // Offset: 0x17C50E4
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(::System::Collections::Generic::IEnumerable_1<::Zenject::DiContainer*>* parentContainersEnumerable, bool isValidating) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(parentContainersEnumerable, isValidating)));
    }
    // public System.Void .ctor(System.Boolean isValidating)
    // Offset: 0x17C5E4C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(bool isValidating) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(isValidating)));
    }
    // public System.Void .ctor()
    // Offset: 0x17C5F2C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>()));
    }
    // public System.Void .ctor(Zenject.DiContainer parentContainer, System.Boolean isValidating)
    // Offset: 0x17C6008
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(::Zenject::DiContainer* parentContainer, bool isValidating) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(parentContainer, isValidating)));
    }
    // public System.Void .ctor(Zenject.DiContainer parentContainer)
    // Offset: 0x17C60C0
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(::Zenject::DiContainer* parentContainer) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(parentContainer)));
    }
    // public System.Void .ctor(System.Collections.Generic.IEnumerable`1<Zenject.DiContainer> parentContainers)
    // Offset: 0x17C6174
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static DiContainer* New_ctor(::System::Collections::Generic::IEnumerable_1<::Zenject::DiContainer*>* parentContainers) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<DiContainer*, creationType>(parentContainers)));
    }
    // private System.Void InstallDefaultBindings()
    // Offset: 0x17C58BC
    void InstallDefaultBindings();
    // private System.Object CreateLazyBinding(Zenject.InjectContext context)
    // Offset: 0x17C63D8
    ::Il2CppObject* CreateLazyBinding(::Zenject::InjectContext* context);
    // public System.Void QueueForValidate(Zenject.IValidatable validatable)
    // Offset: 0x17C6640
    void QueueForValidate(::Zenject::IValidatable* validatable);
    // private System.Boolean ShouldInheritBinding(Zenject.BindStatement binding, Zenject.DiContainer ancestorContainer)
    // Offset: 0x17C5D20
    bool ShouldInheritBinding(::Zenject::BindStatement* binding, ::Zenject::DiContainer* ancestorContainer);
    // public System.Void ResolveRoots()
    // Offset: 0x17C68E8
    void ResolveRoots();
    // private System.Void ResolveDependencyRoots()
    // Offset: 0x17C6960
    void ResolveDependencyRoots();
    // private System.Void ValidateFullResolve()
    // Offset: 0x17C7414
    void ValidateFullResolve();
    // private System.Void FlushValidationQueue()
    // Offset: 0x17C6F30
    void FlushValidationQueue();
    // public Zenject.DiContainer CreateSubContainer()
    // Offset: 0x17C7814
    ::Zenject::DiContainer* CreateSubContainer();
    // public System.Void QueueForInject(System.Object instance)
    // Offset: 0x17C78E8
    void QueueForInject(::Il2CppObject* instance);
    // public T LazyInject(T instance)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T LazyInject(T instance) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::LazyInject");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "LazyInject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(instance)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, instance);
    }
    // private Zenject.DiContainer CreateSubContainer(System.Boolean isValidating)
    // Offset: 0x17C781C
    ::Zenject::DiContainer* CreateSubContainer(bool isValidating);
    // public System.Void RegisterProvider(Zenject.BindingId bindingId, Zenject.BindingCondition condition, Zenject.IProvider provider, System.Boolean nonLazy)
    // Offset: 0x17C7904
    void RegisterProvider(::Zenject::BindingId bindingId, ::Zenject::BindingCondition* condition, ::Zenject::IProvider* provider, bool nonLazy);
    // private System.Void GetProviderMatches(Zenject.InjectContext context, System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo> buffer)
    // Offset: 0x17C7A34
    void GetProviderMatches(::Zenject::InjectContext* context, ::System::Collections::Generic::List_1<::Zenject::DiContainer::ProviderInfo*>* buffer);
    // private Zenject.DiContainer/Zenject.ProviderInfo TryGetUniqueProvider(Zenject.InjectContext context)
    // Offset: 0x17C7CCC
    ::Zenject::DiContainer::ProviderInfo* TryGetUniqueProvider(::Zenject::InjectContext* context);
    // private System.Collections.Generic.List`1<Zenject.DiContainer> FlattenInheritanceChain()
    // Offset: 0x17C5B90
    ::System::Collections::Generic::List_1<::Zenject::DiContainer*>* FlattenInheritanceChain();
    // private System.Void GetLocalProviders(Zenject.BindingId bindingId, System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo> buffer)
    // Offset: 0x17C8270
    void GetLocalProviders(::Zenject::BindingId bindingId, ::System::Collections::Generic::List_1<::Zenject::DiContainer::ProviderInfo*>* buffer);
    // private System.Void GetProvidersForContract(Zenject.BindingId bindingId, Zenject.InjectSources sourceType, System.Collections.Generic.List`1<Zenject.DiContainer/Zenject.ProviderInfo> buffer)
    // Offset: 0x17C7BF0
    void GetProvidersForContract(::Zenject::BindingId bindingId, ::Zenject::InjectSources sourceType, ::System::Collections::Generic::List_1<::Zenject::DiContainer::ProviderInfo*>* buffer);
    // public System.Void Install()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TInstaller>
    void Install() {
      static_assert(std::is_convertible_v<TInstaller, ::Zenject::Installer*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Install");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Install", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TInstaller>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TInstaller>::get()}));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___generic__method);
    }
    // public System.Void Install(System.Object[] extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TInstaller>
    void Install(::ArrayW<::Il2CppObject*> extraArgs) {
      static_assert(std::is_convertible_v<TInstaller, ::Zenject::Installer*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Install");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Install", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TInstaller>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(extraArgs)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TInstaller>::get()}));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___generic__method, extraArgs);
    }
    // public System.Collections.IList ResolveAll(Zenject.InjectContext context)
    // Offset: 0x17C76F4
    ::System::Collections::IList* ResolveAll(::Zenject::InjectContext* context);
    // public System.Void ResolveAll(Zenject.InjectContext context, System.Collections.Generic.List`1<System.Object> buffer)
    // Offset: 0x17C838C
    void ResolveAll(::Zenject::InjectContext* context, ::System::Collections::Generic::List_1<::Il2CppObject*>* buffer);
    // private System.Void CheckForInstallWarning(Zenject.InjectContext context)
    // Offset: 0x17C8934
    void CheckForInstallWarning(::Zenject::InjectContext* context);
    // public System.Type ResolveType()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::System::Type* ResolveType() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::ResolveType");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "ResolveType", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::System::Type*, false>(this, ___generic__method);
    }
    // public System.Type ResolveType(System.Type type)
    // Offset: 0x17C895C
    ::System::Type* ResolveType(::System::Type* type);
    // public System.Type ResolveType(Zenject.InjectContext context)
    // Offset: 0x17C8A94
    ::System::Type* ResolveType(::Zenject::InjectContext* context);
    // public System.Collections.Generic.List`1<System.Type> ResolveTypeAll(System.Type type)
    // Offset: 0x17C8D28
    ::System::Collections::Generic::List_1<::System::Type*>* ResolveTypeAll(::System::Type* type);
    // public System.Collections.Generic.List`1<System.Type> ResolveTypeAll(System.Type type, System.Object identifier)
    // Offset: 0x17C8D30
    ::System::Collections::Generic::List_1<::System::Type*>* ResolveTypeAll(::System::Type* type, ::Il2CppObject* identifier);
    // public System.Collections.Generic.List`1<System.Type> ResolveTypeAll(Zenject.InjectContext context)
    // Offset: 0x17C8E84
    ::System::Collections::Generic::List_1<::System::Type*>* ResolveTypeAll(::Zenject::InjectContext* context);
    // public System.Object Resolve(Zenject.BindingId id)
    // Offset: 0x17C9120
    ::Il2CppObject* Resolve(::Zenject::BindingId id);
    // public System.Object Resolve(Zenject.InjectContext context)
    // Offset: 0x17C9274
    ::Il2CppObject* Resolve(::Zenject::InjectContext* context);
    // private System.Void SafeGetInstances(Zenject.DiContainer/Zenject.ProviderInfo providerInfo, Zenject.InjectContext context, System.Collections.Generic.List`1<System.Object> instances)
    // Offset: 0x17C70D8
    void SafeGetInstances(::Zenject::DiContainer::ProviderInfo* providerInfo, ::Zenject::InjectContext* context, ::System::Collections::Generic::List_1<::Il2CppObject*>* instances);
    // public Zenject.DecoratorToChoiceFromBinder`1<TContract> Decorate()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::Zenject::DecoratorToChoiceFromBinder_1<TContract>* Decorate() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Decorate");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Decorate", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::DecoratorToChoiceFromBinder_1<TContract>*, false>(this, ___generic__method);
    }
    // private System.Void GetDecoratedInstances(Zenject.IProvider provider, Zenject.InjectContext context, System.Collections.Generic.List`1<System.Object> buffer)
    // Offset: 0x17C9E80
    void GetDecoratedInstances(::Zenject::IProvider* provider, ::Zenject::InjectContext* context, ::System::Collections::Generic::List_1<::Il2CppObject*>* buffer);
    // private Zenject.Internal.IDecoratorProvider TryGetDecoratorProvider(System.Type contractType)
    // Offset: 0x17C9FAC
    ::Zenject::Internal::IDecoratorProvider* TryGetDecoratorProvider(::System::Type* contractType);
    // private System.Int32 GetContainerHeirarchyDistance(Zenject.DiContainer container)
    // Offset: 0x17C81FC
    int GetContainerHeirarchyDistance(::Zenject::DiContainer* container);
    // private System.Nullable`1<System.Int32> GetContainerHeirarchyDistance(Zenject.DiContainer container, System.Int32 depth)
    // Offset: 0x17CA0A4
    ::System::Nullable_1<int> GetContainerHeirarchyDistance(::Zenject::DiContainer* container, int depth);
    // public System.Collections.Generic.IEnumerable`1<System.Type> GetDependencyContracts()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::System::Collections::Generic::IEnumerable_1<::System::Type*>* GetDependencyContracts() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::GetDependencyContracts");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "GetDependencyContracts", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::IEnumerable_1<::System::Type*>*, false>(this, ___generic__method);
    }
    // public System.Collections.Generic.IEnumerable`1<System.Type> GetDependencyContracts(System.Type contract)
    // Offset: 0x17CA1EC
    ::System::Collections::Generic::IEnumerable_1<::System::Type*>* GetDependencyContracts(::System::Type* contract);
    // private System.Object InstantiateInternal(System.Type concreteType, System.Boolean autoInject, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x17CA26C
    ::Il2CppObject* InstantiateInternal(::System::Type* concreteType, bool autoInject, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // public System.Void InjectExplicit(System.Object injectable, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x17CAC38
    void InjectExplicit(::Il2CppObject* injectable, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs);
    // public System.Void InjectExplicit(System.Object injectable, System.Type injectableType, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x17B8794
    void InjectExplicit(::Il2CppObject* injectable, ::System::Type* injectableType, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // private System.Void CallInjectMethodsTopDown(System.Object injectable, System.Type injectableType, Zenject.InjectTypeInfo typeInfo, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier, System.Boolean isDryRun)
    // Offset: 0x17CB150
    void CallInjectMethodsTopDown(::Il2CppObject* injectable, ::System::Type* injectableType, ::Zenject::InjectTypeInfo* typeInfo, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier, bool isDryRun);
    // private System.Void InjectMembersTopDown(System.Object injectable, System.Type injectableType, Zenject.InjectTypeInfo typeInfo, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier, System.Boolean isDryRun)
    // Offset: 0x17CB678
    void InjectMembersTopDown(::Il2CppObject* injectable, ::System::Type* injectableType, ::Zenject::InjectTypeInfo* typeInfo, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier, bool isDryRun);
    // private System.Void InjectExplicitInternal(System.Object injectable, System.Type injectableType, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x17CAD24
    void InjectExplicitInternal(::Il2CppObject* injectable, ::System::Type* injectableType, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // UnityEngine.GameObject CreateAndParentPrefabResource(System.String resourcePath, Zenject.GameObjectCreationParameters gameObjectBindInfo, Zenject.InjectContext context, out System.Boolean shouldMakeActive)
    // Offset: 0x17CB934
    ::UnityEngine::GameObject* CreateAndParentPrefabResource(::StringW resourcePath, ::Zenject::GameObjectCreationParameters* gameObjectBindInfo, ::Zenject::InjectContext* context, ByRef<bool> shouldMakeActive);
    // private UnityEngine.GameObject GetPrefabAsGameObject(UnityEngine.Object prefab)
    // Offset: 0x17CBE74
    ::UnityEngine::GameObject* GetPrefabAsGameObject(::UnityEngine::Object* prefab);
    // UnityEngine.GameObject CreateAndParentPrefab(UnityEngine.Object prefab, Zenject.GameObjectCreationParameters gameObjectBindInfo, Zenject.InjectContext context, out System.Boolean shouldMakeActive)
    // Offset: 0x17CBA60
    ::UnityEngine::GameObject* CreateAndParentPrefab(::UnityEngine::Object* prefab, ::Zenject::GameObjectCreationParameters* gameObjectBindInfo, ::Zenject::InjectContext* context, ByRef<bool> shouldMakeActive);
    // public UnityEngine.GameObject CreateEmptyGameObject(System.String name)
    // Offset: 0x17CC410
    ::UnityEngine::GameObject* CreateEmptyGameObject(::StringW name);
    // public UnityEngine.GameObject CreateEmptyGameObject(Zenject.GameObjectCreationParameters gameObjectBindInfo, Zenject.InjectContext context)
    // Offset: 0x17B934C
    ::UnityEngine::GameObject* CreateEmptyGameObject(::Zenject::GameObjectCreationParameters* gameObjectBindInfo, ::Zenject::InjectContext* context);
    // private UnityEngine.Transform GetTransformGroup(Zenject.GameObjectCreationParameters gameObjectBindInfo, Zenject.InjectContext context)
    // Offset: 0x17CBF7C
    ::UnityEngine::Transform* GetTransformGroup(::Zenject::GameObjectCreationParameters* gameObjectBindInfo, ::Zenject::InjectContext* context);
    // private UnityEngine.GameObject CreateTransformGroup(System.String groupName)
    // Offset: 0x17CC490
    ::UnityEngine::GameObject* CreateTransformGroup(::StringW groupName);
    // public T Instantiate()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T Instantiate() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Instantiate");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Instantiate", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method);
    }
    // public T Instantiate(System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T Instantiate(::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Instantiate");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Instantiate", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, extraArgs);
    }
    // public System.Object Instantiate(System.Type concreteType)
    // Offset: 0x17BFDF0
    ::Il2CppObject* Instantiate(::System::Type* concreteType);
    // public System.Object Instantiate(System.Type concreteType, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x17CC558
    ::Il2CppObject* Instantiate(::System::Type* concreteType, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public TContract InstantiateComponent(UnityEngine.GameObject gameObject)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    TContract InstantiateComponent(::UnityEngine::GameObject* gameObject) {
      static_assert(std::is_convertible_v<TContract, ::UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiateComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObject)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<TContract, false>(this, ___generic__method, gameObject);
    }
    // public TContract InstantiateComponent(UnityEngine.GameObject gameObject, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    TContract InstantiateComponent(::UnityEngine::GameObject* gameObject, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<TContract, ::UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiateComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObject), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<TContract, false>(this, ___generic__method, gameObject, extraArgs);
    }
    // public UnityEngine.Component InstantiateComponent(System.Type componentType, UnityEngine.GameObject gameObject)
    // Offset: 0x17CC684
    ::UnityEngine::Component* InstantiateComponent(::System::Type* componentType, ::UnityEngine::GameObject* gameObject);
    // public UnityEngine.Component InstantiateComponent(System.Type componentType, UnityEngine.GameObject gameObject, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x17CC700
    ::UnityEngine::Component* InstantiateComponent(::System::Type* componentType, ::UnityEngine::GameObject* gameObject, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public T InstantiateComponentOnNewGameObject()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiateComponentOnNewGameObject() {
      static_assert(std::is_convertible_v<T, ::UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiateComponentOnNewGameObject");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponentOnNewGameObject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method);
    }
    // public T InstantiateComponentOnNewGameObject(System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiateComponentOnNewGameObject(::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<T, ::UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiateComponentOnNewGameObject");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponentOnNewGameObject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, extraArgs);
    }
    // public T InstantiateComponentOnNewGameObject(System.String gameObjectName)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiateComponentOnNewGameObject(::StringW gameObjectName) {
      static_assert(std::is_convertible_v<T, ::UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiateComponentOnNewGameObject");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponentOnNewGameObject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObjectName)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, gameObjectName);
    }
    // public T InstantiateComponentOnNewGameObject(System.String gameObjectName, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiateComponentOnNewGameObject(::StringW gameObjectName, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<T, ::UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiateComponentOnNewGameObject");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateComponentOnNewGameObject", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObjectName), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, gameObjectName, extraArgs);
    }
    // public UnityEngine.GameObject InstantiatePrefab(UnityEngine.Object prefab)
    // Offset: 0x17CC818
    ::UnityEngine::GameObject* InstantiatePrefab(::UnityEngine::Object* prefab);
    // public UnityEngine.GameObject InstantiatePrefab(UnityEngine.Object prefab, UnityEngine.Transform parentTransform)
    // Offset: 0x17CC920
    ::UnityEngine::GameObject* InstantiatePrefab(::UnityEngine::Object* prefab, ::UnityEngine::Transform* parentTransform);
    // public UnityEngine.GameObject InstantiatePrefab(UnityEngine.Object prefab, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform)
    // Offset: 0x17CC9A4
    ::UnityEngine::GameObject* InstantiatePrefab(::UnityEngine::Object* prefab, ::UnityEngine::Vector3 position, ::UnityEngine::Quaternion rotation, ::UnityEngine::Transform* parentTransform);
    // public UnityEngine.GameObject InstantiatePrefab(UnityEngine.Object prefab, Zenject.GameObjectCreationParameters gameObjectBindInfo)
    // Offset: 0x17CC898
    ::UnityEngine::GameObject* InstantiatePrefab(::UnityEngine::Object* prefab, ::Zenject::GameObjectCreationParameters* gameObjectBindInfo);
    // public UnityEngine.GameObject InstantiatePrefabResource(System.String resourcePath)
    // Offset: 0x17CCC2C
    ::UnityEngine::GameObject* InstantiatePrefabResource(::StringW resourcePath);
    // public UnityEngine.GameObject InstantiatePrefabResource(System.String resourcePath, UnityEngine.Transform parentTransform)
    // Offset: 0x17CCDC0
    ::UnityEngine::GameObject* InstantiatePrefabResource(::StringW resourcePath, ::UnityEngine::Transform* parentTransform);
    // public UnityEngine.GameObject InstantiatePrefabResource(System.String resourcePath, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform)
    // Offset: 0x17CCE44
    ::UnityEngine::GameObject* InstantiatePrefabResource(::StringW resourcePath, ::UnityEngine::Vector3 position, ::UnityEngine::Quaternion rotation, ::UnityEngine::Transform* parentTransform);
    // public UnityEngine.GameObject InstantiatePrefabResource(System.String resourcePath, Zenject.GameObjectCreationParameters creationInfo)
    // Offset: 0x17CCCAC
    ::UnityEngine::GameObject* InstantiatePrefabResource(::StringW resourcePath, ::Zenject::GameObjectCreationParameters* creationInfo);
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(::UnityEngine::Object* prefab) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, prefab);
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(::UnityEngine::Object* prefab, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, prefab, extraArgs);
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, UnityEngine.Transform parentTransform)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(::UnityEngine::Object* prefab, ::UnityEngine::Transform* parentTransform) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(parentTransform)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, prefab, parentTransform);
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(::UnityEngine::Object* prefab, ::UnityEngine::Transform* parentTransform, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(parentTransform), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, prefab, parentTransform, extraArgs);
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(::UnityEngine::Object* prefab, ::UnityEngine::Vector3 position, ::UnityEngine::Quaternion rotation, ::UnityEngine::Transform* parentTransform) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(position), ::il2cpp_utils::ExtractType(rotation), ::il2cpp_utils::ExtractType(parentTransform)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, prefab, position, rotation, parentTransform);
    }
    // public T InstantiatePrefabForComponent(UnityEngine.Object prefab, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabForComponent(::UnityEngine::Object* prefab, ::UnityEngine::Vector3 position, ::UnityEngine::Quaternion rotation, ::UnityEngine::Transform* parentTransform, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(prefab), ::il2cpp_utils::ExtractType(position), ::il2cpp_utils::ExtractType(rotation), ::il2cpp_utils::ExtractType(parentTransform), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, prefab, position, rotation, parentTransform, extraArgs);
    }
    // public System.Object InstantiatePrefabForComponent(System.Type concreteType, UnityEngine.Object prefab, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x17CCF78
    ::Il2CppObject* InstantiatePrefabForComponent(::System::Type* concreteType, ::UnityEngine::Object* prefab, ::UnityEngine::Transform* parentTransform, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public System.Object InstantiatePrefabForComponent(System.Type concreteType, UnityEngine.Object prefab, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs, Zenject.GameObjectCreationParameters creationInfo)
    // Offset: 0x17CD020
    ::Il2CppObject* InstantiatePrefabForComponent(::System::Type* concreteType, ::UnityEngine::Object* prefab, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs, ::Zenject::GameObjectCreationParameters* creationInfo);
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::StringW resourcePath) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, resourcePath);
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::StringW resourcePath, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, resourcePath, extraArgs);
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, UnityEngine.Transform parentTransform)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::StringW resourcePath, ::UnityEngine::Transform* parentTransform) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(parentTransform)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, resourcePath, parentTransform);
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::StringW resourcePath, ::UnityEngine::Transform* parentTransform, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(parentTransform), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, resourcePath, parentTransform, extraArgs);
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::StringW resourcePath, ::UnityEngine::Vector3 position, ::UnityEngine::Quaternion rotation, ::UnityEngine::Transform* parentTransform) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(position), ::il2cpp_utils::ExtractType(rotation), ::il2cpp_utils::ExtractType(parentTransform)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, resourcePath, position, rotation, parentTransform);
    }
    // public T InstantiatePrefabResourceForComponent(System.String resourcePath, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiatePrefabResourceForComponent(::StringW resourcePath, ::UnityEngine::Vector3 position, ::UnityEngine::Quaternion rotation, ::UnityEngine::Transform* parentTransform, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiatePrefabResourceForComponent");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(position), ::il2cpp_utils::ExtractType(rotation), ::il2cpp_utils::ExtractType(parentTransform), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, resourcePath, position, rotation, parentTransform, extraArgs);
    }
    // public System.Object InstantiatePrefabResourceForComponent(System.Type concreteType, System.String resourcePath, UnityEngine.Transform parentTransform, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x17CD114
    ::Il2CppObject* InstantiatePrefabResourceForComponent(::System::Type* concreteType, ::StringW resourcePath, ::UnityEngine::Transform* parentTransform, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public T InstantiateScriptableObjectResource(System.String resourcePath)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiateScriptableObjectResource(::StringW resourcePath) {
      static_assert(std::is_convertible_v<T, ::UnityEngine::ScriptableObject*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiateScriptableObjectResource");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateScriptableObjectResource", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, resourcePath);
    }
    // public T InstantiateScriptableObjectResource(System.String resourcePath, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiateScriptableObjectResource(::StringW resourcePath, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<T, ::UnityEngine::ScriptableObject*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiateScriptableObjectResource");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateScriptableObjectResource", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(resourcePath), ::il2cpp_utils::ExtractType(extraArgs)})));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, resourcePath, extraArgs);
    }
    // public System.Object InstantiateScriptableObjectResource(System.Type scriptableObjectType, System.String resourcePath)
    // Offset: 0x17CD29C
    ::Il2CppObject* InstantiateScriptableObjectResource(::System::Type* scriptableObjectType, ::StringW resourcePath);
    // public System.Object InstantiateScriptableObjectResource(System.Type scriptableObjectType, System.String resourcePath, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x17CD310
    ::Il2CppObject* InstantiateScriptableObjectResource(::System::Type* scriptableObjectType, ::StringW resourcePath, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public System.Void InjectGameObject(UnityEngine.GameObject gameObject)
    // Offset: 0x17CCAD8
    void InjectGameObject(::UnityEngine::GameObject* gameObject);
    // public T InjectGameObjectForComponent(UnityEngine.GameObject gameObject)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InjectGameObjectForComponent(::UnityEngine::GameObject* gameObject) {
      static_assert(std::is_convertible_v<T, ::UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InjectGameObjectForComponent");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InjectGameObjectForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObject)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, gameObject);
    }
    // public T InjectGameObjectForComponent(UnityEngine.GameObject gameObject, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InjectGameObjectForComponent(::UnityEngine::GameObject* gameObject, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs) {
      static_assert(std::is_convertible_v<T, ::UnityEngine::Component*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InjectGameObjectForComponent");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InjectGameObjectForComponent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(gameObject), ::il2cpp_utils::ExtractType(extraArgs)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, gameObject, extraArgs);
    }
    // public System.Object InjectGameObjectForComponent(UnityEngine.GameObject gameObject, System.Type componentType, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x17CD4BC
    ::Il2CppObject* InjectGameObjectForComponent(::UnityEngine::GameObject* gameObject, ::System::Type* componentType, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public UnityEngine.Component InjectGameObjectForComponentExplicit(UnityEngine.GameObject gameObject, System.Type componentType, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x17CD56C
    ::UnityEngine::Component* InjectGameObjectForComponentExplicit(::UnityEngine::GameObject* gameObject, ::System::Type* componentType, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // public System.Void Inject(System.Object injectable)
    // Offset: 0x17BFE5C
    void Inject(::Il2CppObject* injectable);
    // public System.Void Inject(System.Object injectable, System.Collections.Generic.IEnumerable`1<System.Object> extraArgs)
    // Offset: 0x17CD890
    void Inject(::Il2CppObject* injectable, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>* extraArgs);
    // public TContract Resolve()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    TContract Resolve() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Resolve");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Resolve", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<TContract, false>(this, ___generic__method);
    }
    // public System.Object Resolve(System.Type contractType)
    // Offset: 0x17CD8C8
    ::Il2CppObject* Resolve(::System::Type* contractType);
    // public TContract ResolveId(System.Object identifier)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    TContract ResolveId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::ResolveId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "ResolveId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<TContract, false>(this, ___generic__method, identifier);
    }
    // public System.Object ResolveId(System.Type contractType, System.Object identifier)
    // Offset: 0x17CD8D0
    ::Il2CppObject* ResolveId(::System::Type* contractType, ::Il2CppObject* identifier);
    // public TContract TryResolve()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    TContract TryResolve() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::TryResolve");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "TryResolve", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<TContract, false>(this, ___generic__method);
    }
    // public System.Object TryResolve(System.Type contractType)
    // Offset: 0x17CDA24
    ::Il2CppObject* TryResolve(::System::Type* contractType);
    // public TContract TryResolveId(System.Object identifier)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    TContract TryResolveId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::TryResolveId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "TryResolveId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<TContract, false>(this, ___generic__method, identifier);
    }
    // public System.Object TryResolveId(System.Type contractType, System.Object identifier)
    // Offset: 0x17CDA2C
    ::Il2CppObject* TryResolveId(::System::Type* contractType, ::Il2CppObject* identifier);
    // public System.Collections.Generic.List`1<TContract> ResolveAll()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::System::Collections::Generic::List_1<TContract>* ResolveAll() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::ResolveAll");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "ResolveAll", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::List_1<TContract>*, false>(this, ___generic__method);
    }
    // public System.Collections.IList ResolveAll(System.Type contractType)
    // Offset: 0x17CDB88
    ::System::Collections::IList* ResolveAll(::System::Type* contractType);
    // public System.Collections.Generic.List`1<TContract> ResolveIdAll(System.Object identifier)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::System::Collections::Generic::List_1<TContract>* ResolveIdAll(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::ResolveIdAll");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "ResolveIdAll", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::List_1<TContract>*, false>(this, ___generic__method, identifier);
    }
    // public System.Collections.IList ResolveIdAll(System.Type contractType, System.Object identifier)
    // Offset: 0x17CDB90
    ::System::Collections::IList* ResolveIdAll(::System::Type* contractType, ::Il2CppObject* identifier);
    // public System.Void UnbindAll()
    // Offset: 0x17CDCEC
    void UnbindAll();
    // public System.Boolean Unbind()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    bool Unbind() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Unbind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Unbind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___generic__method);
    }
    // public System.Boolean Unbind(System.Type contractType)
    // Offset: 0x17CDD4C
    bool Unbind(::System::Type* contractType);
    // public System.Boolean UnbindId(System.Object identifier)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    bool UnbindId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::UnbindId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "UnbindId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___generic__method, identifier);
    }
    // public System.Boolean UnbindId(System.Type contractType, System.Object identifier)
    // Offset: 0x17CDD54
    bool UnbindId(::System::Type* contractType, ::Il2CppObject* identifier);
    // public System.Void UnbindInterfacesTo()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TConcrete>
    void UnbindInterfacesTo() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::UnbindInterfacesTo");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "UnbindInterfacesTo", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()}));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___generic__method);
    }
    // public System.Void UnbindInterfacesTo(System.Type concreteType)
    // Offset: 0x17CDDCC
    void UnbindInterfacesTo(::System::Type* concreteType);
    // public System.Boolean Unbind()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract, class TConcrete>
    bool Unbind() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Unbind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Unbind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___generic__method);
    }
    // public System.Boolean Unbind(System.Type contractType, System.Type concreteType)
    // Offset: 0x17CDEA4
    bool Unbind(::System::Type* contractType, ::System::Type* concreteType);
    // public System.Boolean UnbindId(System.Object identifier)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract, class TConcrete>
    bool UnbindId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::UnbindId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "UnbindId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___generic__method, identifier);
    }
    // public System.Boolean UnbindId(System.Type contractType, System.Type concreteType, System.Object identifier)
    // Offset: 0x17CDEAC
    bool UnbindId(::System::Type* contractType, ::System::Type* concreteType, ::Il2CppObject* identifier);
    // public System.Boolean HasBinding()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    bool HasBinding() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::HasBinding");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "HasBinding", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___generic__method);
    }
    // public System.Boolean HasBinding(System.Type contractType)
    // Offset: 0x17CE09C
    bool HasBinding(::System::Type* contractType);
    // public System.Boolean HasBindingId(System.Object identifier)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    bool HasBindingId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::HasBindingId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "HasBindingId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___generic__method, identifier);
    }
    // public System.Boolean HasBindingId(System.Type contractType, System.Object identifier)
    // Offset: 0x17CE0A8
    bool HasBindingId(::System::Type* contractType, ::Il2CppObject* identifier);
    // public System.Boolean HasBindingId(System.Type contractType, System.Object identifier, Zenject.InjectSources sourceType)
    // Offset: 0x17CE0B0
    bool HasBindingId(::System::Type* contractType, ::Il2CppObject* identifier, ::Zenject::InjectSources sourceType);
    // public System.Boolean HasBinding(Zenject.InjectContext context)
    // Offset: 0x17CE214
    bool HasBinding(::Zenject::InjectContext* context);
    // public System.Void FlushBindings()
    // Offset: 0x17C5AB4
    void FlushBindings();
    // private System.Void FinalizeBinding(Zenject.BindStatement binding)
    // Offset: 0x17C5DE4
    void FinalizeBinding(::Zenject::BindStatement* binding);
    // public Zenject.BindStatement StartBinding(System.Boolean flush)
    // Offset: 0x17CE330
    ::Zenject::BindStatement* StartBinding(bool flush);
    // public Zenject.ConcreteBinderGeneric`1<TContract> Rebind()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::Zenject::ConcreteBinderGeneric_1<TContract>* Rebind() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Rebind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Rebind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::ConcreteBinderGeneric_1<TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.ConcreteBinderGeneric`1<TContract> RebindId(System.Object identifier)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::Zenject::ConcreteBinderGeneric_1<TContract>* RebindId(::Il2CppObject* identifier) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::RebindId");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "RebindId", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(identifier)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::ConcreteBinderGeneric_1<TContract>*, false>(this, ___generic__method, identifier);
    }
    // public Zenject.ConcreteBinderNonGeneric Rebind(System.Type contractType)
    // Offset: 0x17CE3F8
    ::Zenject::ConcreteBinderNonGeneric* Rebind(::System::Type* contractType);
    // public Zenject.ConcreteBinderNonGeneric RebindId(System.Type contractType, System.Object identifier)
    // Offset: 0x17CE400
    ::Zenject::ConcreteBinderNonGeneric* RebindId(::System::Type* contractType, ::Il2CppObject* identifier);
    // public Zenject.ConcreteIdBinderGeneric`1<TContract> Bind()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::Zenject::ConcreteIdBinderGeneric_1<TContract>* Bind() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Bind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Bind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::ConcreteIdBinderGeneric_1<TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.ConcreteIdBinderGeneric`1<TContract> BindNoFlush()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::Zenject::ConcreteIdBinderGeneric_1<TContract>* BindNoFlush() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindNoFlush");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindNoFlush", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::ConcreteIdBinderGeneric_1<TContract>*, false>(this, ___generic__method);
    }
    // private Zenject.ConcreteIdBinderGeneric`1<TContract> Bind(Zenject.BindStatement bindStatement)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::Zenject::ConcreteIdBinderGeneric_1<TContract>* Bind(::Zenject::BindStatement* bindStatement) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::Bind");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "Bind", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(bindStatement)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::ConcreteIdBinderGeneric_1<TContract>*, false>(this, ___generic__method, bindStatement);
    }
    // public Zenject.ConcreteIdBinderNonGeneric Bind(params System.Type[] contractTypes)
    // Offset: 0x17C0A64
    ::Zenject::ConcreteIdBinderNonGeneric* Bind(::ArrayW<::System::Type*> contractTypes);
    // public Zenject.ConcreteIdBinderNonGeneric Bind(System.Collections.Generic.IEnumerable`1<System.Type> contractTypes)
    // Offset: 0x17CE634
    ::Zenject::ConcreteIdBinderNonGeneric* Bind(::System::Collections::Generic::IEnumerable_1<::System::Type*>* contractTypes);
    // private Zenject.ConcreteIdBinderNonGeneric BindInternal(Zenject.BindInfo bindInfo, Zenject.BindStatement bindingFinalizer)
    // Offset: 0x17CE4D8
    ::Zenject::ConcreteIdBinderNonGeneric* BindInternal(::Zenject::BindInfo* bindInfo, ::Zenject::BindStatement* bindingFinalizer);
    // public Zenject.ConcreteIdBinderNonGeneric Bind(System.Action`1<Zenject.ConventionSelectTypesBinder> generator)
    // Offset: 0x17CE6CC
    ::Zenject::ConcreteIdBinderNonGeneric* Bind(::System::Action_1<::Zenject::ConventionSelectTypesBinder*>* generator);
    // public Zenject.FromBinderNonGeneric BindInterfacesTo()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::Zenject::FromBinderNonGeneric* BindInterfacesTo() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindInterfacesTo");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindInterfacesTo", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FromBinderNonGeneric*, false>(this, ___generic__method);
    }
    // public Zenject.FromBinderNonGeneric BindInterfacesTo(System.Type type)
    // Offset: 0x17CE8C0
    ::Zenject::FromBinderNonGeneric* BindInterfacesTo(::System::Type* type);
    // public Zenject.FromBinderNonGeneric BindInterfacesAndSelfTo()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::Zenject::FromBinderNonGeneric* BindInterfacesAndSelfTo() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindInterfacesAndSelfTo");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindInterfacesAndSelfTo", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FromBinderNonGeneric*, false>(this, ___generic__method);
    }
    // public Zenject.FromBinderNonGeneric BindInterfacesAndSelfTo(System.Type type)
    // Offset: 0x17CEA64
    ::Zenject::FromBinderNonGeneric* BindInterfacesAndSelfTo(::System::Type* type);
    // public Zenject.IdScopeConcreteIdArgConditionCopyNonLazyBinder BindInstance(TContract instance)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::Zenject::IdScopeConcreteIdArgConditionCopyNonLazyBinder* BindInstance(TContract instance) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindInstance");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindInstance", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(instance)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::IdScopeConcreteIdArgConditionCopyNonLazyBinder*, false>(this, ___generic__method, instance);
    }
    // public System.Void BindInstances(params System.Object[] instances)
    // Offset: 0x17CEBC0
    void BindInstances(::ArrayW<::Il2CppObject*> instances);
    // private Zenject.FactoryToChoiceIdBinder`1<TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract, class TFactoryContract, class TFactoryConcrete>
    ::Zenject::FactoryToChoiceIdBinder_1<TContract>* BindFactoryInternal() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_convertible_v<std::remove_pointer_t<TFactoryConcrete>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_1<TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`1<TContract> BindIFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract>
    ::Zenject::FactoryToChoiceIdBinder_1<TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_1<TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`1<TContract> BindFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract, class TFactory>
    ::Zenject::FactoryToChoiceIdBinder_1<TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, ::Zenject::PlaceholderFactory_1<TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_1<TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`1<TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TContract, class TFactoryConcrete, class TFactoryContract>
    ::Zenject::FactoryToChoiceIdBinder_1<TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, ::Zenject::PlaceholderFactory_1<TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_1<TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPool()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TItemContract>
    ::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPool() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindMemoryPool");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPool", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method);
    }
    // public Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPool()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TItemContract, class TPool>
    ::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPool() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TPool>, ::Zenject::IMemoryPool>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindMemoryPool");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPool", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPool>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPool>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method);
    }
    // public Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPoolCustomInterface(System.Boolean includeConcreteType)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TItemContract, class TPoolConcrete, class TPoolContract>
    ::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPoolCustomInterface(bool includeConcreteType) {
      static_assert(std::is_convertible_v<TPoolConcrete, TPoolContract> && std::is_convertible_v<std::remove_pointer_t<TPoolConcrete>, ::Zenject::IMemoryPool>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TPoolContract>, ::Zenject::IMemoryPool>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindMemoryPoolCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPoolCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(includeConcreteType)})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method, includeConcreteType);
    }
    // Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPoolCustomInterfaceNoFlush(System.Boolean includeConcreteType)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TItemContract, class TPoolConcrete, class TPoolContract>
    ::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPoolCustomInterfaceNoFlush(bool includeConcreteType) {
      static_assert(std::is_convertible_v<TPoolConcrete, TPoolContract> && std::is_convertible_v<std::remove_pointer_t<TPoolConcrete>, ::Zenject::IMemoryPool>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TPoolContract>, ::Zenject::IMemoryPool>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindMemoryPoolCustomInterfaceNoFlush");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPoolCustomInterfaceNoFlush", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(includeConcreteType)})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method, includeConcreteType);
    }
    // private Zenject.MemoryPoolIdInitialSizeMaxSizeBinder`1<TItemContract> BindMemoryPoolCustomInterfaceInternal(System.Boolean includeConcreteType, Zenject.BindStatement statement)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TItemContract, class TPoolConcrete, class TPoolContract>
    ::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>* BindMemoryPoolCustomInterfaceInternal(bool includeConcreteType, ::Zenject::BindStatement* statement) {
      static_assert(std::is_convertible_v<TPoolConcrete, TPoolContract> && std::is_convertible_v<std::remove_pointer_t<TPoolConcrete>, ::Zenject::IMemoryPool>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TPoolContract>, ::Zenject::IMemoryPool>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindMemoryPoolCustomInterfaceInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindMemoryPoolCustomInterfaceInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(includeConcreteType), ::il2cpp_utils::ExtractType(statement)})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TItemContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TPoolContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::MemoryPoolIdInitialSizeMaxSizeBinder_1<TItemContract>*, false>(this, ___generic__method, includeConcreteType, statement);
    }
    // private Zenject.FactoryToChoiceIdBinder`2<TParam1,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TContract, class TFactoryContract, class TFactoryConcrete>
    ::Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>* BindFactoryInternal() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_convertible_v<std::remove_pointer_t<TFactoryConcrete>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`2<TParam1,TContract> BindIFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TContract>
    ::Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`2<TParam1,TContract> BindFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TContract, class TFactory>
    ::Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, ::Zenject::PlaceholderFactory_2<TParam1, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`2<TParam1,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TContract, class TFactoryConcrete, class TFactoryContract>
    ::Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, ::Zenject::PlaceholderFactory_2<TParam1, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_2<TParam1, TContract>*, false>(this, ___generic__method);
    }
    // private Zenject.FactoryToChoiceIdBinder`3<TParam1,TParam2,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TContract, class TFactoryContract, class TFactoryConcrete>
    ::Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>* BindFactoryInternal() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_convertible_v<std::remove_pointer_t<TFactoryConcrete>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`3<TParam1,TParam2,TContract> BindIFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TContract>
    ::Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`3<TParam1,TParam2,TContract> BindFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TContract, class TFactory>
    ::Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, ::Zenject::PlaceholderFactory_3<TParam1, TParam2, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`3<TParam1,TParam2,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TContract, class TFactoryConcrete, class TFactoryContract>
    ::Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, ::Zenject::PlaceholderFactory_3<TParam1, TParam2, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_3<TParam1, TParam2, TContract>*, false>(this, ___generic__method);
    }
    // private Zenject.FactoryToChoiceIdBinder`4<TParam1,TParam2,TParam3,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TContract, class TFactoryContract, class TFactoryConcrete>
    ::Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>* BindFactoryInternal() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_convertible_v<std::remove_pointer_t<TFactoryConcrete>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`4<TParam1,TParam2,TParam3,TContract> BindIFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TContract>
    ::Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`4<TParam1,TParam2,TParam3,TContract> BindFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TContract, class TFactory>
    ::Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, ::Zenject::PlaceholderFactory_4<TParam1, TParam2, TParam3, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`4<TParam1,TParam2,TParam3,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TContract, class TFactoryConcrete, class TFactoryContract>
    ::Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, ::Zenject::PlaceholderFactory_4<TParam1, TParam2, TParam3, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_4<TParam1, TParam2, TParam3, TContract>*, false>(this, ___generic__method);
    }
    // private Zenject.FactoryToChoiceIdBinder`5<TParam1,TParam2,TParam3,TParam4,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TContract, class TFactoryContract, class TFactoryConcrete>
    ::Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>* BindFactoryInternal() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_convertible_v<std::remove_pointer_t<TFactoryConcrete>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`5<TParam1,TParam2,TParam3,TParam4,TContract> BindIFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TContract>
    ::Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`5<TParam1,TParam2,TParam3,TParam4,TContract> BindFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TContract, class TFactory>
    ::Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, ::Zenject::PlaceholderFactory_5<TParam1, TParam2, TParam3, TParam4, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`5<TParam1,TParam2,TParam3,TParam4,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TContract, class TFactoryConcrete, class TFactoryContract>
    ::Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, ::Zenject::PlaceholderFactory_5<TParam1, TParam2, TParam3, TParam4, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_5<TParam1, TParam2, TParam3, TParam4, TContract>*, false>(this, ___generic__method);
    }
    // private Zenject.FactoryToChoiceIdBinder`6<TParam1,TParam2,TParam3,TParam4,TParam5,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TContract, class TFactoryContract, class TFactoryConcrete>
    ::Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>* BindFactoryInternal() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_convertible_v<std::remove_pointer_t<TFactoryConcrete>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`6<TParam1,TParam2,TParam3,TParam4,TParam5,TContract> BindIFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TContract>
    ::Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`6<TParam1,TParam2,TParam3,TParam4,TParam5,TContract> BindFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TContract, class TFactory>
    ::Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, ::Zenject::PlaceholderFactory_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`6<TParam1,TParam2,TParam3,TParam4,TParam5,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TContract, class TFactoryConcrete, class TFactoryContract>
    ::Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, ::Zenject::PlaceholderFactory_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_6<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>*, false>(this, ___generic__method);
    }
    // private Zenject.FactoryToChoiceIdBinder`7<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TContract, class TFactoryContract, class TFactoryConcrete>
    ::Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>* BindFactoryInternal() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_convertible_v<std::remove_pointer_t<TFactoryConcrete>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`7<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TContract> BindIFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TContract>
    ::Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`7<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TContract> BindFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TContract, class TFactory>
    ::Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, ::Zenject::PlaceholderFactory_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`7<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TContract, class TFactoryConcrete, class TFactoryContract>
    ::Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, ::Zenject::PlaceholderFactory_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_7<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>*, false>(this, ___generic__method);
    }
    // private Zenject.FactoryToChoiceIdBinder`11<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TParam7,TParam8,TParam9,TParam10,TContract> BindFactoryInternal()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TParam7, class TParam8, class TParam9, class TParam10, class TContract, class TFactoryContract, class TFactoryConcrete>
    ::Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>* BindFactoryInternal() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static_assert(std::is_convertible_v<TFactoryConcrete, TFactoryContract> && std::is_convertible_v<std::remove_pointer_t<TFactoryConcrete>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryInternal");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryInternal", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`11<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TParam7,TParam8,TParam9,TParam10,TContract> BindIFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TParam7, class TParam8, class TParam9, class TParam10, class TContract>
    ::Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>* BindIFactory() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindIFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindIFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`11<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TParam7,TParam8,TParam9,TParam10,TContract> BindFactory()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TParam7, class TParam8, class TParam9, class TParam10, class TContract, class TFactory>
    ::Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>* BindFactory() {
      static_assert(std::is_convertible_v<TFactory, ::Zenject::PlaceholderFactory_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactory");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactory", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactory>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*, false>(this, ___generic__method);
    }
    // public Zenject.FactoryToChoiceIdBinder`11<TParam1,TParam2,TParam3,TParam4,TParam5,TParam6,TParam7,TParam8,TParam9,TParam10,TContract> BindFactoryCustomInterface()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TParam1, class TParam2, class TParam3, class TParam4, class TParam5, class TParam6, class TParam7, class TParam8, class TParam9, class TParam10, class TContract, class TFactoryConcrete, class TFactoryContract>
    ::Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>* BindFactoryCustomInterface() {
      static_assert(std::is_convertible_v<TFactoryConcrete, ::Zenject::PlaceholderFactory_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*> && std::is_convertible_v<TFactoryConcrete, TFactoryContract>);
      static_assert(std::is_convertible_v<std::remove_pointer_t<TFactoryContract>, ::Zenject::IFactory>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFactoryCustomInterface");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFactoryCustomInterface", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam1>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam2>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam3>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam4>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam5>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam6>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam7>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam8>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam9>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TParam10>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TContract>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryConcrete>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TFactoryContract>::get()})));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::FactoryToChoiceIdBinder_11<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>*, false>(this, ___generic__method);
    }
    // public T InstantiateExplicit(System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T InstantiateExplicit(::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::InstantiateExplicit");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "InstantiateExplicit", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(extraArgs)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, extraArgs);
    }
    // public System.Object InstantiateExplicit(System.Type concreteType, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x17CC5F4
    ::Il2CppObject* InstantiateExplicit(::System::Type* concreteType, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs);
    // public System.Object InstantiateExplicit(System.Type concreteType, System.Boolean autoInject, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier)
    // Offset: 0x17CED00
    ::Il2CppObject* InstantiateExplicit(::System::Type* concreteType, bool autoInject, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier);
    // public UnityEngine.Component InstantiateComponentExplicit(System.Type componentType, UnityEngine.GameObject gameObject, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x17CC748
    ::UnityEngine::Component* InstantiateComponentExplicit(::System::Type* componentType, ::UnityEngine::GameObject* gameObject, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs);
    // public System.Object InstantiateScriptableObjectResourceExplicit(System.Type scriptableObjectType, System.String resourcePath, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x17CD39C
    ::Il2CppObject* InstantiateScriptableObjectResourceExplicit(::System::Type* scriptableObjectType, ::StringW resourcePath, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs);
    // public System.Object InstantiatePrefabResourceForComponentExplicit(System.Type componentType, System.String resourcePath, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.GameObjectCreationParameters creationInfo)
    // Offset: 0x17CD1F8
    ::Il2CppObject* InstantiatePrefabResourceForComponentExplicit(::System::Type* componentType, ::StringW resourcePath, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::GameObjectCreationParameters* creationInfo);
    // public System.Object InstantiatePrefabResourceForComponentExplicit(System.Type componentType, System.String resourcePath, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier, Zenject.GameObjectCreationParameters creationInfo)
    // Offset: 0x17CEE7C
    ::Il2CppObject* InstantiatePrefabResourceForComponentExplicit(::System::Type* componentType, ::StringW resourcePath, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier, ::Zenject::GameObjectCreationParameters* creationInfo);
    // public System.Object InstantiatePrefabForComponentExplicit(System.Type componentType, UnityEngine.Object prefab, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs)
    // Offset: 0x17CF148
    ::Il2CppObject* InstantiatePrefabForComponentExplicit(::System::Type* componentType, ::UnityEngine::Object* prefab, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs);
    // public System.Object InstantiatePrefabForComponentExplicit(System.Type componentType, UnityEngine.Object prefab, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.GameObjectCreationParameters gameObjectBindInfo)
    // Offset: 0x17CD070
    ::Il2CppObject* InstantiatePrefabForComponentExplicit(::System::Type* componentType, ::UnityEngine::Object* prefab, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::GameObjectCreationParameters* gameObjectBindInfo);
    // public System.Object InstantiatePrefabForComponentExplicit(System.Type componentType, UnityEngine.Object prefab, System.Collections.Generic.List`1<Zenject.TypeValuePair> extraArgs, Zenject.InjectContext context, System.Object concreteIdentifier, Zenject.GameObjectCreationParameters gameObjectBindInfo)
    // Offset: 0x17CEFC0
    ::Il2CppObject* InstantiatePrefabForComponentExplicit(::System::Type* componentType, ::UnityEngine::Object* prefab, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>* extraArgs, ::Zenject::InjectContext* context, ::Il2CppObject* concreteIdentifier, ::Zenject::GameObjectCreationParameters* gameObjectBindInfo);
    // public System.Void BindExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    void BindExecutionOrder(int order) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___generic__method, order);
    }
    // public System.Void BindExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x17CF1E0
    void BindExecutionOrder(::System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindTickableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::Zenject::CopyNonLazyBinder* BindTickableExecutionOrder(int order) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<T>, ::Zenject::ITickable>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindTickableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindTickableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order);
    }
    // public Zenject.CopyNonLazyBinder BindTickableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x17CF574
    ::Zenject::CopyNonLazyBinder* BindTickableExecutionOrder(::System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindInitializableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::Zenject::CopyNonLazyBinder* BindInitializableExecutionOrder(int order) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<T>, ::Zenject::IInitializable>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindInitializableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindInitializableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order);
    }
    // public Zenject.CopyNonLazyBinder BindInitializableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x17CF654
    ::Zenject::CopyNonLazyBinder* BindInitializableExecutionOrder(::System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindDisposableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::Zenject::CopyNonLazyBinder* BindDisposableExecutionOrder(int order) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<T>, ::System::IDisposable>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindDisposableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindDisposableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order);
    }
    // public Zenject.CopyNonLazyBinder BindLateDisposableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::Zenject::CopyNonLazyBinder* BindLateDisposableExecutionOrder(int order) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<T>, ::Zenject::ILateDisposable>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindLateDisposableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindLateDisposableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order);
    }
    // public Zenject.CopyNonLazyBinder BindDisposableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x17CF734
    ::Zenject::CopyNonLazyBinder* BindDisposableExecutionOrder(::System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindLateDisposableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x17CF814
    ::Zenject::CopyNonLazyBinder* BindLateDisposableExecutionOrder(::System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindFixedTickableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::Zenject::CopyNonLazyBinder* BindFixedTickableExecutionOrder(int order) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<T>, ::Zenject::IFixedTickable>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindFixedTickableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindFixedTickableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order);
    }
    // public Zenject.CopyNonLazyBinder BindFixedTickableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x17CF90C
    ::Zenject::CopyNonLazyBinder* BindFixedTickableExecutionOrder(::System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindLateTickableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::Zenject::CopyNonLazyBinder* BindLateTickableExecutionOrder(int order) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<T>, ::Zenject::ILateTickable>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindLateTickableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindLateTickableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order);
    }
    // public Zenject.CopyNonLazyBinder BindLateTickableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x17CFA28
    ::Zenject::CopyNonLazyBinder* BindLateTickableExecutionOrder(::System::Type* type, int order);
    // public Zenject.CopyNonLazyBinder BindPoolableExecutionOrder(System.Int32 order)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    ::Zenject::CopyNonLazyBinder* BindPoolableExecutionOrder(int order) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<T>, ::Zenject::IPoolable>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Zenject::DiContainer::BindPoolableExecutionOrder");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "BindPoolableExecutionOrder", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(order)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Zenject::CopyNonLazyBinder*, false>(this, ___generic__method, order);
    }
    // public Zenject.CopyNonLazyBinder BindPoolableExecutionOrder(System.Type type, System.Int32 order)
    // Offset: 0x17CFB44
    ::Zenject::CopyNonLazyBinder* BindPoolableExecutionOrder(::System::Type* type, int order);
  }; // Zenject.DiContainer
  #pragma pack(pop)
  static check_size<sizeof(DiContainer), 156 + sizeof(bool)> __Zenject_DiContainerSizeCheck;
  static_assert(sizeof(DiContainer) == 0x9D);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Zenject::DiContainer::get_Settings
// Il2CppName: get_Settings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::ZenjectSettings* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_Settings)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_Settings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::set_Settings
// Il2CppName: set_Settings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::ZenjectSettings*)>(&Zenject::DiContainer::set_Settings)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("Zenject", "ZenjectSettings")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "set_Settings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_SingletonMarkRegistry
// Il2CppName: get_SingletonMarkRegistry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::Internal::SingletonMarkRegistry* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_SingletonMarkRegistry)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_SingletonMarkRegistry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_AllProviders
// Il2CppName: get_AllProviders
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerable_1<::Zenject::IProvider*>* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_AllProviders)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_AllProviders", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_ContextTransform
// Il2CppName: get_ContextTransform
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Transform* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_ContextTransform)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_ContextTransform", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_AssertOnNewGameObjects
// Il2CppName: get_AssertOnNewGameObjects
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_AssertOnNewGameObjects)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_AssertOnNewGameObjects", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::set_AssertOnNewGameObjects
// Il2CppName: set_AssertOnNewGameObjects
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(bool)>(&Zenject::DiContainer::set_AssertOnNewGameObjects)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "set_AssertOnNewGameObjects", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_InheritedDefaultParent
// Il2CppName: get_InheritedDefaultParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Transform* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_InheritedDefaultParent)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_InheritedDefaultParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_DefaultParent
// Il2CppName: get_DefaultParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Transform* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_DefaultParent)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_DefaultParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::set_DefaultParent
// Il2CppName: set_DefaultParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::UnityEngine::Transform*)>(&Zenject::DiContainer::set_DefaultParent)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "set_DefaultParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_ParentContainers
// Il2CppName: get_ParentContainers
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::Zenject::DiContainer*> (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_ParentContainers)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_ParentContainers", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_AncestorContainers
// Il2CppName: get_AncestorContainers
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::Zenject::DiContainer*> (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_AncestorContainers)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_AncestorContainers", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_ChecksForCircularDependencies
// Il2CppName: get_ChecksForCircularDependencies
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_ChecksForCircularDependencies)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_ChecksForCircularDependencies", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_IsValidating
// Il2CppName: get_IsValidating
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_IsValidating)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_IsValidating", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_IsInstalling
// Il2CppName: get_IsInstalling
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_IsInstalling)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_IsInstalling", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::set_IsInstalling
// Il2CppName: set_IsInstalling
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(bool)>(&Zenject::DiContainer::set_IsInstalling)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "set_IsInstalling", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::get_AllContracts
// Il2CppName: get_AllContracts
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerable_1<::Zenject::BindingId>* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::get_AllContracts)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "get_AllContracts", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Zenject::DiContainer::InstallDefaultBindings
// Il2CppName: InstallDefaultBindings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::InstallDefaultBindings)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstallDefaultBindings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateLazyBinding
// Il2CppName: CreateLazyBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::Zenject::InjectContext*)>(&Zenject::DiContainer::CreateLazyBinding)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateLazyBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::QueueForValidate
// Il2CppName: QueueForValidate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::IValidatable*)>(&Zenject::DiContainer::QueueForValidate)> {
  static const MethodInfo* get() {
    static auto* validatable = &::il2cpp_utils::GetClassFromName("Zenject", "IValidatable")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "QueueForValidate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{validatable});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ShouldInheritBinding
// Il2CppName: ShouldInheritBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(::Zenject::BindStatement*, ::Zenject::DiContainer*)>(&Zenject::DiContainer::ShouldInheritBinding)> {
  static const MethodInfo* get() {
    static auto* binding = &::il2cpp_utils::GetClassFromName("Zenject", "BindStatement")->byval_arg;
    static auto* ancestorContainer = &::il2cpp_utils::GetClassFromName("Zenject", "DiContainer")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ShouldInheritBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{binding, ancestorContainer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveRoots
// Il2CppName: ResolveRoots
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::ResolveRoots)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveRoots", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveDependencyRoots
// Il2CppName: ResolveDependencyRoots
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::ResolveDependencyRoots)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveDependencyRoots", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ValidateFullResolve
// Il2CppName: ValidateFullResolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::ValidateFullResolve)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ValidateFullResolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::FlushValidationQueue
// Il2CppName: FlushValidationQueue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::FlushValidationQueue)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "FlushValidationQueue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateSubContainer
// Il2CppName: CreateSubContainer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::DiContainer* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::CreateSubContainer)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateSubContainer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::QueueForInject
// Il2CppName: QueueForInject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*)>(&Zenject::DiContainer::QueueForInject)> {
  static const MethodInfo* get() {
    static auto* instance = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "QueueForInject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{instance});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::LazyInject
// Il2CppName: LazyInject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::CreateSubContainer
// Il2CppName: CreateSubContainer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::DiContainer* (Zenject::DiContainer::*)(bool)>(&Zenject::DiContainer::CreateSubContainer)> {
  static const MethodInfo* get() {
    static auto* isValidating = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateSubContainer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{isValidating});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::RegisterProvider
// Il2CppName: RegisterProvider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::BindingId, ::Zenject::BindingCondition*, ::Zenject::IProvider*, bool)>(&Zenject::DiContainer::RegisterProvider)> {
  static const MethodInfo* get() {
    static auto* bindingId = &::il2cpp_utils::GetClassFromName("Zenject", "BindingId")->byval_arg;
    static auto* condition = &::il2cpp_utils::GetClassFromName("Zenject", "BindingCondition")->byval_arg;
    static auto* provider = &::il2cpp_utils::GetClassFromName("Zenject", "IProvider")->byval_arg;
    static auto* nonLazy = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "RegisterProvider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bindingId, condition, provider, nonLazy});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetProviderMatches
// Il2CppName: GetProviderMatches
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::InjectContext*, ::System::Collections::Generic::List_1<::Zenject::DiContainer::ProviderInfo*>*)>(&Zenject::DiContainer::GetProviderMatches)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "DiContainer/ProviderInfo")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetProviderMatches", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::TryGetUniqueProvider
// Il2CppName: TryGetUniqueProvider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::DiContainer::ProviderInfo* (Zenject::DiContainer::*)(::Zenject::InjectContext*)>(&Zenject::DiContainer::TryGetUniqueProvider)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "TryGetUniqueProvider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::FlattenInheritanceChain
// Il2CppName: FlattenInheritanceChain
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::List_1<::Zenject::DiContainer*>* (Zenject::DiContainer::*)()>(&Zenject::DiContainer::FlattenInheritanceChain)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "FlattenInheritanceChain", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetLocalProviders
// Il2CppName: GetLocalProviders
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::BindingId, ::System::Collections::Generic::List_1<::Zenject::DiContainer::ProviderInfo*>*)>(&Zenject::DiContainer::GetLocalProviders)> {
  static const MethodInfo* get() {
    static auto* bindingId = &::il2cpp_utils::GetClassFromName("Zenject", "BindingId")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "DiContainer/ProviderInfo")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetLocalProviders", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bindingId, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetProvidersForContract
// Il2CppName: GetProvidersForContract
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::BindingId, ::Zenject::InjectSources, ::System::Collections::Generic::List_1<::Zenject::DiContainer::ProviderInfo*>*)>(&Zenject::DiContainer::GetProvidersForContract)> {
  static const MethodInfo* get() {
    static auto* bindingId = &::il2cpp_utils::GetClassFromName("Zenject", "BindingId")->byval_arg;
    static auto* sourceType = &::il2cpp_utils::GetClassFromName("Zenject", "InjectSources")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "DiContainer/ProviderInfo")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetProvidersForContract", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bindingId, sourceType, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Install
// Il2CppName: Install
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Install
// Il2CppName: Install
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveAll
// Il2CppName: ResolveAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IList* (Zenject::DiContainer::*)(::Zenject::InjectContext*)>(&Zenject::DiContainer::ResolveAll)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveAll
// Il2CppName: ResolveAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::InjectContext*, ::System::Collections::Generic::List_1<::Il2CppObject*>*)>(&Zenject::DiContainer::ResolveAll)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CheckForInstallWarning
// Il2CppName: CheckForInstallWarning
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::InjectContext*)>(&Zenject::DiContainer::CheckForInstallWarning)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CheckForInstallWarning", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveType
// Il2CppName: ResolveType
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveType
// Il2CppName: ResolveType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Type* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::ResolveType)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveType
// Il2CppName: ResolveType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Type* (Zenject::DiContainer::*)(::Zenject::InjectContext*)>(&Zenject::DiContainer::ResolveType)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveTypeAll
// Il2CppName: ResolveTypeAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::List_1<::System::Type*>* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::ResolveTypeAll)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveTypeAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveTypeAll
// Il2CppName: ResolveTypeAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::List_1<::System::Type*>* (Zenject::DiContainer::*)(::System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::ResolveTypeAll)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveTypeAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveTypeAll
// Il2CppName: ResolveTypeAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::List_1<::System::Type*>* (Zenject::DiContainer::*)(::Zenject::InjectContext*)>(&Zenject::DiContainer::ResolveTypeAll)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveTypeAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Resolve
// Il2CppName: Resolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::Zenject::BindingId)>(&Zenject::DiContainer::Resolve)> {
  static const MethodInfo* get() {
    static auto* id = &::il2cpp_utils::GetClassFromName("Zenject", "BindingId")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Resolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{id});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Resolve
// Il2CppName: Resolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::Zenject::InjectContext*)>(&Zenject::DiContainer::Resolve)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Resolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::SafeGetInstances
// Il2CppName: SafeGetInstances
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::DiContainer::ProviderInfo*, ::Zenject::InjectContext*, ::System::Collections::Generic::List_1<::Il2CppObject*>*)>(&Zenject::DiContainer::SafeGetInstances)> {
  static const MethodInfo* get() {
    static auto* providerInfo = &::il2cpp_utils::GetClassFromName("Zenject", "DiContainer/ProviderInfo")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* instances = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "SafeGetInstances", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{providerInfo, context, instances});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Decorate
// Il2CppName: Decorate
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::GetDecoratedInstances
// Il2CppName: GetDecoratedInstances
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::IProvider*, ::Zenject::InjectContext*, ::System::Collections::Generic::List_1<::Il2CppObject*>*)>(&Zenject::DiContainer::GetDecoratedInstances)> {
  static const MethodInfo* get() {
    static auto* provider = &::il2cpp_utils::GetClassFromName("Zenject", "IProvider")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetDecoratedInstances", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{provider, context, buffer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::TryGetDecoratorProvider
// Il2CppName: TryGetDecoratorProvider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::Internal::IDecoratorProvider* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::TryGetDecoratorProvider)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "TryGetDecoratorProvider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetContainerHeirarchyDistance
// Il2CppName: GetContainerHeirarchyDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Zenject::DiContainer::*)(::Zenject::DiContainer*)>(&Zenject::DiContainer::GetContainerHeirarchyDistance)> {
  static const MethodInfo* get() {
    static auto* container = &::il2cpp_utils::GetClassFromName("Zenject", "DiContainer")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetContainerHeirarchyDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{container});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetContainerHeirarchyDistance
// Il2CppName: GetContainerHeirarchyDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Nullable_1<int> (Zenject::DiContainer::*)(::Zenject::DiContainer*, int)>(&Zenject::DiContainer::GetContainerHeirarchyDistance)> {
  static const MethodInfo* get() {
    static auto* container = &::il2cpp_utils::GetClassFromName("Zenject", "DiContainer")->byval_arg;
    static auto* depth = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetContainerHeirarchyDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{container, depth});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetDependencyContracts
// Il2CppName: GetDependencyContracts
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::GetDependencyContracts
// Il2CppName: GetDependencyContracts
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerable_1<::System::Type*>* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::GetDependencyContracts)> {
  static const MethodInfo* get() {
    static auto* contract = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetDependencyContracts", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contract});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateInternal
// Il2CppName: InstantiateInternal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, bool, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InstantiateInternal)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* autoInject = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateInternal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, autoInject, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectExplicit
// Il2CppName: InjectExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InjectExplicit)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectExplicit
// Il2CppName: InjectExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, ::System::Type*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InjectExplicit)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* injectableType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, injectableType, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CallInjectMethodsTopDown
// Il2CppName: CallInjectMethodsTopDown
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, ::System::Type*, ::Zenject::InjectTypeInfo*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::InjectContext*, ::Il2CppObject*, bool)>(&Zenject::DiContainer::CallInjectMethodsTopDown)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* injectableType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* typeInfo = &::il2cpp_utils::GetClassFromName("Zenject", "InjectTypeInfo")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* isDryRun = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CallInjectMethodsTopDown", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, injectableType, typeInfo, extraArgs, context, concreteIdentifier, isDryRun});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectMembersTopDown
// Il2CppName: InjectMembersTopDown
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, ::System::Type*, ::Zenject::InjectTypeInfo*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::InjectContext*, ::Il2CppObject*, bool)>(&Zenject::DiContainer::InjectMembersTopDown)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* injectableType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* typeInfo = &::il2cpp_utils::GetClassFromName("Zenject", "InjectTypeInfo")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* isDryRun = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectMembersTopDown", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, injectableType, typeInfo, extraArgs, context, concreteIdentifier, isDryRun});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectExplicitInternal
// Il2CppName: InjectExplicitInternal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, ::System::Type*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InjectExplicitInternal)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* injectableType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectExplicitInternal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, injectableType, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateAndParentPrefabResource
// Il2CppName: CreateAndParentPrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::StringW, ::Zenject::GameObjectCreationParameters*, ::Zenject::InjectContext*, ByRef<bool>)>(&Zenject::DiContainer::CreateAndParentPrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* shouldMakeActive = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateAndParentPrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath, gameObjectBindInfo, context, shouldMakeActive});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetPrefabAsGameObject
// Il2CppName: GetPrefabAsGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::UnityEngine::Object*)>(&Zenject::DiContainer::GetPrefabAsGameObject)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetPrefabAsGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateAndParentPrefab
// Il2CppName: CreateAndParentPrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::UnityEngine::Object*, ::Zenject::GameObjectCreationParameters*, ::Zenject::InjectContext*, ByRef<bool>)>(&Zenject::DiContainer::CreateAndParentPrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* shouldMakeActive = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateAndParentPrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab, gameObjectBindInfo, context, shouldMakeActive});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateEmptyGameObject
// Il2CppName: CreateEmptyGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::StringW)>(&Zenject::DiContainer::CreateEmptyGameObject)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateEmptyGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateEmptyGameObject
// Il2CppName: CreateEmptyGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::Zenject::GameObjectCreationParameters*, ::Zenject::InjectContext*)>(&Zenject::DiContainer::CreateEmptyGameObject)> {
  static const MethodInfo* get() {
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateEmptyGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObjectBindInfo, context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::GetTransformGroup
// Il2CppName: GetTransformGroup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Transform* (Zenject::DiContainer::*)(::Zenject::GameObjectCreationParameters*, ::Zenject::InjectContext*)>(&Zenject::DiContainer::GetTransformGroup)> {
  static const MethodInfo* get() {
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "GetTransformGroup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObjectBindInfo, context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::CreateTransformGroup
// Il2CppName: CreateTransformGroup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::StringW)>(&Zenject::DiContainer::CreateTransformGroup)> {
  static const MethodInfo* get() {
    static auto* groupName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "CreateTransformGroup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{groupName});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Instantiate
// Il2CppName: Instantiate
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Instantiate
// Il2CppName: Instantiate
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Instantiate
// Il2CppName: Instantiate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::Instantiate)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Instantiate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Instantiate
// Il2CppName: Instantiate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::Instantiate)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Instantiate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponent
// Il2CppName: InstantiateComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponent
// Il2CppName: InstantiateComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponent
// Il2CppName: InstantiateComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Component* (Zenject::DiContainer::*)(::System::Type*, ::UnityEngine::GameObject*)>(&Zenject::DiContainer::InstantiateComponent)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, gameObject});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponent
// Il2CppName: InstantiateComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Component* (Zenject::DiContainer::*)(::System::Type*, ::UnityEngine::GameObject*, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InstantiateComponent)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, gameObject, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentOnNewGameObject
// Il2CppName: InstantiateComponentOnNewGameObject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentOnNewGameObject
// Il2CppName: InstantiateComponentOnNewGameObject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentOnNewGameObject
// Il2CppName: InstantiateComponentOnNewGameObject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentOnNewGameObject
// Il2CppName: InstantiateComponentOnNewGameObject
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefab
// Il2CppName: InstantiatePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::UnityEngine::Object*)>(&Zenject::DiContainer::InstantiatePrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefab
// Il2CppName: InstantiatePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::UnityEngine::Object*, ::UnityEngine::Transform*)>(&Zenject::DiContainer::InstantiatePrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab, parentTransform});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefab
// Il2CppName: InstantiatePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::UnityEngine::Object*, ::UnityEngine::Vector3, ::UnityEngine::Quaternion, ::UnityEngine::Transform*)>(&Zenject::DiContainer::InstantiatePrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* rotation = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab, position, rotation, parentTransform});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefab
// Il2CppName: InstantiatePrefab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::UnityEngine::Object*, ::Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefab)> {
  static const MethodInfo* get() {
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefab, gameObjectBindInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResource
// Il2CppName: InstantiatePrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::StringW)>(&Zenject::DiContainer::InstantiatePrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResource
// Il2CppName: InstantiatePrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::StringW, ::UnityEngine::Transform*)>(&Zenject::DiContainer::InstantiatePrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath, parentTransform});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResource
// Il2CppName: InstantiatePrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::StringW, ::UnityEngine::Vector3, ::UnityEngine::Quaternion, ::UnityEngine::Transform*)>(&Zenject::DiContainer::InstantiatePrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* rotation = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath, position, rotation, parentTransform});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResource
// Il2CppName: InstantiatePrefabResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::GameObject* (Zenject::DiContainer::*)(::StringW, ::Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabResource)> {
  static const MethodInfo* get() {
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* creationInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{resourcePath, creationInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::UnityEngine::Object*, ::UnityEngine::Transform*, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InstantiatePrefabForComponent)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, prefab, parentTransform, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponent
// Il2CppName: InstantiatePrefabForComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::UnityEngine::Object*, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*, ::Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabForComponent)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    static auto* creationInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, prefab, extraArgs, creationInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponent
// Il2CppName: InstantiatePrefabResourceForComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::StringW, ::UnityEngine::Transform*, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InstantiatePrefabResourceForComponent)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* parentTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResourceForComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, resourcePath, parentTransform, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResource
// Il2CppName: InstantiateScriptableObjectResource
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResource
// Il2CppName: InstantiateScriptableObjectResource
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResource
// Il2CppName: InstantiateScriptableObjectResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::StringW)>(&Zenject::DiContainer::InstantiateScriptableObjectResource)> {
  static const MethodInfo* get() {
    static auto* scriptableObjectType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateScriptableObjectResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scriptableObjectType, resourcePath});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResource
// Il2CppName: InstantiateScriptableObjectResource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::StringW, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InstantiateScriptableObjectResource)> {
  static const MethodInfo* get() {
    static auto* scriptableObjectType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateScriptableObjectResource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scriptableObjectType, resourcePath, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObject
// Il2CppName: InjectGameObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::UnityEngine::GameObject*)>(&Zenject::DiContainer::InjectGameObject)> {
  static const MethodInfo* get() {
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectGameObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObject});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObjectForComponent
// Il2CppName: InjectGameObjectForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObjectForComponent
// Il2CppName: InjectGameObjectForComponent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObjectForComponent
// Il2CppName: InjectGameObjectForComponent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::UnityEngine::GameObject*, ::System::Type*, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::InjectGameObjectForComponent)> {
  static const MethodInfo* get() {
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectGameObjectForComponent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObject, componentType, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InjectGameObjectForComponentExplicit
// Il2CppName: InjectGameObjectForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Component* (Zenject::DiContainer::*)(::UnityEngine::GameObject*, ::System::Type*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InjectGameObjectForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InjectGameObjectForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObject, componentType, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Inject
// Il2CppName: Inject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*)>(&Zenject::DiContainer::Inject)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Inject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Inject
// Il2CppName: Inject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Il2CppObject*, ::System::Collections::Generic::IEnumerable_1<::Il2CppObject*>*)>(&Zenject::DiContainer::Inject)> {
  static const MethodInfo* get() {
    static auto* injectable = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Object")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Inject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{injectable, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Resolve
// Il2CppName: Resolve
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Resolve
// Il2CppName: Resolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::Resolve)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Resolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveId
// Il2CppName: ResolveId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveId
// Il2CppName: ResolveId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::ResolveId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::TryResolve
// Il2CppName: TryResolve
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::TryResolve
// Il2CppName: TryResolve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::TryResolve)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "TryResolve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::TryResolveId
// Il2CppName: TryResolveId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::TryResolveId
// Il2CppName: TryResolveId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::TryResolveId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "TryResolveId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveAll
// Il2CppName: ResolveAll
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveAll
// Il2CppName: ResolveAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IList* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::ResolveAll)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveIdAll
// Il2CppName: ResolveIdAll
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::ResolveIdAll
// Il2CppName: ResolveIdAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IList* (Zenject::DiContainer::*)(::System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::ResolveIdAll)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "ResolveIdAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindAll
// Il2CppName: UnbindAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::UnbindAll)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "UnbindAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Unbind
// Il2CppName: Unbind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Unbind
// Il2CppName: Unbind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::Unbind)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Unbind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindId
// Il2CppName: UnbindId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindId
// Il2CppName: UnbindId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(::System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::UnbindId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "UnbindId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindInterfacesTo
// Il2CppName: UnbindInterfacesTo
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindInterfacesTo
// Il2CppName: UnbindInterfacesTo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::UnbindInterfacesTo)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "UnbindInterfacesTo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Unbind
// Il2CppName: Unbind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Unbind
// Il2CppName: Unbind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(::System::Type*, ::System::Type*)>(&Zenject::DiContainer::Unbind)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Unbind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, concreteType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindId
// Il2CppName: UnbindId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::UnbindId
// Il2CppName: UnbindId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(::System::Type*, ::System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::UnbindId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "UnbindId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, concreteType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::HasBinding
// Il2CppName: HasBinding
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::HasBinding
// Il2CppName: HasBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::HasBinding)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "HasBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::HasBindingId
// Il2CppName: HasBindingId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::HasBindingId
// Il2CppName: HasBindingId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(::System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::HasBindingId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "HasBindingId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::HasBindingId
// Il2CppName: HasBindingId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(::System::Type*, ::Il2CppObject*, ::Zenject::InjectSources)>(&Zenject::DiContainer::HasBindingId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* sourceType = &::il2cpp_utils::GetClassFromName("Zenject", "InjectSources")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "HasBindingId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier, sourceType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::HasBinding
// Il2CppName: HasBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Zenject::DiContainer::*)(::Zenject::InjectContext*)>(&Zenject::DiContainer::HasBinding)> {
  static const MethodInfo* get() {
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "HasBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{context});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::FlushBindings
// Il2CppName: FlushBindings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)()>(&Zenject::DiContainer::FlushBindings)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "FlushBindings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::FinalizeBinding
// Il2CppName: FinalizeBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::Zenject::BindStatement*)>(&Zenject::DiContainer::FinalizeBinding)> {
  static const MethodInfo* get() {
    static auto* binding = &::il2cpp_utils::GetClassFromName("Zenject", "BindStatement")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "FinalizeBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{binding});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::StartBinding
// Il2CppName: StartBinding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::BindStatement* (Zenject::DiContainer::*)(bool)>(&Zenject::DiContainer::StartBinding)> {
  static const MethodInfo* get() {
    static auto* flush = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "StartBinding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{flush});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Rebind
// Il2CppName: Rebind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::RebindId
// Il2CppName: RebindId
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Rebind
// Il2CppName: Rebind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::ConcreteBinderNonGeneric* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::Rebind)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Rebind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::RebindId
// Il2CppName: RebindId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::ConcreteBinderNonGeneric* (Zenject::DiContainer::*)(::System::Type*, ::Il2CppObject*)>(&Zenject::DiContainer::RebindId)> {
  static const MethodInfo* get() {
    static auto* contractType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* identifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "RebindId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractType, identifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindNoFlush
// Il2CppName: BindNoFlush
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::ConcreteIdBinderNonGeneric* (Zenject::DiContainer::*)(::ArrayW<::System::Type*>)>(&Zenject::DiContainer::Bind)> {
  static const MethodInfo* get() {
    static auto* contractTypes = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Type"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Bind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractTypes});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::ConcreteIdBinderNonGeneric* (Zenject::DiContainer::*)(::System::Collections::Generic::IEnumerable_1<::System::Type*>*)>(&Zenject::DiContainer::Bind)> {
  static const MethodInfo* get() {
    static auto* contractTypes = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Type")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Bind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contractTypes});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInternal
// Il2CppName: BindInternal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::ConcreteIdBinderNonGeneric* (Zenject::DiContainer::*)(::Zenject::BindInfo*, ::Zenject::BindStatement*)>(&Zenject::DiContainer::BindInternal)> {
  static const MethodInfo* get() {
    static auto* bindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "BindInfo")->byval_arg;
    static auto* bindingFinalizer = &::il2cpp_utils::GetClassFromName("Zenject", "BindStatement")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInternal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bindInfo, bindingFinalizer});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::Bind
// Il2CppName: Bind
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::ConcreteIdBinderNonGeneric* (Zenject::DiContainer::*)(::System::Action_1<::Zenject::ConventionSelectTypesBinder*>*)>(&Zenject::DiContainer::Bind)> {
  static const MethodInfo* get() {
    static auto* generator = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "ConventionSelectTypesBinder")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "Bind", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{generator});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInterfacesTo
// Il2CppName: BindInterfacesTo
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindInterfacesTo
// Il2CppName: BindInterfacesTo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::FromBinderNonGeneric* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::BindInterfacesTo)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInterfacesTo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInterfacesAndSelfTo
// Il2CppName: BindInterfacesAndSelfTo
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindInterfacesAndSelfTo
// Il2CppName: BindInterfacesAndSelfTo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::FromBinderNonGeneric* (Zenject::DiContainer::*)(::System::Type*)>(&Zenject::DiContainer::BindInterfacesAndSelfTo)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInterfacesAndSelfTo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInstance
// Il2CppName: BindInstance
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindInstances
// Il2CppName: BindInstances
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::ArrayW<::Il2CppObject*>)>(&Zenject::DiContainer::BindInstances)> {
  static const MethodInfo* get() {
    static auto* instances = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Object"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInstances", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{instances});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPool
// Il2CppName: BindMemoryPool
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPool
// Il2CppName: BindMemoryPool
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPoolCustomInterface
// Il2CppName: BindMemoryPoolCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPoolCustomInterfaceNoFlush
// Il2CppName: BindMemoryPoolCustomInterfaceNoFlush
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindMemoryPoolCustomInterfaceInternal
// Il2CppName: BindMemoryPoolCustomInterfaceInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryInternal
// Il2CppName: BindFactoryInternal
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindIFactory
// Il2CppName: BindIFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactory
// Il2CppName: BindFactory
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFactoryCustomInterface
// Il2CppName: BindFactoryCustomInterface
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateExplicit
// Il2CppName: InstantiateExplicit
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateExplicit
// Il2CppName: InstantiateExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InstantiateExplicit)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateExplicit
// Il2CppName: InstantiateExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, bool, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::InjectContext*, ::Il2CppObject*)>(&Zenject::DiContainer::InstantiateExplicit)> {
  static const MethodInfo* get() {
    static auto* concreteType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* autoInject = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{concreteType, autoInject, extraArgs, context, concreteIdentifier});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateComponentExplicit
// Il2CppName: InstantiateComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Component* (Zenject::DiContainer::*)(::System::Type*, ::UnityEngine::GameObject*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InstantiateComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, gameObject, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiateScriptableObjectResourceExplicit
// Il2CppName: InstantiateScriptableObjectResourceExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::StringW, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InstantiateScriptableObjectResourceExplicit)> {
  static const MethodInfo* get() {
    static auto* scriptableObjectType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiateScriptableObjectResourceExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scriptableObjectType, resourcePath, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponentExplicit
// Il2CppName: InstantiatePrefabResourceForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::StringW, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabResourceForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* creationInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResourceForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, resourcePath, extraArgs, creationInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabResourceForComponentExplicit
// Il2CppName: InstantiatePrefabResourceForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::StringW, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::InjectContext*, ::Il2CppObject*, ::Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabResourceForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* resourcePath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* creationInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabResourceForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, resourcePath, extraArgs, context, concreteIdentifier, creationInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponentExplicit
// Il2CppName: InstantiatePrefabForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::UnityEngine::Object*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*)>(&Zenject::DiContainer::InstantiatePrefabForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, prefab, extraArgs});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponentExplicit
// Il2CppName: InstantiatePrefabForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::UnityEngine::Object*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, prefab, extraArgs, gameObjectBindInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::InstantiatePrefabForComponentExplicit
// Il2CppName: InstantiatePrefabForComponentExplicit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppObject* (Zenject::DiContainer::*)(::System::Type*, ::UnityEngine::Object*, ::System::Collections::Generic::List_1<::Zenject::TypeValuePair>*, ::Zenject::InjectContext*, ::Il2CppObject*, ::Zenject::GameObjectCreationParameters*)>(&Zenject::DiContainer::InstantiatePrefabForComponentExplicit)> {
  static const MethodInfo* get() {
    static auto* componentType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* prefab = &::il2cpp_utils::GetClassFromName("UnityEngine", "Object")->byval_arg;
    static auto* extraArgs = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Zenject", "TypeValuePair")})->byval_arg;
    static auto* context = &::il2cpp_utils::GetClassFromName("Zenject", "InjectContext")->byval_arg;
    static auto* concreteIdentifier = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* gameObjectBindInfo = &::il2cpp_utils::GetClassFromName("Zenject", "GameObjectCreationParameters")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "InstantiatePrefabForComponentExplicit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{componentType, prefab, extraArgs, context, concreteIdentifier, gameObjectBindInfo});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindExecutionOrder
// Il2CppName: BindExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindExecutionOrder
// Il2CppName: BindExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Zenject::DiContainer::*)(::System::Type*, int)>(&Zenject::DiContainer::BindExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindTickableExecutionOrder
// Il2CppName: BindTickableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindTickableExecutionOrder
// Il2CppName: BindTickableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(::System::Type*, int)>(&Zenject::DiContainer::BindTickableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindTickableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindInitializableExecutionOrder
// Il2CppName: BindInitializableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindInitializableExecutionOrder
// Il2CppName: BindInitializableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(::System::Type*, int)>(&Zenject::DiContainer::BindInitializableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindInitializableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindDisposableExecutionOrder
// Il2CppName: BindDisposableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindLateDisposableExecutionOrder
// Il2CppName: BindLateDisposableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindDisposableExecutionOrder
// Il2CppName: BindDisposableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(::System::Type*, int)>(&Zenject::DiContainer::BindDisposableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindDisposableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindLateDisposableExecutionOrder
// Il2CppName: BindLateDisposableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(::System::Type*, int)>(&Zenject::DiContainer::BindLateDisposableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindLateDisposableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindFixedTickableExecutionOrder
// Il2CppName: BindFixedTickableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindFixedTickableExecutionOrder
// Il2CppName: BindFixedTickableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(::System::Type*, int)>(&Zenject::DiContainer::BindFixedTickableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindFixedTickableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindLateTickableExecutionOrder
// Il2CppName: BindLateTickableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindLateTickableExecutionOrder
// Il2CppName: BindLateTickableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(::System::Type*, int)>(&Zenject::DiContainer::BindLateTickableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindLateTickableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
// Writing MetadataGetter for method: Zenject::DiContainer::BindPoolableExecutionOrder
// Il2CppName: BindPoolableExecutionOrder
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Zenject::DiContainer::BindPoolableExecutionOrder
// Il2CppName: BindPoolableExecutionOrder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Zenject::CopyNonLazyBinder* (Zenject::DiContainer::*)(::System::Type*, int)>(&Zenject::DiContainer::BindPoolableExecutionOrder)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* order = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Zenject::DiContainer*), "BindPoolableExecutionOrder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, order});
  }
};
