// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ComponentModel.Component
#include "System/ComponentModel/Component.hpp"
// Including type: System.ComponentModel.ISupportInitialize
#include "System/ComponentModel/ISupportInitialize.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::Timers
namespace System::Timers {
  // Forward declaring type: ElapsedEventHandler
  class ElapsedEventHandler;
}
// Forward declaring namespace: System::ComponentModel
namespace System::ComponentModel {
  // Forward declaring type: ISynchronizeInvoke
  class ISynchronizeInvoke;
  // Forward declaring type: ISite
  class ISite;
}
// Forward declaring namespace: System::Threading
namespace System::Threading {
  // Forward declaring type: Timer
  class Timer;
  // Forward declaring type: TimerCallback
  class TimerCallback;
}
// Completed forward declares
// Type namespace: System.Timers
namespace System::Timers {
  // Forward declaring type: Timer
  class Timer;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::System::Timers::Timer);
DEFINE_IL2CPP_ARG_TYPE(::System::Timers::Timer*, "System.Timers", "Timer");
// Type namespace: System.Timers
namespace System::Timers {
  // Size: 0x70
  #pragma pack(push, 1)
  // Autogenerated type: System.Timers.Timer
  // [TokenAttribute] Offset: FFFFFFFF
  // [DefaultEventAttribute] Offset: 8FE82C
  // [DefaultPropertyAttribute] Offset: 8FE82C
  class Timer : public ::System::ComponentModel::Component/*, public ::System::ComponentModel::ISupportInitialize*/ {
    public:
    public:
    // private System.Double interval
    // Size: 0x8
    // Offset: 0x28
    double interval;
    // Field size check
    static_assert(sizeof(double) == 0x8);
    // private System.Boolean enabled
    // Size: 0x1
    // Offset: 0x30
    bool enabled;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean initializing
    // Size: 0x1
    // Offset: 0x31
    bool initializing;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean delayedEnable
    // Size: 0x1
    // Offset: 0x32
    bool delayedEnable;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: delayedEnable and: onIntervalElapsed
    char __padding3[0x5] = {};
    // private System.Timers.ElapsedEventHandler onIntervalElapsed
    // Size: 0x8
    // Offset: 0x38
    ::System::Timers::ElapsedEventHandler* onIntervalElapsed;
    // Field size check
    static_assert(sizeof(::System::Timers::ElapsedEventHandler*) == 0x8);
    // private System.Boolean autoReset
    // Size: 0x1
    // Offset: 0x40
    bool autoReset;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: autoReset and: synchronizingObject
    char __padding5[0x7] = {};
    // private System.ComponentModel.ISynchronizeInvoke synchronizingObject
    // Size: 0x8
    // Offset: 0x48
    ::System::ComponentModel::ISynchronizeInvoke* synchronizingObject;
    // Field size check
    static_assert(sizeof(::System::ComponentModel::ISynchronizeInvoke*) == 0x8);
    // private System.Boolean disposed
    // Size: 0x1
    // Offset: 0x50
    bool disposed;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: disposed and: timer
    char __padding7[0x7] = {};
    // private System.Threading.Timer timer
    // Size: 0x8
    // Offset: 0x58
    ::System::Threading::Timer* timer;
    // Field size check
    static_assert(sizeof(::System::Threading::Timer*) == 0x8);
    // private System.Threading.TimerCallback callback
    // Size: 0x8
    // Offset: 0x60
    ::System::Threading::TimerCallback* callback;
    // Field size check
    static_assert(sizeof(::System::Threading::TimerCallback*) == 0x8);
    // private System.Object cookie
    // Size: 0x8
    // Offset: 0x68
    ::Il2CppObject* cookie;
    // Field size check
    static_assert(sizeof(::Il2CppObject*) == 0x8);
    public:
    // Creating interface conversion operator: operator ::System::ComponentModel::ISupportInitialize
    operator ::System::ComponentModel::ISupportInitialize() noexcept {
      return *reinterpret_cast<::System::ComponentModel::ISupportInitialize*>(this);
    }
    // Get instance field reference: private System.Double interval
    [[deprecated("Use field access instead!")]] double& dyn_interval();
    // Get instance field reference: private System.Boolean enabled
    [[deprecated("Use field access instead!")]] bool& dyn_enabled();
    // Get instance field reference: private System.Boolean initializing
    [[deprecated("Use field access instead!")]] bool& dyn_initializing();
    // Get instance field reference: private System.Boolean delayedEnable
    [[deprecated("Use field access instead!")]] bool& dyn_delayedEnable();
    // Get instance field reference: private System.Timers.ElapsedEventHandler onIntervalElapsed
    [[deprecated("Use field access instead!")]] ::System::Timers::ElapsedEventHandler*& dyn_onIntervalElapsed();
    // Get instance field reference: private System.Boolean autoReset
    [[deprecated("Use field access instead!")]] bool& dyn_autoReset();
    // Get instance field reference: private System.ComponentModel.ISynchronizeInvoke synchronizingObject
    [[deprecated("Use field access instead!")]] ::System::ComponentModel::ISynchronizeInvoke*& dyn_synchronizingObject();
    // Get instance field reference: private System.Boolean disposed
    [[deprecated("Use field access instead!")]] bool& dyn_disposed();
    // Get instance field reference: private System.Threading.Timer timer
    [[deprecated("Use field access instead!")]] ::System::Threading::Timer*& dyn_timer();
    // Get instance field reference: private System.Threading.TimerCallback callback
    [[deprecated("Use field access instead!")]] ::System::Threading::TimerCallback*& dyn_callback();
    // Get instance field reference: private System.Object cookie
    [[deprecated("Use field access instead!")]] ::Il2CppObject*& dyn_cookie();
    // public System.Void set_Enabled(System.Boolean value)
    // Offset: 0x10F1F68
    void set_Enabled(bool value);
    // public System.ComponentModel.ISynchronizeInvoke get_SynchronizingObject()
    // Offset: 0x10F22B4
    ::System::ComponentModel::ISynchronizeInvoke* get_SynchronizingObject();
    // public System.Void add_Elapsed(System.Timers.ElapsedEventHandler value)
    // Offset: 0x10F2178
    void add_Elapsed(::System::Timers::ElapsedEventHandler* value);
    // public System.Void remove_Elapsed(System.Timers.ElapsedEventHandler value)
    // Offset: 0x10F21F8
    void remove_Elapsed(::System::Timers::ElapsedEventHandler* value);
    // public System.Void .ctor(System.Double interval)
    // Offset: 0x10F1C08
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Timer* New_ctor(double interval) {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::Timers::Timer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Timer*, creationType>(interval)));
    }
    // static private System.Int32 CalculateRoundedInterval(System.Double interval, System.Boolean argumentCheck)
    // Offset: 0x10F1D4C
    static int CalculateRoundedInterval(double interval, bool argumentCheck);
    // private System.Void UpdateTimer()
    // Offset: 0x10F212C
    void UpdateTimer();
    // public System.Void BeginInit()
    // Offset: 0x10F2440
    void BeginInit();
    // public System.Void Close()
    // Offset: 0x10F2480
    void Close();
    // public System.Void EndInit()
    // Offset: 0x10F2508
    void EndInit();
    // private System.Void MyTimerCallback(System.Object state)
    // Offset: 0x10F2514
    void MyTimerCallback(::Il2CppObject* state);
    // public override System.ComponentModel.ISite get_Site()
    // Offset: 0x10F22AC
    // Implemented from: System.ComponentModel.Component
    // Base method: System.ComponentModel.ISite Component::get_Site()
    ::System::ComponentModel::ISite* get_Site();
    // public override System.Void set_Site(System.ComponentModel.ISite value)
    // Offset: 0x10F2278
    // Implemented from: System.ComponentModel.Component
    // Base method: System.Void Component::set_Site(System.ComponentModel.ISite value)
    void set_Site(::System::ComponentModel::ISite* value);
    // public System.Void .ctor()
    // Offset: 0x10F1B54
    // Implemented from: System.ComponentModel.Component
    // Base method: System.Void Component::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Timer* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::Timers::Timer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Timer*, creationType>()));
    }
    // protected override System.Void Dispose(System.Boolean disposing)
    // Offset: 0x10F24B8
    // Implemented from: System.ComponentModel.Component
    // Base method: System.Void Component::Dispose(System.Boolean disposing)
    void Dispose(bool disposing);
  }; // System.Timers.Timer
  #pragma pack(pop)
  static check_size<sizeof(Timer), 104 + sizeof(::Il2CppObject*)> __System_Timers_TimerSizeCheck;
  static_assert(sizeof(Timer) == 0x70);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: System::Timers::Timer::set_Enabled
// Il2CppName: set_Enabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)(bool)>(&System::Timers::Timer::set_Enabled)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "set_Enabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::get_SynchronizingObject
// Il2CppName: get_SynchronizingObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::ComponentModel::ISynchronizeInvoke* (System::Timers::Timer::*)()>(&System::Timers::Timer::get_SynchronizingObject)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "get_SynchronizingObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::add_Elapsed
// Il2CppName: add_Elapsed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)(::System::Timers::ElapsedEventHandler*)>(&System::Timers::Timer::add_Elapsed)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System.Timers", "ElapsedEventHandler")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "add_Elapsed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::remove_Elapsed
// Il2CppName: remove_Elapsed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)(::System::Timers::ElapsedEventHandler*)>(&System::Timers::Timer::remove_Elapsed)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System.Timers", "ElapsedEventHandler")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "remove_Elapsed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: System::Timers::Timer::CalculateRoundedInterval
// Il2CppName: CalculateRoundedInterval
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(double, bool)>(&System::Timers::Timer::CalculateRoundedInterval)> {
  static const MethodInfo* get() {
    static auto* interval = &::il2cpp_utils::GetClassFromName("System", "Double")->byval_arg;
    static auto* argumentCheck = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "CalculateRoundedInterval", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{interval, argumentCheck});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::UpdateTimer
// Il2CppName: UpdateTimer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)()>(&System::Timers::Timer::UpdateTimer)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "UpdateTimer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::BeginInit
// Il2CppName: BeginInit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)()>(&System::Timers::Timer::BeginInit)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "BeginInit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::Close
// Il2CppName: Close
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)()>(&System::Timers::Timer::Close)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "Close", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::EndInit
// Il2CppName: EndInit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)()>(&System::Timers::Timer::EndInit)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "EndInit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::MyTimerCallback
// Il2CppName: MyTimerCallback
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)(::Il2CppObject*)>(&System::Timers::Timer::MyTimerCallback)> {
  static const MethodInfo* get() {
    static auto* state = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "MyTimerCallback", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{state});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::get_Site
// Il2CppName: get_Site
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::ComponentModel::ISite* (System::Timers::Timer::*)()>(&System::Timers::Timer::get_Site)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "get_Site", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::set_Site
// Il2CppName: set_Site
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)(::System::ComponentModel::ISite*)>(&System::Timers::Timer::set_Site)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System.ComponentModel", "ISite")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "set_Site", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: System::Timers::Timer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: System::Timers::Timer::Dispose
// Il2CppName: Dispose
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Timers::Timer::*)(bool)>(&System::Timers::Timer::Dispose)> {
  static const MethodInfo* get() {
    static auto* disposing = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Timers::Timer*), "Dispose", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{disposing});
  }
};
