// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "extern/beatsaber-hook/shared/utils/typedefs.h"
// Including type: System.IDisposable
#include "System/IDisposable.hpp"
// Including type: System.Int32
#include "System/Int32.hpp"
// Including type: System.UInt32
#include "System/UInt32.hpp"
// Including type: System.Threading.LockRecursionPolicy
#include "System/Threading/LockRecursionPolicy.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "extern/beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::Threading
namespace System::Threading {
  // Forward declaring type: EventWaitHandle
  class EventWaitHandle;
  // Forward declaring type: ReaderWriterCount
  class ReaderWriterCount;
}
// Completed forward declares
// Type namespace: System.Threading
namespace System::Threading {
  // Size: 0x69
  #pragma pack(push, 1)
  // Autogenerated type: System.Threading.ReaderWriterLockSlim
  // [] Offset: FFFFFFFF
  class ReaderWriterLockSlim : public ::Il2CppObject/*, public System::IDisposable*/ {
    public:
    // Nested type: System::Threading::ReaderWriterLockSlim::TimeoutTracker
    struct TimeoutTracker;
    // private System.Boolean fIsReentrant
    // Size: 0x1
    // Offset: 0x10
    bool fIsReentrant;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: fIsReentrant and: myLock
    char __padding0[0x3] = {};
    // private System.Int32 myLock
    // Size: 0x4
    // Offset: 0x14
    int myLock;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.UInt32 numWriteWaiters
    // Size: 0x4
    // Offset: 0x18
    uint numWriteWaiters;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.UInt32 numReadWaiters
    // Size: 0x4
    // Offset: 0x1C
    uint numReadWaiters;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.UInt32 numWriteUpgradeWaiters
    // Size: 0x4
    // Offset: 0x20
    uint numWriteUpgradeWaiters;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.UInt32 numUpgradeWaiters
    // Size: 0x4
    // Offset: 0x24
    uint numUpgradeWaiters;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.Boolean fNoWaiters
    // Size: 0x1
    // Offset: 0x28
    bool fNoWaiters;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: fNoWaiters and: upgradeLockOwnerId
    char __padding6[0x3] = {};
    // private System.Int32 upgradeLockOwnerId
    // Size: 0x4
    // Offset: 0x2C
    int upgradeLockOwnerId;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 writeLockOwnerId
    // Size: 0x4
    // Offset: 0x30
    int writeLockOwnerId;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: writeLockOwnerId and: writeEvent
    char __padding8[0x4] = {};
    // private System.Threading.EventWaitHandle writeEvent
    // Size: 0x8
    // Offset: 0x38
    System::Threading::EventWaitHandle* writeEvent;
    // Field size check
    static_assert(sizeof(System::Threading::EventWaitHandle*) == 0x8);
    // private System.Threading.EventWaitHandle readEvent
    // Size: 0x8
    // Offset: 0x40
    System::Threading::EventWaitHandle* readEvent;
    // Field size check
    static_assert(sizeof(System::Threading::EventWaitHandle*) == 0x8);
    // private System.Threading.EventWaitHandle upgradeEvent
    // Size: 0x8
    // Offset: 0x48
    System::Threading::EventWaitHandle* upgradeEvent;
    // Field size check
    static_assert(sizeof(System::Threading::EventWaitHandle*) == 0x8);
    // private System.Threading.EventWaitHandle waitUpgradeEvent
    // Size: 0x8
    // Offset: 0x50
    System::Threading::EventWaitHandle* waitUpgradeEvent;
    // Field size check
    static_assert(sizeof(System::Threading::EventWaitHandle*) == 0x8);
    // private System.Int64 lockID
    // Size: 0x8
    // Offset: 0x58
    int64_t lockID;
    // Field size check
    static_assert(sizeof(int64_t) == 0x8);
    // private System.Boolean fUpgradeThreadHoldingRead
    // Size: 0x1
    // Offset: 0x60
    bool fUpgradeThreadHoldingRead;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: fUpgradeThreadHoldingRead and: owners
    char __padding14[0x3] = {};
    // private System.UInt32 owners
    // Size: 0x4
    // Offset: 0x64
    uint owners;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.Boolean fDisposed
    // Size: 0x1
    // Offset: 0x68
    bool fDisposed;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Creating value type constructor for type: ReaderWriterLockSlim
    ReaderWriterLockSlim(bool fIsReentrant_ = {}, int myLock_ = {}, uint numWriteWaiters_ = {}, uint numReadWaiters_ = {}, uint numWriteUpgradeWaiters_ = {}, uint numUpgradeWaiters_ = {}, bool fNoWaiters_ = {}, int upgradeLockOwnerId_ = {}, int writeLockOwnerId_ = {}, System::Threading::EventWaitHandle* writeEvent_ = {}, System::Threading::EventWaitHandle* readEvent_ = {}, System::Threading::EventWaitHandle* upgradeEvent_ = {}, System::Threading::EventWaitHandle* waitUpgradeEvent_ = {}, int64_t lockID_ = {}, bool fUpgradeThreadHoldingRead_ = {}, uint owners_ = {}, bool fDisposed_ = {}) noexcept : fIsReentrant{fIsReentrant_}, myLock{myLock_}, numWriteWaiters{numWriteWaiters_}, numReadWaiters{numReadWaiters_}, numWriteUpgradeWaiters{numWriteUpgradeWaiters_}, numUpgradeWaiters{numUpgradeWaiters_}, fNoWaiters{fNoWaiters_}, upgradeLockOwnerId{upgradeLockOwnerId_}, writeLockOwnerId{writeLockOwnerId_}, writeEvent{writeEvent_}, readEvent{readEvent_}, upgradeEvent{upgradeEvent_}, waitUpgradeEvent{waitUpgradeEvent_}, lockID{lockID_}, fUpgradeThreadHoldingRead{fUpgradeThreadHoldingRead_}, owners{owners_}, fDisposed{fDisposed_} {}
    // Creating interface conversion operator: operator System::IDisposable
    operator System::IDisposable() noexcept {
      return *reinterpret_cast<System::IDisposable*>(this);
    }
    // static field const value: static private System.Int32 LockSpinCycles
    static constexpr const int LockSpinCycles = 20;
    // Get static field: static private System.Int32 LockSpinCycles
    static int _get_LockSpinCycles();
    // Set static field: static private System.Int32 LockSpinCycles
    static void _set_LockSpinCycles(int value);
    // static field const value: static private System.Int32 LockSpinCount
    static constexpr const int LockSpinCount = 10;
    // Get static field: static private System.Int32 LockSpinCount
    static int _get_LockSpinCount();
    // Set static field: static private System.Int32 LockSpinCount
    static void _set_LockSpinCount(int value);
    // static field const value: static private System.Int32 LockSleep0Count
    static constexpr const int LockSleep0Count = 5;
    // Get static field: static private System.Int32 LockSleep0Count
    static int _get_LockSleep0Count();
    // Set static field: static private System.Int32 LockSleep0Count
    static void _set_LockSleep0Count(int value);
    // Get static field: static private System.Int64 s_nextLockID
    static int64_t _get_s_nextLockID();
    // Set static field: static private System.Int64 s_nextLockID
    static void _set_s_nextLockID(int64_t value);
    // [ThreadStaticAttribute] Offset: 0xD479E4
    // Get static field: static private System.Threading.ReaderWriterCount t_rwc
    static System::Threading::ReaderWriterCount* _get_t_rwc();
    // Set static field: static private System.Threading.ReaderWriterCount t_rwc
    static void _set_t_rwc(System::Threading::ReaderWriterCount* value);
    // static field const value: static private System.Int32 MaxSpinCount
    static constexpr const int MaxSpinCount = 20;
    // Get static field: static private System.Int32 MaxSpinCount
    static int _get_MaxSpinCount();
    // Set static field: static private System.Int32 MaxSpinCount
    static void _set_MaxSpinCount(int value);
    // static field const value: static private System.UInt32 WRITER_HELD
    static constexpr const uint WRITER_HELD = 2147483648u;
    // Get static field: static private System.UInt32 WRITER_HELD
    static uint _get_WRITER_HELD();
    // Set static field: static private System.UInt32 WRITER_HELD
    static void _set_WRITER_HELD(uint value);
    // static field const value: static private System.UInt32 WAITING_WRITERS
    static constexpr const uint WAITING_WRITERS = 1073741824u;
    // Get static field: static private System.UInt32 WAITING_WRITERS
    static uint _get_WAITING_WRITERS();
    // Set static field: static private System.UInt32 WAITING_WRITERS
    static void _set_WAITING_WRITERS(uint value);
    // static field const value: static private System.UInt32 WAITING_UPGRADER
    static constexpr const uint WAITING_UPGRADER = 536870912u;
    // Get static field: static private System.UInt32 WAITING_UPGRADER
    static uint _get_WAITING_UPGRADER();
    // Set static field: static private System.UInt32 WAITING_UPGRADER
    static void _set_WAITING_UPGRADER(uint value);
    // static field const value: static private System.UInt32 MAX_READER
    static constexpr const uint MAX_READER = 268435454u;
    // Get static field: static private System.UInt32 MAX_READER
    static uint _get_MAX_READER();
    // Set static field: static private System.UInt32 MAX_READER
    static void _set_MAX_READER(uint value);
    // static field const value: static private System.UInt32 READER_MASK
    static constexpr const uint READER_MASK = 268435455u;
    // Get static field: static private System.UInt32 READER_MASK
    static uint _get_READER_MASK();
    // Set static field: static private System.UInt32 READER_MASK
    static void _set_READER_MASK(uint value);
    // private System.Void InitializeThreadCounts()
    // Offset: 0x19B81B8
    void InitializeThreadCounts();
    // public System.Void .ctor(System.Threading.LockRecursionPolicy recursionPolicy)
    // Offset: 0x19B81C4
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static ReaderWriterLockSlim* New_ctor(System::Threading::LockRecursionPolicy recursionPolicy) {
      static auto ___internal__logger = ::Logger::get().WithContext("System::Threading::ReaderWriterLockSlim::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<ReaderWriterLockSlim*, creationType>(recursionPolicy)));
    }
    // static private System.Boolean IsRWEntryEmpty(System.Threading.ReaderWriterCount rwc)
    // Offset: 0x19B8258
    static bool IsRWEntryEmpty(System::Threading::ReaderWriterCount* rwc);
    // private System.Boolean IsRwHashEntryChanged(System.Threading.ReaderWriterCount lrwc)
    // Offset: 0x19B8298
    bool IsRwHashEntryChanged(System::Threading::ReaderWriterCount* lrwc);
    // private System.Threading.ReaderWriterCount GetThreadRWCount(System.Boolean dontAllocate)
    // Offset: 0x19B82BC
    System::Threading::ReaderWriterCount* GetThreadRWCount(bool dontAllocate);
    // public System.Void EnterReadLock()
    // Offset: 0x19B83EC
    void EnterReadLock();
    // public System.Boolean TryEnterReadLock(System.Int32 millisecondsTimeout)
    // Offset: 0x19B8434
    bool TryEnterReadLock(int millisecondsTimeout);
    // private System.Boolean TryEnterReadLock(System.Threading.ReaderWriterLockSlim/TimeoutTracker timeout)
    // Offset: 0x19B8520
    bool TryEnterReadLock(System::Threading::ReaderWriterLockSlim::TimeoutTracker timeout);
    // private System.Boolean TryEnterReadLockCore(System.Threading.ReaderWriterLockSlim/TimeoutTracker timeout)
    // Offset: 0x19B8524
    bool TryEnterReadLockCore(System::Threading::ReaderWriterLockSlim::TimeoutTracker timeout);
    // public System.Void EnterWriteLock()
    // Offset: 0x19B8BEC
    void EnterWriteLock();
    // public System.Boolean TryEnterWriteLock(System.Int32 millisecondsTimeout)
    // Offset: 0x19B8C34
    bool TryEnterWriteLock(int millisecondsTimeout);
    // private System.Boolean TryEnterWriteLock(System.Threading.ReaderWriterLockSlim/TimeoutTracker timeout)
    // Offset: 0x19B8C6C
    bool TryEnterWriteLock(System::Threading::ReaderWriterLockSlim::TimeoutTracker timeout);
    // private System.Boolean TryEnterWriteLockCore(System.Threading.ReaderWriterLockSlim/TimeoutTracker timeout)
    // Offset: 0x19B8C70
    bool TryEnterWriteLockCore(System::Threading::ReaderWriterLockSlim::TimeoutTracker timeout);
    // public System.Void EnterUpgradeableReadLock()
    // Offset: 0x19B90A0
    void EnterUpgradeableReadLock();
    // public System.Boolean TryEnterUpgradeableReadLock(System.Int32 millisecondsTimeout)
    // Offset: 0x19B90E8
    bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    // private System.Boolean TryEnterUpgradeableReadLock(System.Threading.ReaderWriterLockSlim/TimeoutTracker timeout)
    // Offset: 0x19B9120
    bool TryEnterUpgradeableReadLock(System::Threading::ReaderWriterLockSlim::TimeoutTracker timeout);
    // private System.Boolean TryEnterUpgradeableReadLockCore(System.Threading.ReaderWriterLockSlim/TimeoutTracker timeout)
    // Offset: 0x19B9124
    bool TryEnterUpgradeableReadLockCore(System::Threading::ReaderWriterLockSlim::TimeoutTracker timeout);
    // public System.Void ExitReadLock()
    // Offset: 0x19B9498
    void ExitReadLock();
    // public System.Void ExitWriteLock()
    // Offset: 0x19B965C
    void ExitWriteLock();
    // public System.Void ExitUpgradeableReadLock()
    // Offset: 0x19B97CC
    void ExitUpgradeableReadLock();
    // private System.Void LazyCreateEvent(ref System.Threading.EventWaitHandle waitEvent, System.Boolean makeAutoResetEvent)
    // Offset: 0x19B8944
    void LazyCreateEvent(System::Threading::EventWaitHandle*& waitEvent, bool makeAutoResetEvent);
    // private System.Boolean WaitOnEvent(System.Threading.EventWaitHandle waitEvent, ref System.UInt32 numWaiters, System.Threading.ReaderWriterLockSlim/TimeoutTracker timeout, System.Boolean isWriteWaiter)
    // Offset: 0x19B8A44
    bool WaitOnEvent(System::Threading::EventWaitHandle* waitEvent, uint& numWaiters, System::Threading::ReaderWriterLockSlim::TimeoutTracker timeout, bool isWriteWaiter);
    // private System.Void ExitAndWakeUpAppropriateWaiters()
    // Offset: 0x19B9620
    void ExitAndWakeUpAppropriateWaiters();
    // private System.Void ExitAndWakeUpAppropriateWaitersPreferringWriters()
    // Offset: 0x19B9AB8
    void ExitAndWakeUpAppropriateWaitersPreferringWriters();
    // private System.Void ExitAndWakeUpAppropriateReadWaiters()
    // Offset: 0x19B9A14
    void ExitAndWakeUpAppropriateReadWaiters();
    // private System.Boolean IsWriterAcquired()
    // Offset: 0x19B9074
    bool IsWriterAcquired();
    // private System.Void SetWriterAcquired()
    // Offset: 0x19B9084
    void SetWriterAcquired();
    // private System.Void ClearWriterAcquired()
    // Offset: 0x19B97BC
    void ClearWriterAcquired();
    // private System.Void SetWritersWaiting()
    // Offset: 0x19B9980
    void SetWritersWaiting();
    // private System.Void ClearWritersWaiting()
    // Offset: 0x19B99F4
    void ClearWritersWaiting();
    // private System.Void SetUpgraderWaiting()
    // Offset: 0x19B9990
    void SetUpgraderWaiting();
    // private System.Void ClearUpgraderWaiting()
    // Offset: 0x19B9A04
    void ClearUpgraderWaiting();
    // private System.UInt32 GetNumReaders()
    // Offset: 0x19B9094
    uint GetNumReaders();
    // private System.Void EnterMyLock()
    // Offset: 0x19B9B50
    void EnterMyLock();
    // private System.Void EnterMyLockSpin()
    // Offset: 0x19B9B94
    void EnterMyLockSpin();
    // private System.Void ExitMyLock()
    // Offset: 0x19B88A0
    void ExitMyLock();
    // static private System.Void SpinWait(System.Int32 SpinCount)
    // Offset: 0x19B88E0
    static void SpinWait(int SpinCount);
    // private System.Void Dispose(System.Boolean disposing)
    // Offset: 0x19B9C40
    void Dispose(bool disposing);
    // public System.Boolean get_IsReadLockHeld()
    // Offset: 0x19B9DE4
    bool get_IsReadLockHeld();
    // public System.Boolean get_IsUpgradeableReadLockHeld()
    // Offset: 0x19B9E00
    bool get_IsUpgradeableReadLockHeld();
    // public System.Boolean get_IsWriteLockHeld()
    // Offset: 0x19B9E1C
    bool get_IsWriteLockHeld();
    // public System.Int32 get_RecursiveReadCount()
    // Offset: 0x19B9E38
    int get_RecursiveReadCount();
    // public System.Int32 get_RecursiveUpgradeCount()
    // Offset: 0x19B9EB4
    int get_RecursiveUpgradeCount();
    // public System.Int32 get_RecursiveWriteCount()
    // Offset: 0x19B9F60
    int get_RecursiveWriteCount();
    // public System.Int32 get_WaitingReadCount()
    // Offset: 0x19BA00C
    int get_WaitingReadCount();
    // public System.Int32 get_WaitingUpgradeCount()
    // Offset: 0x19BA014
    int get_WaitingUpgradeCount();
    // public System.Int32 get_WaitingWriteCount()
    // Offset: 0x19BA01C
    int get_WaitingWriteCount();
    // public System.Void Dispose()
    // Offset: 0x19B9C38
    // Implemented from: System.IDisposable
    // Base method: System.Void IDisposable::Dispose()
    void Dispose();
    // Creating proxy method: System_IDisposable_Dispose
    // Maps to method: Dispose
    void System_IDisposable_Dispose();
  }; // System.Threading.ReaderWriterLockSlim
  static check_size<sizeof(ReaderWriterLockSlim), 104 + sizeof(bool)> __System_Threading_ReaderWriterLockSlimSizeCheck;
  static_assert(sizeof(ReaderWriterLockSlim) == 0x69);
}
#pragma pack(pop)
DEFINE_IL2CPP_ARG_TYPE(System::Threading::ReaderWriterLockSlim*, "System.Threading", "ReaderWriterLockSlim");
