// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: HoudiniEngineUnity.HAPI_GeoInfo
#include "HoudiniEngineUnity/HAPI_GeoInfo.hpp"
// Including type: HoudiniEngineUnity.HAPI_PartInfo
#include "HoudiniEngineUnity/HAPI_PartInfo.hpp"
// Including type: HoudiniEngineUnity.HAPI_AttributeInfo
#include "HoudiniEngineUnity/HAPI_AttributeInfo.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: HoudiniEngineUnity
namespace HoudiniEngineUnity {
  // Forward declaring type: HEU_UnityMaterialInfo
  class HEU_UnityMaterialInfo;
  // Forward declaring type: HEU_MaterialData
  class HEU_MaterialData;
  // Forward declaring type: HEU_MeshIndexFormat
  class HEU_MeshIndexFormat;
  // Forward declaring type: HEU_SessionBase
  class HEU_SessionBase;
  // Forward declaring type: HEU_GeneratedOutputData
  class HEU_GeneratedOutputData;
  // Forward declaring type: HEU_GeoGroup
  class HEU_GeoGroup;
  // Forward declaring type: HEU_GeneratedOutput
  class HEU_GeneratedOutput;
  // Forward declaring type: HEU_MeshData
  class HEU_MeshData;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: MeshTopology
  struct MeshTopology;
}
// Completed forward declares
// Type namespace: HoudiniEngineUnity
namespace HoudiniEngineUnity {
  // Forward declaring type: HEU_GenerateGeoCache
  class HEU_GenerateGeoCache;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::HoudiniEngineUnity::HEU_GenerateGeoCache);
DEFINE_IL2CPP_ARG_TYPE(::HoudiniEngineUnity::HEU_GenerateGeoCache*, "HoudiniEngineUnity", "HEU_GenerateGeoCache");
// Type namespace: HoudiniEngineUnity
namespace HoudiniEngineUnity {
  // Size: 0x2B8
  #pragma pack(push, 1)
  // Autogenerated type: HoudiniEngineUnity.HEU_GenerateGeoCache
  // [TokenAttribute] Offset: FFFFFFFF
  class HEU_GenerateGeoCache : public ::Il2CppObject {
    public:
    // Nested type: ::HoudiniEngineUnity::HEU_GenerateGeoCache::HEU_ColliderInfo
    class HEU_ColliderInfo;
    // Nested type: ::HoudiniEngineUnity::HEU_GenerateGeoCache::$$c
    class $$c;
    public:
    // private System.Int32 <AssetID>k__BackingField
    // Size: 0x4
    // Offset: 0x10
    int AssetID;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public HoudiniEngineUnity.HAPI_GeoInfo _geoInfo
    // Size: 0x24
    // Offset: 0x14
    ::HoudiniEngineUnity::HAPI_GeoInfo geoInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_GeoInfo) == 0x24);
    // public HoudiniEngineUnity.HAPI_PartInfo _partInfo
    // Size: 0x2D
    // Offset: 0x38
    ::HoudiniEngineUnity::HAPI_PartInfo partInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_PartInfo) == 0x2D);
    // Padding between fields: partInfo and: partName
    char __padding2[0x3] = {};
    // public System.String _partName
    // Size: 0x8
    // Offset: 0x68
    ::StringW partName;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public System.Int32[] _vertexList
    // Size: 0x8
    // Offset: 0x70
    ::ArrayW<int> vertexList;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Int32[] _faceCounts
    // Size: 0x8
    // Offset: 0x78
    ::ArrayW<int> faceCounts;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Int32[] _houdiniMaterialIDs
    // Size: 0x8
    // Offset: 0x80
    ::ArrayW<int> houdiniMaterialIDs;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Boolean _singleFaceUnityMaterial
    // Size: 0x1
    // Offset: 0x88
    bool singleFaceUnityMaterial;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean _singleFaceHoudiniMaterial
    // Size: 0x1
    // Offset: 0x89
    bool singleFaceHoudiniMaterial;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: singleFaceHoudiniMaterial and: unityMaterialInfos
    char __padding8[0x6] = {};
    // public System.Collections.Generic.Dictionary`2<System.Int32,HoudiniEngineUnity.HEU_UnityMaterialInfo> _unityMaterialInfos
    // Size: 0x8
    // Offset: 0x90
    ::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_UnityMaterialInfo*>* unityMaterialInfos;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_UnityMaterialInfo*>*) == 0x8);
    // public HoudiniEngineUnity.HAPI_AttributeInfo _unityMaterialAttrInfo
    // Size: 0x24
    // Offset: 0x98
    ::HoudiniEngineUnity::HAPI_AttributeInfo unityMaterialAttrInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_AttributeInfo) == 0x24);
    // Padding between fields: unityMaterialAttrInfo and: unityMaterialAttrName
    char __padding10[0x4] = {};
    // public System.Int32[] _unityMaterialAttrName
    // Size: 0x8
    // Offset: 0xC0
    ::ArrayW<int> unityMaterialAttrName;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Collections.Generic.Dictionary`2<System.Int32,System.String> _unityMaterialAttrStringsMap
    // Size: 0x8
    // Offset: 0xC8
    ::System::Collections::Generic::Dictionary_2<int, ::StringW>* unityMaterialAttrStringsMap;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<int, ::StringW>*) == 0x8);
    // public HoudiniEngineUnity.HAPI_AttributeInfo _substanceMaterialAttrNameInfo
    // Size: 0x24
    // Offset: 0xD0
    ::HoudiniEngineUnity::HAPI_AttributeInfo substanceMaterialAttrNameInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_AttributeInfo) == 0x24);
    // Padding between fields: substanceMaterialAttrNameInfo and: substanceMaterialAttrName
    char __padding13[0x4] = {};
    // public System.Int32[] _substanceMaterialAttrName
    // Size: 0x8
    // Offset: 0xF8
    ::ArrayW<int> substanceMaterialAttrName;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Collections.Generic.Dictionary`2<System.Int32,System.String> _substanceMaterialAttrStringsMap
    // Size: 0x8
    // Offset: 0x100
    ::System::Collections::Generic::Dictionary_2<int, ::StringW>* substanceMaterialAttrStringsMap;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<int, ::StringW>*) == 0x8);
    // public HoudiniEngineUnity.HAPI_AttributeInfo _substanceMaterialAttrIndexInfo
    // Size: 0x24
    // Offset: 0x108
    ::HoudiniEngineUnity::HAPI_AttributeInfo substanceMaterialAttrIndexInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_AttributeInfo) == 0x24);
    // Padding between fields: substanceMaterialAttrIndexInfo and: substanceMaterialAttrIndex
    char __padding16[0x4] = {};
    // public System.Int32[] _substanceMaterialAttrIndex
    // Size: 0x8
    // Offset: 0x130
    ::ArrayW<int> substanceMaterialAttrIndex;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_MaterialData> _inUseMaterials
    // Size: 0x8
    // Offset: 0x138
    ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_MaterialData*>* inUseMaterials;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_MaterialData*>*) == 0x8);
    // public HoudiniEngineUnity.HAPI_AttributeInfo _posAttrInfo
    // Size: 0x24
    // Offset: 0x140
    ::HoudiniEngineUnity::HAPI_AttributeInfo posAttrInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_AttributeInfo) == 0x24);
    // Padding between fields: posAttrInfo and: uvsAttrInfo
    char __padding19[0x4] = {};
    // public HoudiniEngineUnity.HAPI_AttributeInfo[] _uvsAttrInfo
    // Size: 0x8
    // Offset: 0x168
    ::ArrayW<::HoudiniEngineUnity::HAPI_AttributeInfo> uvsAttrInfo;
    // Field size check
    static_assert(sizeof(::ArrayW<::HoudiniEngineUnity::HAPI_AttributeInfo>) == 0x8);
    // public HoudiniEngineUnity.HAPI_AttributeInfo _normalAttrInfo
    // Size: 0x24
    // Offset: 0x170
    ::HoudiniEngineUnity::HAPI_AttributeInfo normalAttrInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_AttributeInfo) == 0x24);
    // Padding between fields: normalAttrInfo and: colorAttrInfo
    char __padding21[0x4] = {};
    // public HoudiniEngineUnity.HAPI_AttributeInfo _colorAttrInfo
    // Size: 0x24
    // Offset: 0x198
    ::HoudiniEngineUnity::HAPI_AttributeInfo colorAttrInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_AttributeInfo) == 0x24);
    // Padding between fields: colorAttrInfo and: alphaAttrInfo
    char __padding22[0x4] = {};
    // public HoudiniEngineUnity.HAPI_AttributeInfo _alphaAttrInfo
    // Size: 0x24
    // Offset: 0x1C0
    ::HoudiniEngineUnity::HAPI_AttributeInfo alphaAttrInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_AttributeInfo) == 0x24);
    // Padding between fields: alphaAttrInfo and: tangentAttrInfo
    char __padding23[0x4] = {};
    // public HoudiniEngineUnity.HAPI_AttributeInfo _tangentAttrInfo
    // Size: 0x24
    // Offset: 0x1E8
    ::HoudiniEngineUnity::HAPI_AttributeInfo tangentAttrInfo;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HAPI_AttributeInfo) == 0x24);
    // Padding between fields: tangentAttrInfo and: posAttr
    char __padding24[0x4] = {};
    // public System.Single[] _posAttr
    // Size: 0x8
    // Offset: 0x210
    ::ArrayW<float> posAttr;
    // Field size check
    static_assert(sizeof(::ArrayW<float>) == 0x8);
    // public System.Single[][] _uvsAttr
    // Size: 0x8
    // Offset: 0x218
    ::ArrayW<::ArrayW<float>> uvsAttr;
    // Field size check
    static_assert(sizeof(::ArrayW<::ArrayW<float>>) == 0x8);
    // public System.Single[] _normalAttr
    // Size: 0x8
    // Offset: 0x220
    ::ArrayW<float> normalAttr;
    // Field size check
    static_assert(sizeof(::ArrayW<float>) == 0x8);
    // public System.Single[] _colorAttr
    // Size: 0x8
    // Offset: 0x228
    ::ArrayW<float> colorAttr;
    // Field size check
    static_assert(sizeof(::ArrayW<float>) == 0x8);
    // public System.Single[] _alphaAttr
    // Size: 0x8
    // Offset: 0x230
    ::ArrayW<float> alphaAttr;
    // Field size check
    static_assert(sizeof(::ArrayW<float>) == 0x8);
    // public System.Single[] _tangentAttr
    // Size: 0x8
    // Offset: 0x238
    ::ArrayW<float> tangentAttr;
    // Field size check
    static_assert(sizeof(::ArrayW<float>) == 0x8);
    // public System.String[] _groups
    // Size: 0x8
    // Offset: 0x240
    ::ArrayW<::StringW> groups;
    // Field size check
    static_assert(sizeof(::ArrayW<::StringW>) == 0x8);
    // public System.Boolean _hasGroupGeometry
    // Size: 0x1
    // Offset: 0x248
    bool hasGroupGeometry;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: hasGroupGeometry and: groupSplitVertexIndices
    char __padding32[0x7] = {};
    // public System.Collections.Generic.Dictionary`2<System.String,System.Int32[]> _groupSplitVertexIndices
    // Size: 0x8
    // Offset: 0x250
    ::System::Collections::Generic::Dictionary_2<::StringW, ::ArrayW<int>>* groupSplitVertexIndices;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::StringW, ::ArrayW<int>>*) == 0x8);
    // public System.Collections.Generic.Dictionary`2<System.String,System.Collections.Generic.List`1<System.Int32>> _groupSplitFaceIndices
    // Size: 0x8
    // Offset: 0x258
    ::System::Collections::Generic::Dictionary_2<::StringW, ::System::Collections::Generic::List_1<int>*>* groupSplitFaceIndices;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::StringW, ::System::Collections::Generic::List_1<int>*>*) == 0x8);
    // public System.Collections.Generic.Dictionary`2<System.String,System.Collections.Generic.List`1<System.Int32>> _groupVertexOffsets
    // Size: 0x8
    // Offset: 0x260
    ::System::Collections::Generic::Dictionary_2<::StringW, ::System::Collections::Generic::List_1<int>*>* groupVertexOffsets;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::StringW, ::System::Collections::Generic::List_1<int>*>*) == 0x8);
    // public System.Int32[] _allCollisionVertexList
    // Size: 0x8
    // Offset: 0x268
    ::ArrayW<int> allCollisionVertexList;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Int32[] _allCollisionFaceIndices
    // Size: 0x8
    // Offset: 0x270
    ::ArrayW<int> allCollisionFaceIndices;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Single _normalCosineThreshold
    // Size: 0x4
    // Offset: 0x278
    float normalCosineThreshold;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean _hasLODGroups
    // Size: 0x1
    // Offset: 0x27C
    bool hasLODGroups;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: hasLODGroups and: LODTransitionValues
    char __padding39[0x3] = {};
    // public System.Single[] _LODTransitionValues
    // Size: 0x8
    // Offset: 0x280
    ::ArrayW<float> LODTransitionValues;
    // Field size check
    static_assert(sizeof(::ArrayW<float>) == 0x8);
    // public System.Boolean _isMeshReadWrite
    // Size: 0x1
    // Offset: 0x288
    bool isMeshReadWrite;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isMeshReadWrite and: colliderInfos
    char __padding41[0x7] = {};
    // public System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_GenerateGeoCache/HoudiniEngineUnity.HEU_ColliderInfo> _colliderInfos
    // Size: 0x8
    // Offset: 0x290
    ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_GenerateGeoCache::HEU_ColliderInfo*>* colliderInfos;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_GenerateGeoCache::HEU_ColliderInfo*>*) == 0x8);
    // public System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_MaterialData> _materialCache
    // Size: 0x8
    // Offset: 0x298
    ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_MaterialData*>* materialCache;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_MaterialData*>*) == 0x8);
    // public System.Collections.Generic.Dictionary`2<System.Int32,HoudiniEngineUnity.HEU_MaterialData> _materialIDToDataMap
    // Size: 0x8
    // Offset: 0x2A0
    ::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_MaterialData*>* materialIDToDataMap;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_MaterialData*>*) == 0x8);
    // public System.String _assetCacheFolderPath
    // Size: 0x8
    // Offset: 0x2A8
    ::StringW assetCacheFolderPath;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public HoudiniEngineUnity.HEU_MeshIndexFormat _meshIndexFormat
    // Size: 0x8
    // Offset: 0x2B0
    ::HoudiniEngineUnity::HEU_MeshIndexFormat* meshIndexFormat;
    // Field size check
    static_assert(sizeof(::HoudiniEngineUnity::HEU_MeshIndexFormat*) == 0x8);
    public:
    // Get instance field reference: private System.Int32 <AssetID>k__BackingField
    [[deprecated("Use field access instead!")]] int& dyn_$AssetID$k__BackingField();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_GeoInfo _geoInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_GeoInfo& dyn__geoInfo();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_PartInfo _partInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_PartInfo& dyn__partInfo();
    // Get instance field reference: public System.String _partName
    [[deprecated("Use field access instead!")]] ::StringW& dyn__partName();
    // Get instance field reference: public System.Int32[] _vertexList
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn__vertexList();
    // Get instance field reference: public System.Int32[] _faceCounts
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn__faceCounts();
    // Get instance field reference: public System.Int32[] _houdiniMaterialIDs
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn__houdiniMaterialIDs();
    // Get instance field reference: public System.Boolean _singleFaceUnityMaterial
    [[deprecated("Use field access instead!")]] bool& dyn__singleFaceUnityMaterial();
    // Get instance field reference: public System.Boolean _singleFaceHoudiniMaterial
    [[deprecated("Use field access instead!")]] bool& dyn__singleFaceHoudiniMaterial();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.Int32,HoudiniEngineUnity.HEU_UnityMaterialInfo> _unityMaterialInfos
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_UnityMaterialInfo*>*& dyn__unityMaterialInfos();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_AttributeInfo _unityMaterialAttrInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_AttributeInfo& dyn__unityMaterialAttrInfo();
    // Get instance field reference: public System.Int32[] _unityMaterialAttrName
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn__unityMaterialAttrName();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.Int32,System.String> _unityMaterialAttrStringsMap
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<int, ::StringW>*& dyn__unityMaterialAttrStringsMap();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_AttributeInfo _substanceMaterialAttrNameInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_AttributeInfo& dyn__substanceMaterialAttrNameInfo();
    // Get instance field reference: public System.Int32[] _substanceMaterialAttrName
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn__substanceMaterialAttrName();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.Int32,System.String> _substanceMaterialAttrStringsMap
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<int, ::StringW>*& dyn__substanceMaterialAttrStringsMap();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_AttributeInfo _substanceMaterialAttrIndexInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_AttributeInfo& dyn__substanceMaterialAttrIndexInfo();
    // Get instance field reference: public System.Int32[] _substanceMaterialAttrIndex
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn__substanceMaterialAttrIndex();
    // Get instance field reference: public System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_MaterialData> _inUseMaterials
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_MaterialData*>*& dyn__inUseMaterials();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_AttributeInfo _posAttrInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_AttributeInfo& dyn__posAttrInfo();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_AttributeInfo[] _uvsAttrInfo
    [[deprecated("Use field access instead!")]] ::ArrayW<::HoudiniEngineUnity::HAPI_AttributeInfo>& dyn__uvsAttrInfo();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_AttributeInfo _normalAttrInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_AttributeInfo& dyn__normalAttrInfo();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_AttributeInfo _colorAttrInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_AttributeInfo& dyn__colorAttrInfo();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_AttributeInfo _alphaAttrInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_AttributeInfo& dyn__alphaAttrInfo();
    // Get instance field reference: public HoudiniEngineUnity.HAPI_AttributeInfo _tangentAttrInfo
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HAPI_AttributeInfo& dyn__tangentAttrInfo();
    // Get instance field reference: public System.Single[] _posAttr
    [[deprecated("Use field access instead!")]] ::ArrayW<float>& dyn__posAttr();
    // Get instance field reference: public System.Single[][] _uvsAttr
    [[deprecated("Use field access instead!")]] ::ArrayW<::ArrayW<float>>& dyn__uvsAttr();
    // Get instance field reference: public System.Single[] _normalAttr
    [[deprecated("Use field access instead!")]] ::ArrayW<float>& dyn__normalAttr();
    // Get instance field reference: public System.Single[] _colorAttr
    [[deprecated("Use field access instead!")]] ::ArrayW<float>& dyn__colorAttr();
    // Get instance field reference: public System.Single[] _alphaAttr
    [[deprecated("Use field access instead!")]] ::ArrayW<float>& dyn__alphaAttr();
    // Get instance field reference: public System.Single[] _tangentAttr
    [[deprecated("Use field access instead!")]] ::ArrayW<float>& dyn__tangentAttr();
    // Get instance field reference: public System.String[] _groups
    [[deprecated("Use field access instead!")]] ::ArrayW<::StringW>& dyn__groups();
    // Get instance field reference: public System.Boolean _hasGroupGeometry
    [[deprecated("Use field access instead!")]] bool& dyn__hasGroupGeometry();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.String,System.Int32[]> _groupSplitVertexIndices
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::StringW, ::ArrayW<int>>*& dyn__groupSplitVertexIndices();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.String,System.Collections.Generic.List`1<System.Int32>> _groupSplitFaceIndices
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::StringW, ::System::Collections::Generic::List_1<int>*>*& dyn__groupSplitFaceIndices();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.String,System.Collections.Generic.List`1<System.Int32>> _groupVertexOffsets
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::StringW, ::System::Collections::Generic::List_1<int>*>*& dyn__groupVertexOffsets();
    // Get instance field reference: public System.Int32[] _allCollisionVertexList
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn__allCollisionVertexList();
    // Get instance field reference: public System.Int32[] _allCollisionFaceIndices
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn__allCollisionFaceIndices();
    // Get instance field reference: public System.Single _normalCosineThreshold
    [[deprecated("Use field access instead!")]] float& dyn__normalCosineThreshold();
    // Get instance field reference: public System.Boolean _hasLODGroups
    [[deprecated("Use field access instead!")]] bool& dyn__hasLODGroups();
    // Get instance field reference: public System.Single[] _LODTransitionValues
    [[deprecated("Use field access instead!")]] ::ArrayW<float>& dyn__LODTransitionValues();
    // Get instance field reference: public System.Boolean _isMeshReadWrite
    [[deprecated("Use field access instead!")]] bool& dyn__isMeshReadWrite();
    // Get instance field reference: public System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_GenerateGeoCache/HoudiniEngineUnity.HEU_ColliderInfo> _colliderInfos
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_GenerateGeoCache::HEU_ColliderInfo*>*& dyn__colliderInfos();
    // Get instance field reference: public System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_MaterialData> _materialCache
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_MaterialData*>*& dyn__materialCache();
    // Get instance field reference: public System.Collections.Generic.Dictionary`2<System.Int32,HoudiniEngineUnity.HEU_MaterialData> _materialIDToDataMap
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_MaterialData*>*& dyn__materialIDToDataMap();
    // Get instance field reference: public System.String _assetCacheFolderPath
    [[deprecated("Use field access instead!")]] ::StringW& dyn__assetCacheFolderPath();
    // Get instance field reference: public HoudiniEngineUnity.HEU_MeshIndexFormat _meshIndexFormat
    [[deprecated("Use field access instead!")]] ::HoudiniEngineUnity::HEU_MeshIndexFormat*& dyn__meshIndexFormat();
    // public System.Int32 get_GeoID()
    // Offset: 0x1790010
    int get_GeoID();
    // public System.Int32 get_PartID()
    // Offset: 0x1790018
    int get_PartID();
    // public System.Int32 get_AssetID()
    // Offset: 0x1790020
    int get_AssetID();
    // public System.Void set_AssetID(System.Int32 value)
    // Offset: 0x1790028
    void set_AssetID(int value);
    // public System.Void .ctor()
    // Offset: 0x179030C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static HEU_GenerateGeoCache* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::HoudiniEngineUnity::HEU_GenerateGeoCache::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<HEU_GenerateGeoCache*, creationType>()));
    }
    // static public HoudiniEngineUnity.HEU_GenerateGeoCache GetPopulatedGeoCache(HoudiniEngineUnity.HEU_SessionBase session, System.Int32 assetID, System.Int32 geoID, System.Int32 partID, System.Boolean bUseLODGroups, System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_MaterialData> materialCache, System.String assetCacheFolderPath)
    // Offset: 0x1790030
    static ::HoudiniEngineUnity::HEU_GenerateGeoCache* GetPopulatedGeoCache(::HoudiniEngineUnity::HEU_SessionBase* session, int assetID, int geoID, int partID, bool bUseLODGroups, ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_MaterialData*>* materialCache, ::StringW assetCacheFolderPath);
    // public System.Void PopulateUnityMaterialData(HoudiniEngineUnity.HEU_SessionBase session)
    // Offset: 0x1790474
    void PopulateUnityMaterialData(::HoudiniEngineUnity::HEU_SessionBase* session);
    // static public System.Int32 GetMaterialKeyFromAttributeIndex(HoudiniEngineUnity.HEU_GenerateGeoCache geoCache, System.Int32 attributeIndex, out System.String unityMaterialName, out System.String substanceName, out System.Int32 substanceIndex)
    // Offset: 0x17922BC
    static int GetMaterialKeyFromAttributeIndex(::HoudiniEngineUnity::HEU_GenerateGeoCache* geoCache, int attributeIndex, ByRef<::StringW> unityMaterialName, ByRef<::StringW> substanceName, ByRef<int> substanceIndex);
    // static public System.Void CreateMaterialInfoEntryFromAttributeIndex(HoudiniEngineUnity.HEU_GenerateGeoCache geoCache, System.Int32 materialAttributeIndex)
    // Offset: 0x17921BC
    static void CreateMaterialInfoEntryFromAttributeIndex(::HoudiniEngineUnity::HEU_GenerateGeoCache* geoCache, int materialAttributeIndex);
    // public System.Boolean PopulateGeometryData(HoudiniEngineUnity.HEU_SessionBase session, System.Boolean bUseLODGroups)
    // Offset: 0x1790A84
    bool PopulateGeometryData(::HoudiniEngineUnity::HEU_SessionBase* session, bool bUseLODGroups);
    // static public System.Void ParseLODTransitionAttribute(HoudiniEngineUnity.HEU_SessionBase session, System.Int32 geoID, System.Int32 partID, ref System.Single[] LODTransitionValues)
    // Offset: 0x1792434
    static void ParseLODTransitionAttribute(::HoudiniEngineUnity::HEU_SessionBase* session, int geoID, int partID, ByRef<::ArrayW<float>> LODTransitionValues);
    // static public System.Void UpdateColliders(HoudiniEngineUnity.HEU_GenerateGeoCache geoCache, HoudiniEngineUnity.HEU_GeneratedOutputData outputData)
    // Offset: 0x17925CC
    static void UpdateColliders(::HoudiniEngineUnity::HEU_GenerateGeoCache* geoCache, ::HoudiniEngineUnity::HEU_GeneratedOutputData* outputData);
    // static public System.Void UpdateCollider(HoudiniEngineUnity.HEU_GenerateGeoCache geoCache, HoudiniEngineUnity.HEU_GeneratedOutputData outputData, HoudiniEngineUnity.HEU_GenerateGeoCache/HoudiniEngineUnity.HEU_ColliderInfo colliderInfo)
    // Offset: 0x17928E4
    static void UpdateCollider(::HoudiniEngineUnity::HEU_GenerateGeoCache* geoCache, ::HoudiniEngineUnity::HEU_GeneratedOutputData* outputData, ::HoudiniEngineUnity::HEU_GenerateGeoCache::HEU_ColliderInfo* colliderInfo);
    // static private System.Void GetFinalMaterialsFromComparingNewWithPrevious(UnityEngine.GameObject gameObject, UnityEngine.Material[] previousMaterials, UnityEngine.Material[] newMaterials, ref UnityEngine.Material[] finalMaterials)
    // Offset: 0x1792EB0
    static void GetFinalMaterialsFromComparingNewWithPrevious(::UnityEngine::GameObject* gameObject, ::ArrayW<::UnityEngine::Material*> previousMaterials, ::ArrayW<::UnityEngine::Material*> newMaterials, ByRef<::ArrayW<::UnityEngine::Material*>> finalMaterials);
    // static public System.Boolean GenerateMeshFromSingleGroup(HoudiniEngineUnity.HEU_SessionBase session, HoudiniEngineUnity.HEU_GeoGroup GeoGroup, HoudiniEngineUnity.HEU_GenerateGeoCache geoCache, HoudiniEngineUnity.HEU_GeneratedOutput generatedOutput, System.Int32 defaultMaterialKey, System.Boolean bGenerateUVs, System.Boolean bGenerateTangents, System.Boolean bGenerateNormals, System.Boolean bPartInstanced)
    // Offset: 0x1793200
    static bool GenerateMeshFromSingleGroup(::HoudiniEngineUnity::HEU_SessionBase* session, ::HoudiniEngineUnity::HEU_GeoGroup* GeoGroup, ::HoudiniEngineUnity::HEU_GenerateGeoCache* geoCache, ::HoudiniEngineUnity::HEU_GeneratedOutput* generatedOutput, int defaultMaterialKey, bool bGenerateUVs, bool bGenerateTangents, bool bGenerateNormals, bool bPartInstanced);
    // static public System.Boolean GenerateLODMeshesFromGeoGroups(HoudiniEngineUnity.HEU_SessionBase session, System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_GeoGroup> GeoGroupMeshes, HoudiniEngineUnity.HEU_GenerateGeoCache geoCache, HoudiniEngineUnity.HEU_GeneratedOutput generatedOutput, System.Int32 defaultMaterialKey, System.Boolean bGenerateUVs, System.Boolean bGenerateTangents, System.Boolean bGenerateNormals, System.Boolean bPartInstanced)
    // Offset: 0x1793FA0
    static bool GenerateLODMeshesFromGeoGroups(::HoudiniEngineUnity::HEU_SessionBase* session, ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_GeoGroup*>* GeoGroupMeshes, ::HoudiniEngineUnity::HEU_GenerateGeoCache* geoCache, ::HoudiniEngineUnity::HEU_GeneratedOutput* generatedOutput, int defaultMaterialKey, bool bGenerateUVs, bool bGenerateTangents, bool bGenerateNormals, bool bPartInstanced);
    // static public System.Boolean GenerateMeshFromGeoGroup(HoudiniEngineUnity.HEU_SessionBase session, HoudiniEngineUnity.HEU_GeoGroup GeoGroup, HoudiniEngineUnity.HEU_GenerateGeoCache geoCache, System.Int32 defaultMaterialKey, System.Boolean bGenerateUVs, System.Boolean bGenerateTangents, System.Boolean bGenerateNormals, System.Boolean bPartInstanced, out UnityEngine.Mesh newMesh, out UnityEngine.Material[] newMaterials)
    // Offset: 0x17933B8
    static bool GenerateMeshFromGeoGroup(::HoudiniEngineUnity::HEU_SessionBase* session, ::HoudiniEngineUnity::HEU_GeoGroup* GeoGroup, ::HoudiniEngineUnity::HEU_GenerateGeoCache* geoCache, int defaultMaterialKey, bool bGenerateUVs, bool bGenerateTangents, bool bGenerateNormals, bool bPartInstanced, ByRef<::UnityEngine::Mesh*> newMesh, ByRef<::ArrayW<::UnityEngine::Material*>> newMaterials);
    // static public UnityEngine.Mesh CombineQuadMeshes(System.Collections.Generic.Dictionary`2<System.Int32,HoudiniEngineUnity.HEU_MeshData> subMeshesMap, System.Collections.Generic.List`1<System.Int32> subMeshIndices, System.Boolean bGenerateNormals)
    // Offset: 0x1794C5C
    static ::UnityEngine::Mesh* CombineQuadMeshes(::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_MeshData*>* subMeshesMap, ::System::Collections::Generic::List_1<int>* subMeshIndices, bool bGenerateNormals);
    // static public UnityEngine.Mesh CombineMeshes(System.Collections.Generic.Dictionary`2<System.Int32,HoudiniEngineUnity.HEU_MeshData> subMeshesMap, System.Collections.Generic.List`1<System.Int32> submeshIndices, System.Boolean bGenerateUVs, System.Boolean bGenerateNormals, HoudiniEngineUnity.HEU_MeshIndexFormat meshIndexFormat)
    // Offset: 0x1795188
    static ::UnityEngine::Mesh* CombineMeshes(::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_MeshData*>* subMeshesMap, ::System::Collections::Generic::List_1<int>* submeshIndices, bool bGenerateUVs, bool bGenerateNormals, ::HoudiniEngineUnity::HEU_MeshIndexFormat* meshIndexFormat);
    // static public UnityEngine.Mesh CreateMeshFromMeshData(HoudiniEngineUnity.HEU_MeshData submesh, System.Boolean bGenerateUVs, System.Boolean bGenerateNormals, HoudiniEngineUnity.HEU_MeshIndexFormat meshIndexFormat)
    // Offset: 0x1794994
    static ::UnityEngine::Mesh* CreateMeshFromMeshData(::HoudiniEngineUnity::HEU_MeshData* submesh, bool bGenerateUVs, bool bGenerateNormals, ::HoudiniEngineUnity::HEU_MeshIndexFormat* meshIndexFormat);
    // static public System.Void TransferRegularAttributesToVertices(System.Int32[] groupVertexList, System.Int32[] allFaceCounts, System.Collections.Generic.List`1<System.Int32> groupFaces, System.Collections.Generic.List`1<System.Int32> groupVertexOffset, ref HoudiniEngineUnity.HAPI_AttributeInfo attribInfo, System.Single[] inData, ref System.Single[] outData)
    // Offset: 0x17954D0
    static void TransferRegularAttributesToVertices(::ArrayW<int> groupVertexList, ::ArrayW<int> allFaceCounts, ::System::Collections::Generic::List_1<int>* groupFaces, ::System::Collections::Generic::List_1<int>* groupVertexOffset, ByRef<::HoudiniEngineUnity::HAPI_AttributeInfo> attribInfo, ::ArrayW<float> inData, ByRef<::ArrayW<float>> outData);
    // static public System.Boolean GenerateGeoGroupUsingGeoCacheVertices(HoudiniEngineUnity.HEU_SessionBase session, HoudiniEngineUnity.HEU_GenerateGeoCache geoCache, System.Boolean bGenerateUVs, System.Boolean bGenerateTangents, System.Boolean bGenerateNormals, System.Boolean bUseLODGroups, System.Boolean bPartInstanced, out System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_GeoGroup> LODGroupMeshes, out System.Int32 defaultMaterialKey)
    // Offset: 0x17957D8
    static bool GenerateGeoGroupUsingGeoCacheVertices(::HoudiniEngineUnity::HEU_SessionBase* session, ::HoudiniEngineUnity::HEU_GenerateGeoCache* geoCache, bool bGenerateUVs, bool bGenerateTangents, bool bGenerateNormals, bool bUseLODGroups, bool bPartInstanced, ByRef<::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_GeoGroup*>*> LODGroupMeshes, ByRef<int> defaultMaterialKey);
    // static public System.Boolean GenerateGeoGroupUsingGeoCachePoints(HoudiniEngineUnity.HEU_SessionBase session, HoudiniEngineUnity.HEU_GenerateGeoCache geoCache, System.Boolean bGenerateUVs, System.Boolean bGenerateTangents, System.Boolean bGenerateNormals, System.Boolean bUseLODGroups, System.Boolean bPartInstanced, out System.Collections.Generic.List`1<HoudiniEngineUnity.HEU_GeoGroup> LODGroupMeshes, out System.Int32 defaultMaterialKey)
    // Offset: 0x1798270
    static bool GenerateGeoGroupUsingGeoCachePoints(::HoudiniEngineUnity::HEU_SessionBase* session, ::HoudiniEngineUnity::HEU_GenerateGeoCache* geoCache, bool bGenerateUVs, bool bGenerateTangents, bool bGenerateNormals, bool bUseLODGroups, bool bPartInstanced, ByRef<::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_GeoGroup*>*> LODGroupMeshes, ByRef<int> defaultMaterialKey);
    // static public UnityEngine.MeshTopology CalculateGroupMeshTopology(System.Collections.Generic.List`1<System.Int32> groupFaces, System.Int32[] allFaceCounts)
    // Offset: 0x1797EAC
    static ::UnityEngine::MeshTopology CalculateGroupMeshTopology(::System::Collections::Generic::List_1<int>* groupFaces, ::ArrayW<int> allFaceCounts);
  }; // HoudiniEngineUnity.HEU_GenerateGeoCache
  #pragma pack(pop)
  static check_size<sizeof(HEU_GenerateGeoCache), 688 + sizeof(::HoudiniEngineUnity::HEU_MeshIndexFormat*)> __HoudiniEngineUnity_HEU_GenerateGeoCacheSizeCheck;
  static_assert(sizeof(HEU_GenerateGeoCache) == 0x2B8);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::get_GeoID
// Il2CppName: get_GeoID
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (HoudiniEngineUnity::HEU_GenerateGeoCache::*)()>(&HoudiniEngineUnity::HEU_GenerateGeoCache::get_GeoID)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "get_GeoID", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::get_PartID
// Il2CppName: get_PartID
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (HoudiniEngineUnity::HEU_GenerateGeoCache::*)()>(&HoudiniEngineUnity::HEU_GenerateGeoCache::get_PartID)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "get_PartID", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::get_AssetID
// Il2CppName: get_AssetID
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (HoudiniEngineUnity::HEU_GenerateGeoCache::*)()>(&HoudiniEngineUnity::HEU_GenerateGeoCache::get_AssetID)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "get_AssetID", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::set_AssetID
// Il2CppName: set_AssetID
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HoudiniEngineUnity::HEU_GenerateGeoCache::*)(int)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::set_AssetID)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "set_AssetID", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::GetPopulatedGeoCache
// Il2CppName: GetPopulatedGeoCache
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::HoudiniEngineUnity::HEU_GenerateGeoCache* (*)(::HoudiniEngineUnity::HEU_SessionBase*, int, int, int, bool, ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_MaterialData*>*, ::StringW)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::GetPopulatedGeoCache)> {
  static const MethodInfo* get() {
    static auto* session = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_SessionBase")->byval_arg;
    static auto* assetID = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* geoID = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* partID = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* bUseLODGroups = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* materialCache = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_MaterialData")})->byval_arg;
    static auto* assetCacheFolderPath = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "GetPopulatedGeoCache", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{session, assetID, geoID, partID, bUseLODGroups, materialCache, assetCacheFolderPath});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::PopulateUnityMaterialData
// Il2CppName: PopulateUnityMaterialData
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (HoudiniEngineUnity::HEU_GenerateGeoCache::*)(::HoudiniEngineUnity::HEU_SessionBase*)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::PopulateUnityMaterialData)> {
  static const MethodInfo* get() {
    static auto* session = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_SessionBase")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "PopulateUnityMaterialData", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{session});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::GetMaterialKeyFromAttributeIndex
// Il2CppName: GetMaterialKeyFromAttributeIndex
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(::HoudiniEngineUnity::HEU_GenerateGeoCache*, int, ByRef<::StringW>, ByRef<::StringW>, ByRef<int>)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::GetMaterialKeyFromAttributeIndex)> {
  static const MethodInfo* get() {
    static auto* geoCache = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache")->byval_arg;
    static auto* attributeIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* unityMaterialName = &::il2cpp_utils::GetClassFromName("System", "String")->this_arg;
    static auto* substanceName = &::il2cpp_utils::GetClassFromName("System", "String")->this_arg;
    static auto* substanceIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "GetMaterialKeyFromAttributeIndex", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{geoCache, attributeIndex, unityMaterialName, substanceName, substanceIndex});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::CreateMaterialInfoEntryFromAttributeIndex
// Il2CppName: CreateMaterialInfoEntryFromAttributeIndex
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::HoudiniEngineUnity::HEU_GenerateGeoCache*, int)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::CreateMaterialInfoEntryFromAttributeIndex)> {
  static const MethodInfo* get() {
    static auto* geoCache = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache")->byval_arg;
    static auto* materialAttributeIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "CreateMaterialInfoEntryFromAttributeIndex", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{geoCache, materialAttributeIndex});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::PopulateGeometryData
// Il2CppName: PopulateGeometryData
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (HoudiniEngineUnity::HEU_GenerateGeoCache::*)(::HoudiniEngineUnity::HEU_SessionBase*, bool)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::PopulateGeometryData)> {
  static const MethodInfo* get() {
    static auto* session = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_SessionBase")->byval_arg;
    static auto* bUseLODGroups = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "PopulateGeometryData", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{session, bUseLODGroups});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::ParseLODTransitionAttribute
// Il2CppName: ParseLODTransitionAttribute
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::HoudiniEngineUnity::HEU_SessionBase*, int, int, ByRef<::ArrayW<float>>)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::ParseLODTransitionAttribute)> {
  static const MethodInfo* get() {
    static auto* session = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_SessionBase")->byval_arg;
    static auto* geoID = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* partID = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* LODTransitionValues = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Single"), 1)->this_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "ParseLODTransitionAttribute", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{session, geoID, partID, LODTransitionValues});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::UpdateColliders
// Il2CppName: UpdateColliders
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::HoudiniEngineUnity::HEU_GenerateGeoCache*, ::HoudiniEngineUnity::HEU_GeneratedOutputData*)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::UpdateColliders)> {
  static const MethodInfo* get() {
    static auto* geoCache = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache")->byval_arg;
    static auto* outputData = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GeneratedOutputData")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "UpdateColliders", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{geoCache, outputData});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::UpdateCollider
// Il2CppName: UpdateCollider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::HoudiniEngineUnity::HEU_GenerateGeoCache*, ::HoudiniEngineUnity::HEU_GeneratedOutputData*, ::HoudiniEngineUnity::HEU_GenerateGeoCache::HEU_ColliderInfo*)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::UpdateCollider)> {
  static const MethodInfo* get() {
    static auto* geoCache = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache")->byval_arg;
    static auto* outputData = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GeneratedOutputData")->byval_arg;
    static auto* colliderInfo = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache/HEU_ColliderInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "UpdateCollider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{geoCache, outputData, colliderInfo});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::GetFinalMaterialsFromComparingNewWithPrevious
// Il2CppName: GetFinalMaterialsFromComparingNewWithPrevious
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::UnityEngine::GameObject*, ::ArrayW<::UnityEngine::Material*>, ::ArrayW<::UnityEngine::Material*>, ByRef<::ArrayW<::UnityEngine::Material*>>)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::GetFinalMaterialsFromComparingNewWithPrevious)> {
  static const MethodInfo* get() {
    static auto* gameObject = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* previousMaterials = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Material"), 1)->byval_arg;
    static auto* newMaterials = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Material"), 1)->byval_arg;
    static auto* finalMaterials = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Material"), 1)->this_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "GetFinalMaterialsFromComparingNewWithPrevious", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{gameObject, previousMaterials, newMaterials, finalMaterials});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateMeshFromSingleGroup
// Il2CppName: GenerateMeshFromSingleGroup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::HoudiniEngineUnity::HEU_SessionBase*, ::HoudiniEngineUnity::HEU_GeoGroup*, ::HoudiniEngineUnity::HEU_GenerateGeoCache*, ::HoudiniEngineUnity::HEU_GeneratedOutput*, int, bool, bool, bool, bool)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateMeshFromSingleGroup)> {
  static const MethodInfo* get() {
    static auto* session = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_SessionBase")->byval_arg;
    static auto* GeoGroup = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GeoGroup")->byval_arg;
    static auto* geoCache = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache")->byval_arg;
    static auto* generatedOutput = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GeneratedOutput")->byval_arg;
    static auto* defaultMaterialKey = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* bGenerateUVs = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateTangents = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateNormals = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bPartInstanced = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "GenerateMeshFromSingleGroup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{session, GeoGroup, geoCache, generatedOutput, defaultMaterialKey, bGenerateUVs, bGenerateTangents, bGenerateNormals, bPartInstanced});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateLODMeshesFromGeoGroups
// Il2CppName: GenerateLODMeshesFromGeoGroups
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::HoudiniEngineUnity::HEU_SessionBase*, ::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_GeoGroup*>*, ::HoudiniEngineUnity::HEU_GenerateGeoCache*, ::HoudiniEngineUnity::HEU_GeneratedOutput*, int, bool, bool, bool, bool)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateLODMeshesFromGeoGroups)> {
  static const MethodInfo* get() {
    static auto* session = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_SessionBase")->byval_arg;
    static auto* GeoGroupMeshes = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GeoGroup")})->byval_arg;
    static auto* geoCache = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache")->byval_arg;
    static auto* generatedOutput = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GeneratedOutput")->byval_arg;
    static auto* defaultMaterialKey = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* bGenerateUVs = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateTangents = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateNormals = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bPartInstanced = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "GenerateLODMeshesFromGeoGroups", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{session, GeoGroupMeshes, geoCache, generatedOutput, defaultMaterialKey, bGenerateUVs, bGenerateTangents, bGenerateNormals, bPartInstanced});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateMeshFromGeoGroup
// Il2CppName: GenerateMeshFromGeoGroup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::HoudiniEngineUnity::HEU_SessionBase*, ::HoudiniEngineUnity::HEU_GeoGroup*, ::HoudiniEngineUnity::HEU_GenerateGeoCache*, int, bool, bool, bool, bool, ByRef<::UnityEngine::Mesh*>, ByRef<::ArrayW<::UnityEngine::Material*>>)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateMeshFromGeoGroup)> {
  static const MethodInfo* get() {
    static auto* session = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_SessionBase")->byval_arg;
    static auto* GeoGroup = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GeoGroup")->byval_arg;
    static auto* geoCache = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache")->byval_arg;
    static auto* defaultMaterialKey = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* bGenerateUVs = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateTangents = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateNormals = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bPartInstanced = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* newMesh = &::il2cpp_utils::GetClassFromName("UnityEngine", "Mesh")->this_arg;
    static auto* newMaterials = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Material"), 1)->this_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "GenerateMeshFromGeoGroup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{session, GeoGroup, geoCache, defaultMaterialKey, bGenerateUVs, bGenerateTangents, bGenerateNormals, bPartInstanced, newMesh, newMaterials});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::CombineQuadMeshes
// Il2CppName: CombineQuadMeshes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Mesh* (*)(::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_MeshData*>*, ::System::Collections::Generic::List_1<int>*, bool)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::CombineQuadMeshes)> {
  static const MethodInfo* get() {
    static auto* subMeshesMap = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "Dictionary`2"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Int32"), ::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_MeshData")})->byval_arg;
    static auto* subMeshIndices = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Int32")})->byval_arg;
    static auto* bGenerateNormals = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "CombineQuadMeshes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{subMeshesMap, subMeshIndices, bGenerateNormals});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::CombineMeshes
// Il2CppName: CombineMeshes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Mesh* (*)(::System::Collections::Generic::Dictionary_2<int, ::HoudiniEngineUnity::HEU_MeshData*>*, ::System::Collections::Generic::List_1<int>*, bool, bool, ::HoudiniEngineUnity::HEU_MeshIndexFormat*)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::CombineMeshes)> {
  static const MethodInfo* get() {
    static auto* subMeshesMap = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "Dictionary`2"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Int32"), ::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_MeshData")})->byval_arg;
    static auto* submeshIndices = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Int32")})->byval_arg;
    static auto* bGenerateUVs = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateNormals = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* meshIndexFormat = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_MeshIndexFormat")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "CombineMeshes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{subMeshesMap, submeshIndices, bGenerateUVs, bGenerateNormals, meshIndexFormat});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::CreateMeshFromMeshData
// Il2CppName: CreateMeshFromMeshData
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Mesh* (*)(::HoudiniEngineUnity::HEU_MeshData*, bool, bool, ::HoudiniEngineUnity::HEU_MeshIndexFormat*)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::CreateMeshFromMeshData)> {
  static const MethodInfo* get() {
    static auto* submesh = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_MeshData")->byval_arg;
    static auto* bGenerateUVs = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateNormals = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* meshIndexFormat = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_MeshIndexFormat")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "CreateMeshFromMeshData", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{submesh, bGenerateUVs, bGenerateNormals, meshIndexFormat});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::TransferRegularAttributesToVertices
// Il2CppName: TransferRegularAttributesToVertices
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::ArrayW<int>, ::ArrayW<int>, ::System::Collections::Generic::List_1<int>*, ::System::Collections::Generic::List_1<int>*, ByRef<::HoudiniEngineUnity::HAPI_AttributeInfo>, ::ArrayW<float>, ByRef<::ArrayW<float>>)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::TransferRegularAttributesToVertices)> {
  static const MethodInfo* get() {
    static auto* groupVertexList = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Int32"), 1)->byval_arg;
    static auto* allFaceCounts = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Int32"), 1)->byval_arg;
    static auto* groupFaces = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Int32")})->byval_arg;
    static auto* groupVertexOffset = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Int32")})->byval_arg;
    static auto* attribInfo = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HAPI_AttributeInfo")->this_arg;
    static auto* inData = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Single"), 1)->byval_arg;
    static auto* outData = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Single"), 1)->this_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "TransferRegularAttributesToVertices", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{groupVertexList, allFaceCounts, groupFaces, groupVertexOffset, attribInfo, inData, outData});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateGeoGroupUsingGeoCacheVertices
// Il2CppName: GenerateGeoGroupUsingGeoCacheVertices
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::HoudiniEngineUnity::HEU_SessionBase*, ::HoudiniEngineUnity::HEU_GenerateGeoCache*, bool, bool, bool, bool, bool, ByRef<::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_GeoGroup*>*>, ByRef<int>)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateGeoGroupUsingGeoCacheVertices)> {
  static const MethodInfo* get() {
    static auto* session = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_SessionBase")->byval_arg;
    static auto* geoCache = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache")->byval_arg;
    static auto* bGenerateUVs = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateTangents = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateNormals = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bUseLODGroups = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bPartInstanced = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* LODGroupMeshes = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GeoGroup")})->this_arg;
    static auto* defaultMaterialKey = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "GenerateGeoGroupUsingGeoCacheVertices", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{session, geoCache, bGenerateUVs, bGenerateTangents, bGenerateNormals, bUseLODGroups, bPartInstanced, LODGroupMeshes, defaultMaterialKey});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateGeoGroupUsingGeoCachePoints
// Il2CppName: GenerateGeoGroupUsingGeoCachePoints
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::HoudiniEngineUnity::HEU_SessionBase*, ::HoudiniEngineUnity::HEU_GenerateGeoCache*, bool, bool, bool, bool, bool, ByRef<::System::Collections::Generic::List_1<::HoudiniEngineUnity::HEU_GeoGroup*>*>, ByRef<int>)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::GenerateGeoGroupUsingGeoCachePoints)> {
  static const MethodInfo* get() {
    static auto* session = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_SessionBase")->byval_arg;
    static auto* geoCache = &::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GenerateGeoCache")->byval_arg;
    static auto* bGenerateUVs = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateTangents = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bGenerateNormals = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bUseLODGroups = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bPartInstanced = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* LODGroupMeshes = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("HoudiniEngineUnity", "HEU_GeoGroup")})->this_arg;
    static auto* defaultMaterialKey = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "GenerateGeoGroupUsingGeoCachePoints", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{session, geoCache, bGenerateUVs, bGenerateTangents, bGenerateNormals, bUseLODGroups, bPartInstanced, LODGroupMeshes, defaultMaterialKey});
  }
};
// Writing MetadataGetter for method: HoudiniEngineUnity::HEU_GenerateGeoCache::CalculateGroupMeshTopology
// Il2CppName: CalculateGroupMeshTopology
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::MeshTopology (*)(::System::Collections::Generic::List_1<int>*, ::ArrayW<int>)>(&HoudiniEngineUnity::HEU_GenerateGeoCache::CalculateGroupMeshTopology)> {
  static const MethodInfo* get() {
    static auto* groupFaces = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Int32")})->byval_arg;
    static auto* allFaceCounts = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Int32"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(HoudiniEngineUnity::HEU_GenerateGeoCache*), "CalculateGroupMeshTopology", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{groupFaces, allFaceCounts});
  }
};
