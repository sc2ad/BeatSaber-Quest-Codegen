// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Photon.Pun.MonoBehaviourPunCallbacks
#include "Photon/Pun/MonoBehaviourPunCallbacks.hpp"
// Including type: Photon.Realtime.IOnEventCallback
#include "Photon/Realtime/IOnEventCallback.hpp"
// Including type: System.Byte
#include "System/Byte.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Photon::Realtime
namespace Photon::Realtime {
  // Forward declaring type: Player
  class Player;
}
// Forward declaring namespace: Photon::Pun::UtilityScripts
namespace Photon::Pun::UtilityScripts {
  // Forward declaring type: IPunTurnManagerCallbacks
  class IPunTurnManagerCallbacks;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: HashSet`1<T>
  template<typename T>
  class HashSet_1;
}
// Forward declaring namespace: ExitGames::Client::Photon
namespace ExitGames::Client::Photon {
  // Forward declaring type: EventData
  class EventData;
  // Forward declaring type: Hashtable
  class Hashtable;
}
// Completed forward declares
// Type namespace: Photon.Pun.UtilityScripts
namespace Photon::Pun::UtilityScripts {
  // Forward declaring type: PunTurnManager
  class PunTurnManager;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Photon::Pun::UtilityScripts::PunTurnManager);
DEFINE_IL2CPP_ARG_TYPE(::Photon::Pun::UtilityScripts::PunTurnManager*, "Photon.Pun.UtilityScripts", "PunTurnManager");
// Type namespace: Photon.Pun.UtilityScripts
namespace Photon::Pun::UtilityScripts {
  // Size: 0x41
  #pragma pack(push, 1)
  // Autogenerated type: Photon.Pun.UtilityScripts.PunTurnManager
  // [TokenAttribute] Offset: FFFFFFFF
  class PunTurnManager : public ::Photon::Pun::MonoBehaviourPunCallbacks/*, public ::Photon::Realtime::IOnEventCallback*/ {
    public:
    public:
    // private Photon.Realtime.Player sender
    // Size: 0x8
    // Offset: 0x20
    ::Photon::Realtime::Player* sender;
    // Field size check
    static_assert(sizeof(::Photon::Realtime::Player*) == 0x8);
    // public System.Single TurnDuration
    // Size: 0x4
    // Offset: 0x28
    float TurnDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: TurnDuration and: TurnManagerListener
    char __padding1[0x4] = {};
    // public Photon.Pun.UtilityScripts.IPunTurnManagerCallbacks TurnManagerListener
    // Size: 0x8
    // Offset: 0x30
    ::Photon::Pun::UtilityScripts::IPunTurnManagerCallbacks* TurnManagerListener;
    // Field size check
    static_assert(sizeof(::Photon::Pun::UtilityScripts::IPunTurnManagerCallbacks*) == 0x8);
    // private readonly System.Collections.Generic.HashSet`1<Photon.Realtime.Player> finishedPlayers
    // Size: 0x8
    // Offset: 0x38
    ::System::Collections::Generic::HashSet_1<::Photon::Realtime::Player*>* finishedPlayers;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::HashSet_1<::Photon::Realtime::Player*>*) == 0x8);
    // private System.Boolean _isOverCallProcessed
    // Size: 0x1
    // Offset: 0x40
    bool isOverCallProcessed;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Creating interface conversion operator: operator ::Photon::Realtime::IOnEventCallback
    operator ::Photon::Realtime::IOnEventCallback() noexcept {
      return *reinterpret_cast<::Photon::Realtime::IOnEventCallback*>(this);
    }
    // static field const value: static public System.Byte TurnManagerEventOffset
    static constexpr const uint8_t TurnManagerEventOffset = 0u;
    // Get static field: static public System.Byte TurnManagerEventOffset
    static uint8_t _get_TurnManagerEventOffset();
    // Set static field: static public System.Byte TurnManagerEventOffset
    static void _set_TurnManagerEventOffset(uint8_t value);
    // static field const value: static public System.Byte EvMove
    static constexpr const uint8_t EvMove = 1u;
    // Get static field: static public System.Byte EvMove
    static uint8_t _get_EvMove();
    // Set static field: static public System.Byte EvMove
    static void _set_EvMove(uint8_t value);
    // static field const value: static public System.Byte EvFinalMove
    static constexpr const uint8_t EvFinalMove = 2u;
    // Get static field: static public System.Byte EvFinalMove
    static uint8_t _get_EvFinalMove();
    // Set static field: static public System.Byte EvFinalMove
    static void _set_EvFinalMove(uint8_t value);
    // Get instance field reference: private Photon.Realtime.Player sender
    [[deprecated("Use field access instead!")]] ::Photon::Realtime::Player*& dyn_sender();
    // Get instance field reference: public System.Single TurnDuration
    [[deprecated("Use field access instead!")]] float& dyn_TurnDuration();
    // Get instance field reference: public Photon.Pun.UtilityScripts.IPunTurnManagerCallbacks TurnManagerListener
    [[deprecated("Use field access instead!")]] ::Photon::Pun::UtilityScripts::IPunTurnManagerCallbacks*& dyn_TurnManagerListener();
    // Get instance field reference: private readonly System.Collections.Generic.HashSet`1<Photon.Realtime.Player> finishedPlayers
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::HashSet_1<::Photon::Realtime::Player*>*& dyn_finishedPlayers();
    // Get instance field reference: private System.Boolean _isOverCallProcessed
    [[deprecated("Use field access instead!")]] bool& dyn__isOverCallProcessed();
    // public System.Int32 get_Turn()
    // Offset: 0x1656148
    int get_Turn();
    // private System.Void set_Turn(System.Int32 value)
    // Offset: 0x16562E4
    void set_Turn(int value);
    // public System.Single get_ElapsedTimeInTurn()
    // Offset: 0x1656510
    float get_ElapsedTimeInTurn();
    // public System.Single get_RemainingSecondsInTurn()
    // Offset: 0x16566D0
    float get_RemainingSecondsInTurn();
    // public System.Boolean get_IsCompletedByAll()
    // Offset: 0x1656750
    bool get_IsCompletedByAll();
    // public System.Boolean get_IsFinishedByMe()
    // Offset: 0x1656814
    bool get_IsFinishedByMe();
    // public System.Boolean get_IsOver()
    // Offset: 0x165689C
    bool get_IsOver();
    // public System.Void .ctor()
    // Offset: 0x1657364
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static PunTurnManager* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Photon::Pun::UtilityScripts::PunTurnManager::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<PunTurnManager*, creationType>()));
    }
    // private System.Void Start()
    // Offset: 0x16568B8
    void Start();
    // private System.Void Update()
    // Offset: 0x16568BC
    void Update();
    // public System.Void BeginTurn()
    // Offset: 0x16569B4
    void BeginTurn();
    // public System.Void SendMove(System.Object move, System.Boolean finished)
    // Offset: 0x16569DC
    void SendMove(::Il2CppObject* move, bool finished);
    // public System.Boolean GetPlayerFinishedTurn(Photon.Realtime.Player player)
    // Offset: 0x165716C
    bool GetPlayerFinishedTurn(::Photon::Realtime::Player* player);
    // private System.Void ProcessOnEvent(System.Byte eventCode, System.Object content, System.Int32 senderId)
    // Offset: 0x1656D9C
    void ProcessOnEvent(uint8_t eventCode, ::Il2CppObject* content, int senderId);
    // public System.Void OnEvent(ExitGames.Client.Photon.EventData photonEvent)
    // Offset: 0x16571E8
    void OnEvent(::ExitGames::Client::Photon::EventData* photonEvent);
    // public override System.Void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
    // Offset: 0x1657248
    // Implemented from: Photon.Pun.MonoBehaviourPunCallbacks
    // Base method: System.Void MonoBehaviourPunCallbacks::OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
    void OnRoomPropertiesUpdate(::ExitGames::Client::Photon::Hashtable* propertiesThatChanged);
  }; // Photon.Pun.UtilityScripts.PunTurnManager
  #pragma pack(pop)
  static check_size<sizeof(PunTurnManager), 64 + sizeof(bool)> __Photon_Pun_UtilityScripts_PunTurnManagerSizeCheck;
  static_assert(sizeof(PunTurnManager) == 0x41);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::get_Turn
// Il2CppName: get_Turn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Photon::Pun::UtilityScripts::PunTurnManager::*)()>(&Photon::Pun::UtilityScripts::PunTurnManager::get_Turn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "get_Turn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::set_Turn
// Il2CppName: set_Turn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Photon::Pun::UtilityScripts::PunTurnManager::*)(int)>(&Photon::Pun::UtilityScripts::PunTurnManager::set_Turn)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "set_Turn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::get_ElapsedTimeInTurn
// Il2CppName: get_ElapsedTimeInTurn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Photon::Pun::UtilityScripts::PunTurnManager::*)()>(&Photon::Pun::UtilityScripts::PunTurnManager::get_ElapsedTimeInTurn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "get_ElapsedTimeInTurn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::get_RemainingSecondsInTurn
// Il2CppName: get_RemainingSecondsInTurn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Photon::Pun::UtilityScripts::PunTurnManager::*)()>(&Photon::Pun::UtilityScripts::PunTurnManager::get_RemainingSecondsInTurn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "get_RemainingSecondsInTurn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::get_IsCompletedByAll
// Il2CppName: get_IsCompletedByAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Photon::Pun::UtilityScripts::PunTurnManager::*)()>(&Photon::Pun::UtilityScripts::PunTurnManager::get_IsCompletedByAll)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "get_IsCompletedByAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::get_IsFinishedByMe
// Il2CppName: get_IsFinishedByMe
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Photon::Pun::UtilityScripts::PunTurnManager::*)()>(&Photon::Pun::UtilityScripts::PunTurnManager::get_IsFinishedByMe)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "get_IsFinishedByMe", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::get_IsOver
// Il2CppName: get_IsOver
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Photon::Pun::UtilityScripts::PunTurnManager::*)()>(&Photon::Pun::UtilityScripts::PunTurnManager::get_IsOver)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "get_IsOver", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Photon::Pun::UtilityScripts::PunTurnManager::*)()>(&Photon::Pun::UtilityScripts::PunTurnManager::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Photon::Pun::UtilityScripts::PunTurnManager::*)()>(&Photon::Pun::UtilityScripts::PunTurnManager::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::BeginTurn
// Il2CppName: BeginTurn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Photon::Pun::UtilityScripts::PunTurnManager::*)()>(&Photon::Pun::UtilityScripts::PunTurnManager::BeginTurn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "BeginTurn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::SendMove
// Il2CppName: SendMove
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Photon::Pun::UtilityScripts::PunTurnManager::*)(::Il2CppObject*, bool)>(&Photon::Pun::UtilityScripts::PunTurnManager::SendMove)> {
  static const MethodInfo* get() {
    static auto* move = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* finished = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "SendMove", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{move, finished});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::GetPlayerFinishedTurn
// Il2CppName: GetPlayerFinishedTurn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Photon::Pun::UtilityScripts::PunTurnManager::*)(::Photon::Realtime::Player*)>(&Photon::Pun::UtilityScripts::PunTurnManager::GetPlayerFinishedTurn)> {
  static const MethodInfo* get() {
    static auto* player = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "GetPlayerFinishedTurn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{player});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::ProcessOnEvent
// Il2CppName: ProcessOnEvent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Photon::Pun::UtilityScripts::PunTurnManager::*)(uint8_t, ::Il2CppObject*, int)>(&Photon::Pun::UtilityScripts::PunTurnManager::ProcessOnEvent)> {
  static const MethodInfo* get() {
    static auto* eventCode = &::il2cpp_utils::GetClassFromName("System", "Byte")->byval_arg;
    static auto* content = &::il2cpp_utils::GetClassFromName("System", "Object")->byval_arg;
    static auto* senderId = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "ProcessOnEvent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{eventCode, content, senderId});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::OnEvent
// Il2CppName: OnEvent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Photon::Pun::UtilityScripts::PunTurnManager::*)(::ExitGames::Client::Photon::EventData*)>(&Photon::Pun::UtilityScripts::PunTurnManager::OnEvent)> {
  static const MethodInfo* get() {
    static auto* photonEvent = &::il2cpp_utils::GetClassFromName("ExitGames.Client.Photon", "EventData")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "OnEvent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{photonEvent});
  }
};
// Writing MetadataGetter for method: Photon::Pun::UtilityScripts::PunTurnManager::OnRoomPropertiesUpdate
// Il2CppName: OnRoomPropertiesUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Photon::Pun::UtilityScripts::PunTurnManager::*)(::ExitGames::Client::Photon::Hashtable*)>(&Photon::Pun::UtilityScripts::PunTurnManager::OnRoomPropertiesUpdate)> {
  static const MethodInfo* get() {
    static auto* propertiesThatChanged = &::il2cpp_utils::GetClassFromName("ExitGames.Client.Photon", "Hashtable")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Photon::Pun::UtilityScripts::PunTurnManager*), "OnRoomPropertiesUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{propertiesThatChanged});
  }
};
