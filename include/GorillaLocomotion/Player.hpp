// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: UnityEngine.RaycastHit
#include "UnityEngine/RaycastHit.hpp"
// Including type: UnityEngine.LayerMask
#include "UnityEngine/LayerMask.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: MeshCollider
  class MeshCollider;
  // Forward declaring type: SphereCollider
  class SphereCollider;
  // Forward declaring type: CapsuleCollider
  class CapsuleCollider;
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: Rigidbody
  class Rigidbody;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: Collider
  class Collider;
  // Forward declaring type: Renderer
  class Renderer;
  // Forward declaring type: AudioClip
  class AudioClip;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: GorillaSurfaceOverride
  class GorillaSurfaceOverride;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Forward declaring namespace: GorillaLocomotion
namespace GorillaLocomotion {
  // Skipping declaration: MaterialData because it is already included!
}
// Completed forward declares
// Type namespace: GorillaLocomotion
namespace GorillaLocomotion {
  // Forward declaring type: Player
  class Player;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GorillaLocomotion::Player);
DEFINE_IL2CPP_ARG_TYPE(::GorillaLocomotion::Player*, "GorillaLocomotion", "Player");
// Type namespace: GorillaLocomotion
namespace GorillaLocomotion {
  // Size: 0x4E0
  #pragma pack(push, 1)
  // Autogenerated type: GorillaLocomotion.Player
  // [TokenAttribute] Offset: FFFFFFFF
  class Player : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GorillaLocomotion::Player::MaterialData
    struct MaterialData;
    // Size: 0x20
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: GorillaLocomotion.Player/GorillaLocomotion.MaterialData
    // [TokenAttribute] Offset: FFFFFFFF
    struct MaterialData/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.String matName
      // Size: 0x8
      // Offset: 0x0
      ::StringW matName;
      // Field size check
      static_assert(sizeof(::StringW) == 0x8);
      // public System.Boolean overrideAudio
      // Size: 0x1
      // Offset: 0x8
      bool overrideAudio;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // Padding between fields: overrideAudio and: audio
      char __padding1[0x7] = {};
      // public UnityEngine.AudioClip audio
      // Size: 0x8
      // Offset: 0x10
      ::UnityEngine::AudioClip* audio;
      // Field size check
      static_assert(sizeof(::UnityEngine::AudioClip*) == 0x8);
      // public System.Boolean overrideSlidePercent
      // Size: 0x1
      // Offset: 0x18
      bool overrideSlidePercent;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // Padding between fields: overrideSlidePercent and: slidePercent
      char __padding3[0x3] = {};
      // public System.Single slidePercent
      // Size: 0x4
      // Offset: 0x1C
      float slidePercent;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      public:
      // Creating value type constructor for type: MaterialData
      constexpr MaterialData(::StringW matName_ = {}, bool overrideAudio_ = {}, ::UnityEngine::AudioClip* audio_ = {}, bool overrideSlidePercent_ = {}, float slidePercent_ = {}) noexcept : matName{matName_}, overrideAudio{overrideAudio_}, audio{audio_}, overrideSlidePercent{overrideSlidePercent_}, slidePercent{slidePercent_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.String matName
      [[deprecated("Use field access instead!")]] ::StringW& dyn_matName();
      // Get instance field reference: public System.Boolean overrideAudio
      [[deprecated("Use field access instead!")]] bool& dyn_overrideAudio();
      // Get instance field reference: public UnityEngine.AudioClip audio
      [[deprecated("Use field access instead!")]] ::UnityEngine::AudioClip*& dyn_audio();
      // Get instance field reference: public System.Boolean overrideSlidePercent
      [[deprecated("Use field access instead!")]] bool& dyn_overrideSlidePercent();
      // Get instance field reference: public System.Single slidePercent
      [[deprecated("Use field access instead!")]] float& dyn_slidePercent();
    }; // GorillaLocomotion.Player/GorillaLocomotion.MaterialData
    #pragma pack(pop)
    static check_size<sizeof(Player::MaterialData), 28 + sizeof(float)> __GorillaLocomotion_Player_MaterialDataSizeCheck;
    static_assert(sizeof(Player::MaterialData) == 0x20);
    public:
    // public UnityEngine.SphereCollider headCollider
    // Size: 0x8
    // Offset: 0x18
    ::UnityEngine::SphereCollider* headCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::SphereCollider*) == 0x8);
    // public UnityEngine.CapsuleCollider bodyCollider
    // Size: 0x8
    // Offset: 0x20
    ::UnityEngine::CapsuleCollider* bodyCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::CapsuleCollider*) == 0x8);
    // private System.Single bodyInitialRadius
    // Size: 0x4
    // Offset: 0x28
    float bodyInitialRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single bodyInitialHeight
    // Size: 0x4
    // Offset: 0x2C
    float bodyInitialHeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.RaycastHit bodyHitInfo
    // Size: 0x2C
    // Offset: 0x30
    ::UnityEngine::RaycastHit bodyHitInfo;
    // Field size check
    static_assert(sizeof(::UnityEngine::RaycastHit) == 0x2C);
    // Padding between fields: bodyHitInfo and: leftHandFollower
    char __padding4[0x4] = {};
    // public UnityEngine.Transform leftHandFollower
    // Size: 0x8
    // Offset: 0x60
    ::UnityEngine::Transform* leftHandFollower;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform rightHandFollower
    // Size: 0x8
    // Offset: 0x68
    ::UnityEngine::Transform* rightHandFollower;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform rightHandTransform
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::Transform* rightHandTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform leftHandTransform
    // Size: 0x8
    // Offset: 0x78
    ::UnityEngine::Transform* leftHandTransform;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private UnityEngine.Vector3 lastLeftHandPosition
    // Size: 0xC
    // Offset: 0x80
    ::UnityEngine::Vector3 lastLeftHandPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 lastRightHandPosition
    // Size: 0xC
    // Offset: 0x8C
    ::UnityEngine::Vector3 lastRightHandPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Vector3 lastHeadPosition
    // Size: 0xC
    // Offset: 0x98
    ::UnityEngine::Vector3 lastHeadPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // Padding between fields: lastHeadPosition and: playerRigidBody
    char __padding11[0x4] = {};
    // private UnityEngine.Rigidbody playerRigidBody
    // Size: 0x8
    // Offset: 0xA8
    ::UnityEngine::Rigidbody* playerRigidBody;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // public System.Int32 velocityHistorySize
    // Size: 0x4
    // Offset: 0xB0
    int velocityHistorySize;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Single maxArmLength
    // Size: 0x4
    // Offset: 0xB4
    float maxArmLength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single unStickDistance
    // Size: 0x4
    // Offset: 0xB8
    float unStickDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single velocityLimit
    // Size: 0x4
    // Offset: 0xBC
    float velocityLimit;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single slideVelocityLimit
    // Size: 0x4
    // Offset: 0xC0
    float slideVelocityLimit;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single maxJumpSpeed
    // Size: 0x4
    // Offset: 0xC4
    float maxJumpSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single jumpMultiplier
    // Size: 0x4
    // Offset: 0xC8
    float jumpMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single minimumRaycastDistance
    // Size: 0x4
    // Offset: 0xCC
    float minimumRaycastDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single defaultSlideFactor
    // Size: 0x4
    // Offset: 0xD0
    float defaultSlideFactor;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single slidingMinimum
    // Size: 0x4
    // Offset: 0xD4
    float slidingMinimum;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single defaultPrecision
    // Size: 0x4
    // Offset: 0xD8
    float defaultPrecision;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single teleportThresholdNoVel
    // Size: 0x4
    // Offset: 0xDC
    float teleportThresholdNoVel;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single frictionConstant
    // Size: 0x4
    // Offset: 0xE0
    float frictionConstant;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single slideControl
    // Size: 0x4
    // Offset: 0xE4
    float slideControl;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single stickDepth
    // Size: 0x4
    // Offset: 0xE8
    float stickDepth;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: stickDepth and: velocityHistory
    char __padding27[0x4] = {};
    // private UnityEngine.Vector3[] velocityHistory
    // Size: 0x8
    // Offset: 0xF0
    ::ArrayW<::UnityEngine::Vector3> velocityHistory;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private UnityEngine.Vector3[] slideAverageHistory
    // Size: 0x8
    // Offset: 0xF8
    ::ArrayW<::UnityEngine::Vector3> slideAverageHistory;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private System.Int32 velocityIndex
    // Size: 0x4
    // Offset: 0x100
    int velocityIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private UnityEngine.Vector3 currentVelocity
    // Size: 0xC
    // Offset: 0x104
    ::UnityEngine::Vector3 currentVelocity;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 denormalizedVelocityAverage
    // Size: 0xC
    // Offset: 0x110
    ::UnityEngine::Vector3 denormalizedVelocityAverage;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 lastPosition
    // Size: 0xC
    // Offset: 0x11C
    ::UnityEngine::Vector3 lastPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Vector3 rightHandOffset
    // Size: 0xC
    // Offset: 0x128
    ::UnityEngine::Vector3 rightHandOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Vector3 leftHandOffset
    // Size: 0xC
    // Offset: 0x134
    ::UnityEngine::Vector3 leftHandOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Vector3 bodyOffset
    // Size: 0xC
    // Offset: 0x140
    ::UnityEngine::Vector3 bodyOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.LayerMask locomotionEnabledLayers
    // Size: 0x4
    // Offset: 0x14C
    ::UnityEngine::LayerMask locomotionEnabledLayers;
    // Field size check
    static_assert(sizeof(::UnityEngine::LayerMask) == 0x4);
    // public System.Boolean wasLeftHandTouching
    // Size: 0x1
    // Offset: 0x150
    bool wasLeftHandTouching;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean wasRightHandTouching
    // Size: 0x1
    // Offset: 0x151
    bool wasRightHandTouching;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean wasHeadTouching
    // Size: 0x1
    // Offset: 0x152
    bool wasHeadTouching;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: wasHeadTouching and: currentMaterialIndex
    char __padding40[0x1] = {};
    // public System.Int32 currentMaterialIndex
    // Size: 0x4
    // Offset: 0x154
    int currentMaterialIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Boolean leftHandSlide
    // Size: 0x1
    // Offset: 0x158
    bool leftHandSlide;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: leftHandSlide and: leftHandSlideNormal
    char __padding42[0x3] = {};
    // public UnityEngine.Vector3 leftHandSlideNormal
    // Size: 0xC
    // Offset: 0x15C
    ::UnityEngine::Vector3 leftHandSlideNormal;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public System.Boolean rightHandSlide
    // Size: 0x1
    // Offset: 0x168
    bool rightHandSlide;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: rightHandSlide and: rightHandSlideNormal
    char __padding44[0x3] = {};
    // public UnityEngine.Vector3 rightHandSlideNormal
    // Size: 0xC
    // Offset: 0x16C
    ::UnityEngine::Vector3 rightHandSlideNormal;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Vector3 headSlideNormal
    // Size: 0xC
    // Offset: 0x178
    ::UnityEngine::Vector3 headSlideNormal;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public System.Single rightHandSlipPercentage
    // Size: 0x4
    // Offset: 0x184
    float rightHandSlipPercentage;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single leftHandSlipPercentage
    // Size: 0x4
    // Offset: 0x188
    float leftHandSlipPercentage;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single headSlipPercentage
    // Size: 0x4
    // Offset: 0x18C
    float headSlipPercentage;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean wasLeftHandSlide
    // Size: 0x1
    // Offset: 0x190
    bool wasLeftHandSlide;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean wasRightHandSlide
    // Size: 0x1
    // Offset: 0x191
    bool wasRightHandSlide;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: wasRightHandSlide and: rightHandHitPoint
    char __padding51[0x2] = {};
    // public UnityEngine.Vector3 rightHandHitPoint
    // Size: 0xC
    // Offset: 0x194
    ::UnityEngine::Vector3 rightHandHitPoint;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Vector3 leftHandHitPoint
    // Size: 0xC
    // Offset: 0x1A0
    ::UnityEngine::Vector3 leftHandHitPoint;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public System.Boolean debugMovement
    // Size: 0x1
    // Offset: 0x1AC
    bool debugMovement;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean disableMovement
    // Size: 0x1
    // Offset: 0x1AD
    bool disableMovement;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean inOverlay
    // Size: 0x1
    // Offset: 0x1AE
    bool inOverlay;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean didATurn
    // Size: 0x1
    // Offset: 0x1AF
    bool didATurn;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public UnityEngine.GameObject turnParent
    // Size: 0x8
    // Offset: 0x1B0
    ::UnityEngine::GameObject* turnParent;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public System.Int32 leftHandMaterialTouchIndex
    // Size: 0x4
    // Offset: 0x1B8
    int leftHandMaterialTouchIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: leftHandMaterialTouchIndex and: leftHandSurfaceOverride
    char __padding59[0x4] = {};
    // public GorillaSurfaceOverride leftHandSurfaceOverride
    // Size: 0x8
    // Offset: 0x1C0
    ::GlobalNamespace::GorillaSurfaceOverride* leftHandSurfaceOverride;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::GorillaSurfaceOverride*) == 0x8);
    // public System.Int32 rightHandMaterialTouchIndex
    // Size: 0x4
    // Offset: 0x1C8
    int rightHandMaterialTouchIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: rightHandMaterialTouchIndex and: rightHandSurfaceOverride
    char __padding61[0x4] = {};
    // public GorillaSurfaceOverride rightHandSurfaceOverride
    // Size: 0x8
    // Offset: 0x1D0
    ::GlobalNamespace::GorillaSurfaceOverride* rightHandSurfaceOverride;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::GorillaSurfaceOverride*) == 0x8);
    // public GorillaSurfaceOverride currentOverride
    // Size: 0x8
    // Offset: 0x1D8
    ::GlobalNamespace::GorillaSurfaceOverride* currentOverride;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::GorillaSurfaceOverride*) == 0x8);
    // public System.Collections.Generic.List`1<GorillaLocomotion.Player/GorillaLocomotion.MaterialData> materialData
    // Size: 0x8
    // Offset: 0x1E0
    ::System::Collections::Generic::List_1<::GorillaLocomotion::Player::MaterialData>* materialData;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::GorillaLocomotion::Player::MaterialData>*) == 0x8);
    // private System.Boolean leftHandColliding
    // Size: 0x1
    // Offset: 0x1E8
    bool leftHandColliding;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean rightHandColliding
    // Size: 0x1
    // Offset: 0x1E9
    bool rightHandColliding;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean headColliding
    // Size: 0x1
    // Offset: 0x1EA
    bool headColliding;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: headColliding and: finalPosition
    char __padding67[0x1] = {};
    // private UnityEngine.Vector3 finalPosition
    // Size: 0xC
    // Offset: 0x1EC
    ::UnityEngine::Vector3 finalPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 rigidBodyMovement
    // Size: 0xC
    // Offset: 0x1F8
    ::UnityEngine::Vector3 rigidBodyMovement;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 firstIterationLeftHand
    // Size: 0xC
    // Offset: 0x204
    ::UnityEngine::Vector3 firstIterationLeftHand;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 firstIterationRightHand
    // Size: 0xC
    // Offset: 0x210
    ::UnityEngine::Vector3 firstIterationRightHand;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 firstIterationHead
    // Size: 0xC
    // Offset: 0x21C
    ::UnityEngine::Vector3 firstIterationHead;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.RaycastHit hitInfo
    // Size: 0x2C
    // Offset: 0x228
    ::UnityEngine::RaycastHit hitInfo;
    // Field size check
    static_assert(sizeof(::UnityEngine::RaycastHit) == 0x2C);
    // private UnityEngine.RaycastHit iterativeHitInfo
    // Size: 0x2C
    // Offset: 0x254
    ::UnityEngine::RaycastHit iterativeHitInfo;
    // Field size check
    static_assert(sizeof(::UnityEngine::RaycastHit) == 0x2C);
    // private UnityEngine.RaycastHit collisionsInnerHit
    // Size: 0x2C
    // Offset: 0x280
    ::UnityEngine::RaycastHit collisionsInnerHit;
    // Field size check
    static_assert(sizeof(::UnityEngine::RaycastHit) == 0x2C);
    // private System.Single slipPercentage
    // Size: 0x4
    // Offset: 0x2AC
    float slipPercentage;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 bodyOffsetVector
    // Size: 0xC
    // Offset: 0x2B0
    ::UnityEngine::Vector3 bodyOffsetVector;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 distanceTraveled
    // Size: 0xC
    // Offset: 0x2BC
    ::UnityEngine::Vector3 distanceTraveled;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 movementToProjectedAboveCollisionPlane
    // Size: 0xC
    // Offset: 0x2C8
    ::UnityEngine::Vector3 movementToProjectedAboveCollisionPlane;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // Padding between fields: movementToProjectedAboveCollisionPlane and: meshCollider
    char __padding79[0x4] = {};
    // private UnityEngine.MeshCollider meshCollider
    // Size: 0x8
    // Offset: 0x2D8
    ::UnityEngine::MeshCollider* meshCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::MeshCollider*) == 0x8);
    // private UnityEngine.Mesh collidedMesh
    // Size: 0x8
    // Offset: 0x2E0
    ::UnityEngine::Mesh* collidedMesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
    // private GorillaLocomotion.Player/GorillaLocomotion.MaterialData foundMatData
    // Size: 0x20
    // Offset: 0x2E8
    ::GorillaLocomotion::Player::MaterialData foundMatData;
    // Field size check
    static_assert(sizeof(::GorillaLocomotion::Player::MaterialData) == 0x20);
    // private System.String findMatName
    // Size: 0x8
    // Offset: 0x308
    ::StringW findMatName;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // private System.Int32 vertex1
    // Size: 0x4
    // Offset: 0x310
    int vertex1;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 vertex2
    // Size: 0x4
    // Offset: 0x314
    int vertex2;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 vertex3
    // Size: 0x4
    // Offset: 0x318
    int vertex3;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: vertex3 and: trianglesList
    char __padding86[0x4] = {};
    // private System.Collections.Generic.List`1<System.Int32> trianglesList
    // Size: 0x8
    // Offset: 0x320
    ::System::Collections::Generic::List_1<int>* trianglesList;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<int>*) == 0x8);
    // private System.Collections.Generic.List`1<UnityEngine.Material> materialsList
    // Size: 0x8
    // Offset: 0x328
    ::System::Collections::Generic::List_1<::UnityEngine::Material*>* materialsList;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Material*>*) == 0x8);
    // private System.Collections.Generic.Dictionary`2<UnityEngine.Mesh,System.Int32[]> meshTrianglesDict
    // Size: 0x8
    // Offset: 0x330
    ::System::Collections::Generic::Dictionary_2<::UnityEngine::Mesh*, ::ArrayW<int>>* meshTrianglesDict;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::UnityEngine::Mesh*, ::ArrayW<int>>*) == 0x8);
    // private System.Int32[] sharedMeshTris
    // Size: 0x8
    // Offset: 0x338
    ::ArrayW<int> sharedMeshTris;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // private System.Single lastRealTime
    // Size: 0x4
    // Offset: 0x340
    float lastRealTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single calcDeltaTime
    // Size: 0x4
    // Offset: 0x344
    float calcDeltaTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single tempRealTime
    // Size: 0x4
    // Offset: 0x348
    float tempRealTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 junkNormal
    // Size: 0xC
    // Offset: 0x34C
    ::UnityEngine::Vector3 junkNormal;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 slideAverage
    // Size: 0xC
    // Offset: 0x358
    ::UnityEngine::Vector3 slideAverage;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 slideAverageNormal
    // Size: 0xC
    // Offset: 0x364
    ::UnityEngine::Vector3 slideAverageNormal;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 tempVector3
    // Size: 0xC
    // Offset: 0x370
    ::UnityEngine::Vector3 tempVector3;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.RaycastHit tempHitInfo
    // Size: 0x2C
    // Offset: 0x37C
    ::UnityEngine::RaycastHit tempHitInfo;
    // Field size check
    static_assert(sizeof(::UnityEngine::RaycastHit) == 0x2C);
    // private UnityEngine.RaycastHit junkHit
    // Size: 0x2C
    // Offset: 0x3A8
    ::UnityEngine::RaycastHit junkHit;
    // Field size check
    static_assert(sizeof(::UnityEngine::RaycastHit) == 0x2C);
    // private UnityEngine.Vector3 firstPosition
    // Size: 0xC
    // Offset: 0x3D4
    ::UnityEngine::Vector3 firstPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.RaycastHit tempIterativeHit
    // Size: 0x2C
    // Offset: 0x3E0
    ::UnityEngine::RaycastHit tempIterativeHit;
    // Field size check
    static_assert(sizeof(::UnityEngine::RaycastHit) == 0x2C);
    // private System.Boolean collisionsReturnBool
    // Size: 0x1
    // Offset: 0x40C
    bool collisionsReturnBool;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: collisionsReturnBool and: overlapRadiusFunction
    char __padding102[0x3] = {};
    // private System.Single overlapRadiusFunction
    // Size: 0x4
    // Offset: 0x410
    float overlapRadiusFunction;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single maxSphereSize1
    // Size: 0x4
    // Offset: 0x414
    float maxSphereSize1;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single maxSphereSize2
    // Size: 0x4
    // Offset: 0x418
    float maxSphereSize2;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: maxSphereSize2 and: overlapColliders
    char __padding105[0x4] = {};
    // private UnityEngine.Collider[] overlapColliders
    // Size: 0x8
    // Offset: 0x420
    ::ArrayW<::UnityEngine::Collider*> overlapColliders;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Collider*>) == 0x8);
    // private System.Int32 overlapAttempts
    // Size: 0x4
    // Offset: 0x428
    int overlapAttempts;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 touchPoints
    // Size: 0x4
    // Offset: 0x42C
    int touchPoints;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Single averageSlipPercentage
    // Size: 0x4
    // Offset: 0x430
    float averageSlipPercentage;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 surfaceDirection
    // Size: 0xC
    // Offset: 0x434
    ::UnityEngine::Vector3 surfaceDirection;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public System.Single debugMagnitude
    // Size: 0x4
    // Offset: 0x440
    float debugMagnitude;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single iceThreshold
    // Size: 0x4
    // Offset: 0x444
    float iceThreshold;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single bodyMaxRadius
    // Size: 0x4
    // Offset: 0x448
    float bodyMaxRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single bodyLerp
    // Size: 0x4
    // Offset: 0x44C
    float bodyLerp;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean areBothTouching
    // Size: 0x1
    // Offset: 0x450
    bool areBothTouching;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: areBothTouching and: slideFactor
    char __padding115[0x3] = {};
    // private System.Single slideFactor
    // Size: 0x4
    // Offset: 0x454
    float slideFactor;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean didAJump
    // Size: 0x1
    // Offset: 0x458
    bool didAJump;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: didAJump and: slideRenderer
    char __padding117[0x7] = {};
    // private UnityEngine.Renderer slideRenderer
    // Size: 0x8
    // Offset: 0x460
    ::UnityEngine::Renderer* slideRenderer;
    // Field size check
    static_assert(sizeof(::UnityEngine::Renderer*) == 0x8);
    // private System.Boolean iterativeIsRoom
    // Size: 0x1
    // Offset: 0x468
    bool iterativeIsRoom;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean finalIsRoom
    // Size: 0x1
    // Offset: 0x469
    bool finalIsRoom;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean firstIsRoom
    // Size: 0x1
    // Offset: 0x46A
    bool firstIsRoom;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean mainIsRoom
    // Size: 0x1
    // Offset: 0x46B
    bool mainIsRoom;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Single iterativeSphereRadius
    // Size: 0x4
    // Offset: 0x46C
    float iterativeSphereRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.RaycastHit[] rayCastNonAllocColliders
    // Size: 0x8
    // Offset: 0x470
    ::ArrayW<::UnityEngine::RaycastHit> rayCastNonAllocColliders;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::RaycastHit>) == 0x8);
    // private UnityEngine.Collider[] rayCastNonAllocActuallyColliders
    // Size: 0x8
    // Offset: 0x478
    ::ArrayW<::UnityEngine::Collider*> rayCastNonAllocActuallyColliders;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Collider*>) == 0x8);
    // private UnityEngine.Vector3 tempVel
    // Size: 0xC
    // Offset: 0x480
    ::UnityEngine::Vector3 tempVel;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // Padding between fields: tempVel and: crazyCheckVectors
    char __padding126[0x4] = {};
    // private UnityEngine.Vector3[] crazyCheckVectors
    // Size: 0x8
    // Offset: 0x490
    ::ArrayW<::UnityEngine::Vector3> crazyCheckVectors;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private UnityEngine.RaycastHit emptyHit
    // Size: 0x2C
    // Offset: 0x498
    ::UnityEngine::RaycastHit emptyHit;
    // Field size check
    static_assert(sizeof(::UnityEngine::RaycastHit) == 0x2C);
    // private System.Int32 bufferCount
    // Size: 0x4
    // Offset: 0x4C4
    int bufferCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private UnityEngine.Vector3 lastOpenHeadPosition
    // Size: 0xC
    // Offset: 0x4C8
    ::UnityEngine::Vector3 lastOpenHeadPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // Padding between fields: lastOpenHeadPosition and: tempMaterialArray
    char __padding130[0x4] = {};
    // private System.Collections.Generic.List`1<UnityEngine.Material> tempMaterialArray
    // Size: 0x8
    // Offset: 0x4D8
    ::System::Collections::Generic::List_1<::UnityEngine::Material*>* tempMaterialArray;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Material*>*) == 0x8);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get static field: static private GorillaLocomotion.Player _instance
    static ::GorillaLocomotion::Player* _get__instance();
    // Set static field: static private GorillaLocomotion.Player _instance
    static void _set__instance(::GorillaLocomotion::Player* value);
    // Get instance field reference: public UnityEngine.SphereCollider headCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::SphereCollider*& dyn_headCollider();
    // Get instance field reference: public UnityEngine.CapsuleCollider bodyCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::CapsuleCollider*& dyn_bodyCollider();
    // Get instance field reference: private System.Single bodyInitialRadius
    [[deprecated("Use field access instead!")]] float& dyn_bodyInitialRadius();
    // Get instance field reference: private System.Single bodyInitialHeight
    [[deprecated("Use field access instead!")]] float& dyn_bodyInitialHeight();
    // Get instance field reference: private UnityEngine.RaycastHit bodyHitInfo
    [[deprecated("Use field access instead!")]] ::UnityEngine::RaycastHit& dyn_bodyHitInfo();
    // Get instance field reference: public UnityEngine.Transform leftHandFollower
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_leftHandFollower();
    // Get instance field reference: public UnityEngine.Transform rightHandFollower
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_rightHandFollower();
    // Get instance field reference: public UnityEngine.Transform rightHandTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_rightHandTransform();
    // Get instance field reference: public UnityEngine.Transform leftHandTransform
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_leftHandTransform();
    // Get instance field reference: private UnityEngine.Vector3 lastLeftHandPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_lastLeftHandPosition();
    // Get instance field reference: private UnityEngine.Vector3 lastRightHandPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_lastRightHandPosition();
    // Get instance field reference: public UnityEngine.Vector3 lastHeadPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_lastHeadPosition();
    // Get instance field reference: private UnityEngine.Rigidbody playerRigidBody
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_playerRigidBody();
    // Get instance field reference: public System.Int32 velocityHistorySize
    [[deprecated("Use field access instead!")]] int& dyn_velocityHistorySize();
    // Get instance field reference: public System.Single maxArmLength
    [[deprecated("Use field access instead!")]] float& dyn_maxArmLength();
    // Get instance field reference: public System.Single unStickDistance
    [[deprecated("Use field access instead!")]] float& dyn_unStickDistance();
    // Get instance field reference: public System.Single velocityLimit
    [[deprecated("Use field access instead!")]] float& dyn_velocityLimit();
    // Get instance field reference: public System.Single slideVelocityLimit
    [[deprecated("Use field access instead!")]] float& dyn_slideVelocityLimit();
    // Get instance field reference: public System.Single maxJumpSpeed
    [[deprecated("Use field access instead!")]] float& dyn_maxJumpSpeed();
    // Get instance field reference: public System.Single jumpMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_jumpMultiplier();
    // Get instance field reference: public System.Single minimumRaycastDistance
    [[deprecated("Use field access instead!")]] float& dyn_minimumRaycastDistance();
    // Get instance field reference: public System.Single defaultSlideFactor
    [[deprecated("Use field access instead!")]] float& dyn_defaultSlideFactor();
    // Get instance field reference: public System.Single slidingMinimum
    [[deprecated("Use field access instead!")]] float& dyn_slidingMinimum();
    // Get instance field reference: public System.Single defaultPrecision
    [[deprecated("Use field access instead!")]] float& dyn_defaultPrecision();
    // Get instance field reference: public System.Single teleportThresholdNoVel
    [[deprecated("Use field access instead!")]] float& dyn_teleportThresholdNoVel();
    // Get instance field reference: public System.Single frictionConstant
    [[deprecated("Use field access instead!")]] float& dyn_frictionConstant();
    // Get instance field reference: public System.Single slideControl
    [[deprecated("Use field access instead!")]] float& dyn_slideControl();
    // Get instance field reference: public System.Single stickDepth
    [[deprecated("Use field access instead!")]] float& dyn_stickDepth();
    // Get instance field reference: private UnityEngine.Vector3[] velocityHistory
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_velocityHistory();
    // Get instance field reference: private UnityEngine.Vector3[] slideAverageHistory
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_slideAverageHistory();
    // Get instance field reference: private System.Int32 velocityIndex
    [[deprecated("Use field access instead!")]] int& dyn_velocityIndex();
    // Get instance field reference: private UnityEngine.Vector3 currentVelocity
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_currentVelocity();
    // Get instance field reference: private UnityEngine.Vector3 denormalizedVelocityAverage
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_denormalizedVelocityAverage();
    // Get instance field reference: private UnityEngine.Vector3 lastPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_lastPosition();
    // Get instance field reference: public UnityEngine.Vector3 rightHandOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_rightHandOffset();
    // Get instance field reference: public UnityEngine.Vector3 leftHandOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_leftHandOffset();
    // Get instance field reference: public UnityEngine.Vector3 bodyOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_bodyOffset();
    // Get instance field reference: public UnityEngine.LayerMask locomotionEnabledLayers
    [[deprecated("Use field access instead!")]] ::UnityEngine::LayerMask& dyn_locomotionEnabledLayers();
    // Get instance field reference: public System.Boolean wasLeftHandTouching
    [[deprecated("Use field access instead!")]] bool& dyn_wasLeftHandTouching();
    // Get instance field reference: public System.Boolean wasRightHandTouching
    [[deprecated("Use field access instead!")]] bool& dyn_wasRightHandTouching();
    // Get instance field reference: public System.Boolean wasHeadTouching
    [[deprecated("Use field access instead!")]] bool& dyn_wasHeadTouching();
    // Get instance field reference: public System.Int32 currentMaterialIndex
    [[deprecated("Use field access instead!")]] int& dyn_currentMaterialIndex();
    // Get instance field reference: public System.Boolean leftHandSlide
    [[deprecated("Use field access instead!")]] bool& dyn_leftHandSlide();
    // Get instance field reference: public UnityEngine.Vector3 leftHandSlideNormal
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_leftHandSlideNormal();
    // Get instance field reference: public System.Boolean rightHandSlide
    [[deprecated("Use field access instead!")]] bool& dyn_rightHandSlide();
    // Get instance field reference: public UnityEngine.Vector3 rightHandSlideNormal
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_rightHandSlideNormal();
    // Get instance field reference: public UnityEngine.Vector3 headSlideNormal
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_headSlideNormal();
    // Get instance field reference: public System.Single rightHandSlipPercentage
    [[deprecated("Use field access instead!")]] float& dyn_rightHandSlipPercentage();
    // Get instance field reference: public System.Single leftHandSlipPercentage
    [[deprecated("Use field access instead!")]] float& dyn_leftHandSlipPercentage();
    // Get instance field reference: public System.Single headSlipPercentage
    [[deprecated("Use field access instead!")]] float& dyn_headSlipPercentage();
    // Get instance field reference: public System.Boolean wasLeftHandSlide
    [[deprecated("Use field access instead!")]] bool& dyn_wasLeftHandSlide();
    // Get instance field reference: public System.Boolean wasRightHandSlide
    [[deprecated("Use field access instead!")]] bool& dyn_wasRightHandSlide();
    // Get instance field reference: public UnityEngine.Vector3 rightHandHitPoint
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_rightHandHitPoint();
    // Get instance field reference: public UnityEngine.Vector3 leftHandHitPoint
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_leftHandHitPoint();
    // Get instance field reference: public System.Boolean debugMovement
    [[deprecated("Use field access instead!")]] bool& dyn_debugMovement();
    // Get instance field reference: public System.Boolean disableMovement
    [[deprecated("Use field access instead!")]] bool& dyn_disableMovement();
    // Get instance field reference: public System.Boolean inOverlay
    [[deprecated("Use field access instead!")]] bool& dyn_inOverlay();
    // Get instance field reference: public System.Boolean didATurn
    [[deprecated("Use field access instead!")]] bool& dyn_didATurn();
    // Get instance field reference: public UnityEngine.GameObject turnParent
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_turnParent();
    // Get instance field reference: public System.Int32 leftHandMaterialTouchIndex
    [[deprecated("Use field access instead!")]] int& dyn_leftHandMaterialTouchIndex();
    // Get instance field reference: public GorillaSurfaceOverride leftHandSurfaceOverride
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::GorillaSurfaceOverride*& dyn_leftHandSurfaceOverride();
    // Get instance field reference: public System.Int32 rightHandMaterialTouchIndex
    [[deprecated("Use field access instead!")]] int& dyn_rightHandMaterialTouchIndex();
    // Get instance field reference: public GorillaSurfaceOverride rightHandSurfaceOverride
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::GorillaSurfaceOverride*& dyn_rightHandSurfaceOverride();
    // Get instance field reference: public GorillaSurfaceOverride currentOverride
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::GorillaSurfaceOverride*& dyn_currentOverride();
    // Get instance field reference: public System.Collections.Generic.List`1<GorillaLocomotion.Player/GorillaLocomotion.MaterialData> materialData
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::GorillaLocomotion::Player::MaterialData>*& dyn_materialData();
    // Get instance field reference: private System.Boolean leftHandColliding
    [[deprecated("Use field access instead!")]] bool& dyn_leftHandColliding();
    // Get instance field reference: private System.Boolean rightHandColliding
    [[deprecated("Use field access instead!")]] bool& dyn_rightHandColliding();
    // Get instance field reference: private System.Boolean headColliding
    [[deprecated("Use field access instead!")]] bool& dyn_headColliding();
    // Get instance field reference: private UnityEngine.Vector3 finalPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_finalPosition();
    // Get instance field reference: private UnityEngine.Vector3 rigidBodyMovement
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_rigidBodyMovement();
    // Get instance field reference: private UnityEngine.Vector3 firstIterationLeftHand
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_firstIterationLeftHand();
    // Get instance field reference: private UnityEngine.Vector3 firstIterationRightHand
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_firstIterationRightHand();
    // Get instance field reference: private UnityEngine.Vector3 firstIterationHead
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_firstIterationHead();
    // Get instance field reference: private UnityEngine.RaycastHit hitInfo
    [[deprecated("Use field access instead!")]] ::UnityEngine::RaycastHit& dyn_hitInfo();
    // Get instance field reference: private UnityEngine.RaycastHit iterativeHitInfo
    [[deprecated("Use field access instead!")]] ::UnityEngine::RaycastHit& dyn_iterativeHitInfo();
    // Get instance field reference: private UnityEngine.RaycastHit collisionsInnerHit
    [[deprecated("Use field access instead!")]] ::UnityEngine::RaycastHit& dyn_collisionsInnerHit();
    // Get instance field reference: private System.Single slipPercentage
    [[deprecated("Use field access instead!")]] float& dyn_slipPercentage();
    // Get instance field reference: private UnityEngine.Vector3 bodyOffsetVector
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_bodyOffsetVector();
    // Get instance field reference: private UnityEngine.Vector3 distanceTraveled
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_distanceTraveled();
    // Get instance field reference: private UnityEngine.Vector3 movementToProjectedAboveCollisionPlane
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_movementToProjectedAboveCollisionPlane();
    // Get instance field reference: private UnityEngine.MeshCollider meshCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::MeshCollider*& dyn_meshCollider();
    // Get instance field reference: private UnityEngine.Mesh collidedMesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::Mesh*& dyn_collidedMesh();
    // Get instance field reference: private GorillaLocomotion.Player/GorillaLocomotion.MaterialData foundMatData
    [[deprecated("Use field access instead!")]] ::GorillaLocomotion::Player::MaterialData& dyn_foundMatData();
    // Get instance field reference: private System.String findMatName
    [[deprecated("Use field access instead!")]] ::StringW& dyn_findMatName();
    // Get instance field reference: private System.Int32 vertex1
    [[deprecated("Use field access instead!")]] int& dyn_vertex1();
    // Get instance field reference: private System.Int32 vertex2
    [[deprecated("Use field access instead!")]] int& dyn_vertex2();
    // Get instance field reference: private System.Int32 vertex3
    [[deprecated("Use field access instead!")]] int& dyn_vertex3();
    // Get instance field reference: private System.Collections.Generic.List`1<System.Int32> trianglesList
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<int>*& dyn_trianglesList();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.Material> materialsList
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::Material*>*& dyn_materialsList();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<UnityEngine.Mesh,System.Int32[]> meshTrianglesDict
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::UnityEngine::Mesh*, ::ArrayW<int>>*& dyn_meshTrianglesDict();
    // Get instance field reference: private System.Int32[] sharedMeshTris
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_sharedMeshTris();
    // Get instance field reference: private System.Single lastRealTime
    [[deprecated("Use field access instead!")]] float& dyn_lastRealTime();
    // Get instance field reference: private System.Single calcDeltaTime
    [[deprecated("Use field access instead!")]] float& dyn_calcDeltaTime();
    // Get instance field reference: private System.Single tempRealTime
    [[deprecated("Use field access instead!")]] float& dyn_tempRealTime();
    // Get instance field reference: private UnityEngine.Vector3 junkNormal
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_junkNormal();
    // Get instance field reference: private UnityEngine.Vector3 slideAverage
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_slideAverage();
    // Get instance field reference: private UnityEngine.Vector3 slideAverageNormal
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_slideAverageNormal();
    // Get instance field reference: private UnityEngine.Vector3 tempVector3
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_tempVector3();
    // Get instance field reference: private UnityEngine.RaycastHit tempHitInfo
    [[deprecated("Use field access instead!")]] ::UnityEngine::RaycastHit& dyn_tempHitInfo();
    // Get instance field reference: private UnityEngine.RaycastHit junkHit
    [[deprecated("Use field access instead!")]] ::UnityEngine::RaycastHit& dyn_junkHit();
    // Get instance field reference: private UnityEngine.Vector3 firstPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_firstPosition();
    // Get instance field reference: private UnityEngine.RaycastHit tempIterativeHit
    [[deprecated("Use field access instead!")]] ::UnityEngine::RaycastHit& dyn_tempIterativeHit();
    // Get instance field reference: private System.Boolean collisionsReturnBool
    [[deprecated("Use field access instead!")]] bool& dyn_collisionsReturnBool();
    // Get instance field reference: private System.Single overlapRadiusFunction
    [[deprecated("Use field access instead!")]] float& dyn_overlapRadiusFunction();
    // Get instance field reference: private System.Single maxSphereSize1
    [[deprecated("Use field access instead!")]] float& dyn_maxSphereSize1();
    // Get instance field reference: private System.Single maxSphereSize2
    [[deprecated("Use field access instead!")]] float& dyn_maxSphereSize2();
    // Get instance field reference: private UnityEngine.Collider[] overlapColliders
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Collider*>& dyn_overlapColliders();
    // Get instance field reference: private System.Int32 overlapAttempts
    [[deprecated("Use field access instead!")]] int& dyn_overlapAttempts();
    // Get instance field reference: private System.Int32 touchPoints
    [[deprecated("Use field access instead!")]] int& dyn_touchPoints();
    // Get instance field reference: private System.Single averageSlipPercentage
    [[deprecated("Use field access instead!")]] float& dyn_averageSlipPercentage();
    // Get instance field reference: private UnityEngine.Vector3 surfaceDirection
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_surfaceDirection();
    // Get instance field reference: public System.Single debugMagnitude
    [[deprecated("Use field access instead!")]] float& dyn_debugMagnitude();
    // Get instance field reference: public System.Single iceThreshold
    [[deprecated("Use field access instead!")]] float& dyn_iceThreshold();
    // Get instance field reference: private System.Single bodyMaxRadius
    [[deprecated("Use field access instead!")]] float& dyn_bodyMaxRadius();
    // Get instance field reference: public System.Single bodyLerp
    [[deprecated("Use field access instead!")]] float& dyn_bodyLerp();
    // Get instance field reference: private System.Boolean areBothTouching
    [[deprecated("Use field access instead!")]] bool& dyn_areBothTouching();
    // Get instance field reference: private System.Single slideFactor
    [[deprecated("Use field access instead!")]] float& dyn_slideFactor();
    // Get instance field reference: public System.Boolean didAJump
    [[deprecated("Use field access instead!")]] bool& dyn_didAJump();
    // Get instance field reference: private UnityEngine.Renderer slideRenderer
    [[deprecated("Use field access instead!")]] ::UnityEngine::Renderer*& dyn_slideRenderer();
    // Get instance field reference: private System.Boolean iterativeIsRoom
    [[deprecated("Use field access instead!")]] bool& dyn_iterativeIsRoom();
    // Get instance field reference: private System.Boolean finalIsRoom
    [[deprecated("Use field access instead!")]] bool& dyn_finalIsRoom();
    // Get instance field reference: private System.Boolean firstIsRoom
    [[deprecated("Use field access instead!")]] bool& dyn_firstIsRoom();
    // Get instance field reference: private System.Boolean mainIsRoom
    [[deprecated("Use field access instead!")]] bool& dyn_mainIsRoom();
    // Get instance field reference: private System.Single iterativeSphereRadius
    [[deprecated("Use field access instead!")]] float& dyn_iterativeSphereRadius();
    // Get instance field reference: private UnityEngine.RaycastHit[] rayCastNonAllocColliders
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::RaycastHit>& dyn_rayCastNonAllocColliders();
    // Get instance field reference: private UnityEngine.Collider[] rayCastNonAllocActuallyColliders
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Collider*>& dyn_rayCastNonAllocActuallyColliders();
    // Get instance field reference: private UnityEngine.Vector3 tempVel
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_tempVel();
    // Get instance field reference: private UnityEngine.Vector3[] crazyCheckVectors
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_crazyCheckVectors();
    // Get instance field reference: private UnityEngine.RaycastHit emptyHit
    [[deprecated("Use field access instead!")]] ::UnityEngine::RaycastHit& dyn_emptyHit();
    // Get instance field reference: private System.Int32 bufferCount
    [[deprecated("Use field access instead!")]] int& dyn_bufferCount();
    // Get instance field reference: private UnityEngine.Vector3 lastOpenHeadPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_lastOpenHeadPosition();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.Material> tempMaterialArray
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::Material*>*& dyn_tempMaterialArray();
    // static public GorillaLocomotion.Player get_Instance()
    // Offset: 0xDB1B30
    static ::GorillaLocomotion::Player* get_Instance();
    // public System.Void .ctor()
    // Offset: 0xDB7288
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Player* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GorillaLocomotion::Player::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Player*, creationType>()));
    }
    // private System.Void Awake()
    // Offset: 0xDB1B80
    void Awake();
    // public System.Void InitializeValues()
    // Offset: 0xDB1EA8
    void InitializeValues();
    // public System.Void FixedUpdate()
    // Offset: 0xDB20C0
    void FixedUpdate();
    // private System.Void BodyCollider()
    // Offset: 0xDB22C8
    void BodyCollider();
    // private UnityEngine.Vector3 CurrentHandPosition(UnityEngine.Transform handTransform, UnityEngine.Vector3 handOffset)
    // Offset: 0xDB28F8
    ::UnityEngine::Vector3 CurrentHandPosition(::UnityEngine::Transform* handTransform, ::UnityEngine::Vector3 handOffset);
    // private UnityEngine.Vector3 CurrentLeftHandPosition()
    // Offset: 0xDB2BE0
    ::UnityEngine::Vector3 CurrentLeftHandPosition();
    // private UnityEngine.Vector3 CurrentRightHandPosition()
    // Offset: 0xDB2EB0
    ::UnityEngine::Vector3 CurrentRightHandPosition();
    // private UnityEngine.Vector3 PositionWithOffset(UnityEngine.Transform transformToModify, UnityEngine.Vector3 offsetVector)
    // Offset: 0xDB26BC
    ::UnityEngine::Vector3 PositionWithOffset(::UnityEngine::Transform* transformToModify, ::UnityEngine::Vector3 offsetVector);
    // private System.Void LateUpdate()
    // Offset: 0xDB3180
    void LateUpdate();
    // private System.Void FirstHandIteration(UnityEngine.Transform handTransform, UnityEngine.Vector3 handOffset, UnityEngine.Vector3 lastHandPosition, System.Boolean wasHandSlide, System.Boolean wasHandTouching, out UnityEngine.Vector3 firstIteration, ref System.Single handSlipPercentage, ref System.Boolean handSlide, ref UnityEngine.Vector3 slideNormal, ref System.Boolean handColliding, ref System.Int32 materialTouchIndex, ref GorillaSurfaceOverride touchedOverride)
    // Offset: 0xDB4E3C
    void FirstHandIteration(::UnityEngine::Transform* handTransform, ::UnityEngine::Vector3 handOffset, ::UnityEngine::Vector3 lastHandPosition, bool wasHandSlide, bool wasHandTouching, ByRef<::UnityEngine::Vector3> firstIteration, ByRef<float> handSlipPercentage, ByRef<bool> handSlide, ByRef<::UnityEngine::Vector3> slideNormal, ByRef<bool> handColliding, ByRef<int> materialTouchIndex, ByRef<::GlobalNamespace::GorillaSurfaceOverride*> touchedOverride);
    // private UnityEngine.Vector3 FinalHandPosition(UnityEngine.Transform handTransform, UnityEngine.Vector3 handOffset, UnityEngine.Vector3 lastHandPosition, System.Boolean bothTouching, System.Boolean isHandTouching, out System.Boolean handColliding, System.Boolean isHandSlide, out System.Boolean handSlide, System.Int32 currentMaterialTouchIndex, out System.Int32 materialTouchIndex, GorillaSurfaceOverride currentSurface, out GorillaSurfaceOverride touchedOverride)
    // Offset: 0xDB5740
    ::UnityEngine::Vector3 FinalHandPosition(::UnityEngine::Transform* handTransform, ::UnityEngine::Vector3 handOffset, ::UnityEngine::Vector3 lastHandPosition, bool bothTouching, bool isHandTouching, ByRef<bool> handColliding, bool isHandSlide, ByRef<bool> handSlide, int currentMaterialTouchIndex, ByRef<int> materialTouchIndex, ::GlobalNamespace::GorillaSurfaceOverride* currentSurface, ByRef<::GlobalNamespace::GorillaSurfaceOverride*> touchedOverride);
    // private System.Boolean IterativeCollisionSphereCast(UnityEngine.Vector3 startPosition, System.Single sphereRadius, UnityEngine.Vector3 movementVector, out UnityEngine.Vector3 endPosition, System.Boolean singleHand, out System.Single slipPercentage, out UnityEngine.RaycastHit iterativeHitInfo, System.Boolean fullSlide)
    // Offset: 0xDB5398
    bool IterativeCollisionSphereCast(::UnityEngine::Vector3 startPosition, float sphereRadius, ::UnityEngine::Vector3 movementVector, ByRef<::UnityEngine::Vector3> endPosition, bool singleHand, ByRef<float> slipPercentage, ByRef<::UnityEngine::RaycastHit> iterativeHitInfo, bool fullSlide);
    // private System.Boolean CollisionsSphereCast(UnityEngine.Vector3 startPosition, System.Single sphereRadius, UnityEngine.Vector3 movementVector, out UnityEngine.Vector3 finalPosition, out UnityEngine.RaycastHit collisionsHitInfo)
    // Offset: 0xDB5B74
    bool CollisionsSphereCast(::UnityEngine::Vector3 startPosition, float sphereRadius, ::UnityEngine::Vector3 movementVector, ByRef<::UnityEngine::Vector3> finalPosition, ByRef<::UnityEngine::RaycastHit> collisionsHitInfo);
    // public System.Boolean IsHandTouching(System.Boolean forLeftHand)
    // Offset: 0xDB6E38
    bool IsHandTouching(bool forLeftHand);
    // public System.Boolean IsHandSliding(System.Boolean forLeftHand)
    // Offset: 0xDB6E4C
    bool IsHandSliding(bool forLeftHand);
    // public System.Single GetSlidePercentage(UnityEngine.RaycastHit raycastHit)
    // Offset: 0xDB675C
    float GetSlidePercentage(::UnityEngine::RaycastHit raycastHit);
    // public System.Void Turn(System.Single degrees)
    // Offset: 0xDB6E80
    void Turn(float degrees);
    // private System.Void StoreVelocities()
    // Offset: 0xDB5924
    void StoreVelocities();
    // private System.Void AntiTeleportTechnology()
    // Offset: 0xDB20C4
    void AntiTeleportTechnology();
    // private System.Boolean MaxSphereSizeForNoOverlap(System.Single testRadius, UnityEngine.Vector3 checkPosition, out System.Single overlapRadiusTest)
    // Offset: 0xDB27F0
    bool MaxSphereSizeForNoOverlap(float testRadius, ::UnityEngine::Vector3 checkPosition, ByRef<float> overlapRadiusTest);
    // private System.Boolean CrazyCheck2(System.Single sphereSize, UnityEngine.Vector3 startPosition)
    // Offset: 0xDB5244
    bool CrazyCheck2(float sphereSize, ::UnityEngine::Vector3 startPosition);
    // private System.Int32 NonAllocRaycast(UnityEngine.Vector3 startPosition, UnityEngine.Vector3 endPosition)
    // Offset: 0xDB7128
    int NonAllocRaycast(::UnityEngine::Vector3 startPosition, ::UnityEngine::Vector3 endPosition);
    // private System.Void ClearColliderBuffer(ref UnityEngine.Collider[] colliders)
    // Offset: 0xDB70D4
    void ClearColliderBuffer(ByRef<::ArrayW<::UnityEngine::Collider*>> colliders);
    // private System.Void ClearRaycasthitBuffer(ref UnityEngine.RaycastHit[] raycastHits)
    // Offset: 0xDB6DB4
    void ClearRaycasthitBuffer(ByRef<::ArrayW<::UnityEngine::RaycastHit>> raycastHits);
    // private System.Boolean <GetSlidePercentage>b__151_2(GorillaLocomotion.Player/GorillaLocomotion.MaterialData matData)
    // Offset: 0xDB73CC
    bool $GetSlidePercentage$b__151_2(::GorillaLocomotion::Player::MaterialData matData);
    // private System.Boolean <GetSlidePercentage>b__151_3(GorillaLocomotion.Player/GorillaLocomotion.MaterialData matData)
    // Offset: 0xDB73E0
    bool $GetSlidePercentage$b__151_3(::GorillaLocomotion::Player::MaterialData matData);
    // private System.Boolean <GetSlidePercentage>b__151_0(GorillaLocomotion.Player/GorillaLocomotion.MaterialData matData)
    // Offset: 0xDB73F4
    bool $GetSlidePercentage$b__151_0(::GorillaLocomotion::Player::MaterialData matData);
    // private System.Boolean <GetSlidePercentage>b__151_1(GorillaLocomotion.Player/GorillaLocomotion.MaterialData matData)
    // Offset: 0xDB7408
    bool $GetSlidePercentage$b__151_1(::GorillaLocomotion::Player::MaterialData matData);
  }; // GorillaLocomotion.Player
  #pragma pack(pop)
  static check_size<sizeof(Player), 1240 + sizeof(::System::Collections::Generic::List_1<::UnityEngine::Material*>*)> __GorillaLocomotion_PlayerSizeCheck;
  static_assert(sizeof(Player) == 0x4E0);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GorillaLocomotion::Player::MaterialData, "GorillaLocomotion", "Player/MaterialData");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GorillaLocomotion::Player::get_Instance
// Il2CppName: get_Instance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GorillaLocomotion::Player* (*)()>(&GorillaLocomotion::Player::get_Instance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "get_Instance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GorillaLocomotion::Player::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)()>(&GorillaLocomotion::Player::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::InitializeValues
// Il2CppName: InitializeValues
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)()>(&GorillaLocomotion::Player::InitializeValues)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "InitializeValues", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::FixedUpdate
// Il2CppName: FixedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)()>(&GorillaLocomotion::Player::FixedUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "FixedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::BodyCollider
// Il2CppName: BodyCollider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)()>(&GorillaLocomotion::Player::BodyCollider)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "BodyCollider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::CurrentHandPosition
// Il2CppName: CurrentHandPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GorillaLocomotion::Player::*)(::UnityEngine::Transform*, ::UnityEngine::Vector3)>(&GorillaLocomotion::Player::CurrentHandPosition)> {
  static const MethodInfo* get() {
    static auto* handTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* handOffset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "CurrentHandPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{handTransform, handOffset});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::CurrentLeftHandPosition
// Il2CppName: CurrentLeftHandPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GorillaLocomotion::Player::*)()>(&GorillaLocomotion::Player::CurrentLeftHandPosition)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "CurrentLeftHandPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::CurrentRightHandPosition
// Il2CppName: CurrentRightHandPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GorillaLocomotion::Player::*)()>(&GorillaLocomotion::Player::CurrentRightHandPosition)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "CurrentRightHandPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::PositionWithOffset
// Il2CppName: PositionWithOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GorillaLocomotion::Player::*)(::UnityEngine::Transform*, ::UnityEngine::Vector3)>(&GorillaLocomotion::Player::PositionWithOffset)> {
  static const MethodInfo* get() {
    static auto* transformToModify = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* offsetVector = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "PositionWithOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{transformToModify, offsetVector});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)()>(&GorillaLocomotion::Player::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::FirstHandIteration
// Il2CppName: FirstHandIteration
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)(::UnityEngine::Transform*, ::UnityEngine::Vector3, ::UnityEngine::Vector3, bool, bool, ByRef<::UnityEngine::Vector3>, ByRef<float>, ByRef<bool>, ByRef<::UnityEngine::Vector3>, ByRef<bool>, ByRef<int>, ByRef<::GlobalNamespace::GorillaSurfaceOverride*>)>(&GorillaLocomotion::Player::FirstHandIteration)> {
  static const MethodInfo* get() {
    static auto* handTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* handOffset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* lastHandPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* wasHandSlide = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* wasHandTouching = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* firstIteration = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* handSlipPercentage = &::il2cpp_utils::GetClassFromName("System", "Single")->this_arg;
    static auto* handSlide = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    static auto* slideNormal = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* handColliding = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    static auto* materialTouchIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* touchedOverride = &::il2cpp_utils::GetClassFromName("", "GorillaSurfaceOverride")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "FirstHandIteration", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{handTransform, handOffset, lastHandPosition, wasHandSlide, wasHandTouching, firstIteration, handSlipPercentage, handSlide, slideNormal, handColliding, materialTouchIndex, touchedOverride});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::FinalHandPosition
// Il2CppName: FinalHandPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GorillaLocomotion::Player::*)(::UnityEngine::Transform*, ::UnityEngine::Vector3, ::UnityEngine::Vector3, bool, bool, ByRef<bool>, bool, ByRef<bool>, int, ByRef<int>, ::GlobalNamespace::GorillaSurfaceOverride*, ByRef<::GlobalNamespace::GorillaSurfaceOverride*>)>(&GorillaLocomotion::Player::FinalHandPosition)> {
  static const MethodInfo* get() {
    static auto* handTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* handOffset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* lastHandPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* bothTouching = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* isHandTouching = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* handColliding = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    static auto* isHandSlide = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* handSlide = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    static auto* currentMaterialTouchIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* materialTouchIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* currentSurface = &::il2cpp_utils::GetClassFromName("", "GorillaSurfaceOverride")->byval_arg;
    static auto* touchedOverride = &::il2cpp_utils::GetClassFromName("", "GorillaSurfaceOverride")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "FinalHandPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{handTransform, handOffset, lastHandPosition, bothTouching, isHandTouching, handColliding, isHandSlide, handSlide, currentMaterialTouchIndex, materialTouchIndex, currentSurface, touchedOverride});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::IterativeCollisionSphereCast
// Il2CppName: IterativeCollisionSphereCast
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(::UnityEngine::Vector3, float, ::UnityEngine::Vector3, ByRef<::UnityEngine::Vector3>, bool, ByRef<float>, ByRef<::UnityEngine::RaycastHit>, bool)>(&GorillaLocomotion::Player::IterativeCollisionSphereCast)> {
  static const MethodInfo* get() {
    static auto* startPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* sphereRadius = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* movementVector = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* endPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* singleHand = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* slipPercentage = &::il2cpp_utils::GetClassFromName("System", "Single")->this_arg;
    static auto* iterativeHitInfo = &::il2cpp_utils::GetClassFromName("UnityEngine", "RaycastHit")->this_arg;
    static auto* fullSlide = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "IterativeCollisionSphereCast", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{startPosition, sphereRadius, movementVector, endPosition, singleHand, slipPercentage, iterativeHitInfo, fullSlide});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::CollisionsSphereCast
// Il2CppName: CollisionsSphereCast
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(::UnityEngine::Vector3, float, ::UnityEngine::Vector3, ByRef<::UnityEngine::Vector3>, ByRef<::UnityEngine::RaycastHit>)>(&GorillaLocomotion::Player::CollisionsSphereCast)> {
  static const MethodInfo* get() {
    static auto* startPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* sphereRadius = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* movementVector = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* finalPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* collisionsHitInfo = &::il2cpp_utils::GetClassFromName("UnityEngine", "RaycastHit")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "CollisionsSphereCast", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{startPosition, sphereRadius, movementVector, finalPosition, collisionsHitInfo});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::IsHandTouching
// Il2CppName: IsHandTouching
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(bool)>(&GorillaLocomotion::Player::IsHandTouching)> {
  static const MethodInfo* get() {
    static auto* forLeftHand = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "IsHandTouching", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{forLeftHand});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::IsHandSliding
// Il2CppName: IsHandSliding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(bool)>(&GorillaLocomotion::Player::IsHandSliding)> {
  static const MethodInfo* get() {
    static auto* forLeftHand = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "IsHandSliding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{forLeftHand});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::GetSlidePercentage
// Il2CppName: GetSlidePercentage
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (GorillaLocomotion::Player::*)(::UnityEngine::RaycastHit)>(&GorillaLocomotion::Player::GetSlidePercentage)> {
  static const MethodInfo* get() {
    static auto* raycastHit = &::il2cpp_utils::GetClassFromName("UnityEngine", "RaycastHit")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "GetSlidePercentage", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{raycastHit});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::Turn
// Il2CppName: Turn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)(float)>(&GorillaLocomotion::Player::Turn)> {
  static const MethodInfo* get() {
    static auto* degrees = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "Turn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{degrees});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::StoreVelocities
// Il2CppName: StoreVelocities
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)()>(&GorillaLocomotion::Player::StoreVelocities)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "StoreVelocities", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::AntiTeleportTechnology
// Il2CppName: AntiTeleportTechnology
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)()>(&GorillaLocomotion::Player::AntiTeleportTechnology)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "AntiTeleportTechnology", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::MaxSphereSizeForNoOverlap
// Il2CppName: MaxSphereSizeForNoOverlap
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(float, ::UnityEngine::Vector3, ByRef<float>)>(&GorillaLocomotion::Player::MaxSphereSizeForNoOverlap)> {
  static const MethodInfo* get() {
    static auto* testRadius = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* checkPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* overlapRadiusTest = &::il2cpp_utils::GetClassFromName("System", "Single")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "MaxSphereSizeForNoOverlap", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{testRadius, checkPosition, overlapRadiusTest});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::CrazyCheck2
// Il2CppName: CrazyCheck2
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(float, ::UnityEngine::Vector3)>(&GorillaLocomotion::Player::CrazyCheck2)> {
  static const MethodInfo* get() {
    static auto* sphereSize = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* startPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "CrazyCheck2", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{sphereSize, startPosition});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::NonAllocRaycast
// Il2CppName: NonAllocRaycast
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (GorillaLocomotion::Player::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&GorillaLocomotion::Player::NonAllocRaycast)> {
  static const MethodInfo* get() {
    static auto* startPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* endPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "NonAllocRaycast", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{startPosition, endPosition});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::ClearColliderBuffer
// Il2CppName: ClearColliderBuffer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)(ByRef<::ArrayW<::UnityEngine::Collider*>>)>(&GorillaLocomotion::Player::ClearColliderBuffer)> {
  static const MethodInfo* get() {
    static auto* colliders = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Collider"), 1)->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "ClearColliderBuffer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{colliders});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::ClearRaycasthitBuffer
// Il2CppName: ClearRaycasthitBuffer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Player::*)(ByRef<::ArrayW<::UnityEngine::RaycastHit>>)>(&GorillaLocomotion::Player::ClearRaycasthitBuffer)> {
  static const MethodInfo* get() {
    static auto* raycastHits = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "RaycastHit"), 1)->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "ClearRaycasthitBuffer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{raycastHits});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::$GetSlidePercentage$b__151_2
// Il2CppName: <GetSlidePercentage>b__151_2
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(::GorillaLocomotion::Player::MaterialData)>(&GorillaLocomotion::Player::$GetSlidePercentage$b__151_2)> {
  static const MethodInfo* get() {
    static auto* matData = &::il2cpp_utils::GetClassFromName("GorillaLocomotion", "Player/MaterialData")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "<GetSlidePercentage>b__151_2", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{matData});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::$GetSlidePercentage$b__151_3
// Il2CppName: <GetSlidePercentage>b__151_3
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(::GorillaLocomotion::Player::MaterialData)>(&GorillaLocomotion::Player::$GetSlidePercentage$b__151_3)> {
  static const MethodInfo* get() {
    static auto* matData = &::il2cpp_utils::GetClassFromName("GorillaLocomotion", "Player/MaterialData")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "<GetSlidePercentage>b__151_3", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{matData});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::$GetSlidePercentage$b__151_0
// Il2CppName: <GetSlidePercentage>b__151_0
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(::GorillaLocomotion::Player::MaterialData)>(&GorillaLocomotion::Player::$GetSlidePercentage$b__151_0)> {
  static const MethodInfo* get() {
    static auto* matData = &::il2cpp_utils::GetClassFromName("GorillaLocomotion", "Player/MaterialData")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "<GetSlidePercentage>b__151_0", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{matData});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Player::$GetSlidePercentage$b__151_1
// Il2CppName: <GetSlidePercentage>b__151_1
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Player::*)(::GorillaLocomotion::Player::MaterialData)>(&GorillaLocomotion::Player::$GetSlidePercentage$b__151_1)> {
  static const MethodInfo* get() {
    static auto* matData = &::il2cpp_utils::GetClassFromName("GorillaLocomotion", "Player/MaterialData")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Player*), "<GetSlidePercentage>b__151_1", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{matData});
  }
};
