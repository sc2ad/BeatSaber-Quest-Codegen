// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: DigitalOpus::MB::Core
namespace DigitalOpus::MB::Core {
  // Forward declaring type: MB2_LogLevel
  struct MB2_LogLevel;
  // Forward declaring type: ShaderTextureProperty
  class ShaderTextureProperty;
  // Forward declaring type: ProgressUpdateDelegate
  class ProgressUpdateDelegate;
  // Forward declaring type: CombineTexturesIntoAtlasesCoroutineResult
  class MB3_TextureCombiner_CombineTexturesIntoAtlasesCoroutineResult;
  // Forward declaring type: MB3_TextureCombiner
  class MB3_TextureCombiner;
  // Forward declaring type: MB2_EditorMethodsInterface
  class MB2_EditorMethodsInterface;
  // Forward declaring type: AtlasPackingResult
  class AtlasPackingResult;
  // Forward declaring type: MB_ITextureCombinerPacker
  class MB_ITextureCombinerPacker;
  // Forward declaring type: MB2_PackingAlgorithmEnum
  struct MB2_PackingAlgorithmEnum;
  // Forward declaring type: MB2_TexturePacker
  class MB2_TexturePacker;
  // Forward declaring type: MeshBakerMaterialTexture
  class MeshBakerMaterialTexture;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: Texture
  class Texture;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Texture2D
  class Texture2D;
  // Forward declaring type: Vector2
  struct Vector2;
  // Forward declaring type: Color32
  struct Color32;
  // Forward declaring type: Mesh
  class Mesh;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: MB_AtlasesAndRects
  class MB_AtlasesAndRects;
}
// Forward declaring namespace: System::Text
namespace System::Text {
  // Forward declaring type: StringBuilder
  class StringBuilder;
}
// Completed forward declares
// Type namespace: DigitalOpus.MB.Core
namespace DigitalOpus::MB::Core {
  // Forward declaring type: MB3_TextureCombinerPipeline
  class MB3_TextureCombinerPipeline;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline);
DEFINE_IL2CPP_ARG_TYPE(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*, "DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline");
// Type namespace: DigitalOpus.MB.Core
namespace DigitalOpus::MB::Core {
  // Size: 0x10
  #pragma pack(push, 1)
  // Autogenerated type: DigitalOpus.MB.Core.MB3_TextureCombinerPipeline
  // [TokenAttribute] Offset: FFFFFFFF
  class MB3_TextureCombinerPipeline : public ::Il2CppObject {
    public:
    // Nested type: ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateAtlasForProperty
    struct CreateAtlasForProperty;
    // Nested type: ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData
    class TexturePipelineData;
    // Nested type: ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::$$c__DisplayClass7_0
    class $$c__DisplayClass7_0;
    // Nested type: ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::$$c__DisplayClass7_1
    class $$c__DisplayClass7_1;
    // Nested type: ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::$$c__DisplayClass9_0
    class $$c__DisplayClass9_0;
    // Nested type: ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::$$c__DisplayClass9_1
    class $$c__DisplayClass9_1;
    // Nested type: ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::$__Step1_CollectDistinctMatTexturesAndUsedObjects$d__9
    class $__Step1_CollectDistinctMatTexturesAndUsedObjects$d__9;
    // Nested type: ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::$CalculateIdealSizesForTexturesInAtlasAndPadding$d__11
    class $CalculateIdealSizesForTexturesInAtlasAndPadding$d__11;
    // Nested type: ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::$__Step3_BuildAndSaveAtlasesAndStoreResults$d__14
    class $__Step3_BuildAndSaveAtlasesAndStoreResults$d__14;
    // Size: 0x4
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.CreateAtlasForProperty
    // [TokenAttribute] Offset: FFFFFFFF
    struct CreateAtlasForProperty/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Boolean allTexturesAreNull
      // Size: 0x1
      // Offset: 0x0
      bool allTexturesAreNull;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // public System.Boolean allTexturesAreSame
      // Size: 0x1
      // Offset: 0x1
      bool allTexturesAreSame;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // public System.Boolean allNonTexturePropsAreSame
      // Size: 0x1
      // Offset: 0x2
      bool allNonTexturePropsAreSame;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // public System.Boolean allSrcMatsOmittedTextureProperty
      // Size: 0x1
      // Offset: 0x3
      bool allSrcMatsOmittedTextureProperty;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: CreateAtlasForProperty
      constexpr CreateAtlasForProperty(bool allTexturesAreNull_ = {}, bool allTexturesAreSame_ = {}, bool allNonTexturePropsAreSame_ = {}, bool allSrcMatsOmittedTextureProperty_ = {}) noexcept : allTexturesAreNull{allTexturesAreNull_}, allTexturesAreSame{allTexturesAreSame_}, allNonTexturePropsAreSame{allNonTexturePropsAreSame_}, allSrcMatsOmittedTextureProperty{allSrcMatsOmittedTextureProperty_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.Boolean allTexturesAreNull
      [[deprecated("Use field access instead!")]] bool& dyn_allTexturesAreNull();
      // Get instance field reference: public System.Boolean allTexturesAreSame
      [[deprecated("Use field access instead!")]] bool& dyn_allTexturesAreSame();
      // Get instance field reference: public System.Boolean allNonTexturePropsAreSame
      [[deprecated("Use field access instead!")]] bool& dyn_allNonTexturePropsAreSame();
      // Get instance field reference: public System.Boolean allSrcMatsOmittedTextureProperty
      [[deprecated("Use field access instead!")]] bool& dyn_allSrcMatsOmittedTextureProperty();
      // public override System.String ToString()
      // Offset: 0xA64F74
      // Implemented from: System.ValueType
      // Base method: System.String ValueType::ToString()
      ::StringW ToString();
    }; // DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.CreateAtlasForProperty
    #pragma pack(pop)
    static check_size<sizeof(MB3_TextureCombinerPipeline::CreateAtlasForProperty), 3 + sizeof(bool)> __DigitalOpus_MB_Core_MB3_TextureCombinerPipeline_CreateAtlasForPropertySizeCheck;
    static_assert(sizeof(MB3_TextureCombinerPipeline::CreateAtlasForProperty) == 0x4);
    // Get static field: static public System.Boolean USE_EXPERIMENTAL_HOIZONTALVERTICAL
    static bool _get_USE_EXPERIMENTAL_HOIZONTALVERTICAL();
    // Set static field: static public System.Boolean USE_EXPERIMENTAL_HOIZONTALVERTICAL
    static void _set_USE_EXPERIMENTAL_HOIZONTALVERTICAL(bool value);
    // Get static field: static public DigitalOpus.MB.Core.ShaderTextureProperty[] shaderTexPropertyNames
    static ::ArrayW<::DigitalOpus::MB::Core::ShaderTextureProperty*> _get_shaderTexPropertyNames();
    // Set static field: static public DigitalOpus.MB.Core.ShaderTextureProperty[] shaderTexPropertyNames
    static void _set_shaderTexPropertyNames(::ArrayW<::DigitalOpus::MB::Core::ShaderTextureProperty*> value);
    // public System.Void .ctor()
    // Offset: 0x15D0F30
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static MB3_TextureCombinerPipeline* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<MB3_TextureCombinerPipeline*, creationType>()));
    }
    // static private System.Void .cctor()
    // Offset: 0x15D0F38
    static void _cctor();
    // static System.Boolean _ShouldWeCreateAtlasForThisProperty(System.Int32 propertyIndex, System.Boolean considerNonTextureProperties, DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.CreateAtlasForProperty[] allTexturesAreNullAndSameColor)
    // Offset: 0x15C79A4
    static bool _ShouldWeCreateAtlasForThisProperty(int propertyIndex, bool considerNonTextureProperties, ::ArrayW<::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateAtlasForProperty> allTexturesAreNullAndSameColor);
    // static System.Boolean _DoAnySrcMatsHaveProperty(System.Int32 propertyIndex, DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.CreateAtlasForProperty[] allTexturesAreNullAndSameColor)
    // Offset: 0x15CC34C
    static bool _DoAnySrcMatsHaveProperty(int propertyIndex, ::ArrayW<::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateAtlasForProperty> allTexturesAreNullAndSameColor);
    // static System.Boolean _CollectPropertyNames(DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data, DigitalOpus.MB.Core.MB2_LogLevel LOG_LEVEL)
    // Offset: 0x15CE540
    static bool _CollectPropertyNames(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data, ::DigitalOpus::MB::Core::MB2_LogLevel LOG_LEVEL);
    // static System.Boolean _CollectPropertyNames(System.Collections.Generic.List`1<DigitalOpus.MB.Core.ShaderTextureProperty> texPropertyNames, System.Collections.Generic.List`1<DigitalOpus.MB.Core.ShaderTextureProperty> _customShaderPropNames, System.Collections.Generic.List`1<System.String> texPropsToIgnore, UnityEngine.Material resultMaterial, DigitalOpus.MB.Core.MB2_LogLevel LOG_LEVEL)
    // Offset: 0x15CE5DC
    static bool _CollectPropertyNames(::System::Collections::Generic::List_1<::DigitalOpus::MB::Core::ShaderTextureProperty*>* texPropertyNames, ::System::Collections::Generic::List_1<::DigitalOpus::MB::Core::ShaderTextureProperty*>* _customShaderPropNames, ::System::Collections::Generic::List_1<::StringW>* texPropsToIgnore, ::UnityEngine::Material* resultMaterial, ::DigitalOpus::MB::Core::MB2_LogLevel LOG_LEVEL);
    // static public UnityEngine.Texture GetTextureConsideringStandardShaderKeywords(System.String shaderName, UnityEngine.Material mat, System.String propertyName)
    // Offset: 0x15CE9F8
    static ::UnityEngine::Texture* GetTextureConsideringStandardShaderKeywords(::StringW shaderName, ::UnityEngine::Material* mat, ::StringW propertyName);
    // System.Collections.IEnumerator __Step1_CollectDistinctMatTexturesAndUsedObjects(DigitalOpus.MB.Core.ProgressUpdateDelegate progressInfo, DigitalOpus.MB.Core.MB3_TextureCombiner/DigitalOpus.MB.Core.CombineTexturesIntoAtlasesCoroutineResult result, DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data, DigitalOpus.MB.Core.MB3_TextureCombiner combiner, DigitalOpus.MB.Core.MB2_EditorMethodsInterface textureEditorMethods, System.Collections.Generic.List`1<UnityEngine.GameObject> usedObjsToMesh, DigitalOpus.MB.Core.MB2_LogLevel LOG_LEVEL)
    // Offset: 0x15CEB08
    ::System::Collections::IEnumerator* __Step1_CollectDistinctMatTexturesAndUsedObjects(::DigitalOpus::MB::Core::ProgressUpdateDelegate* progressInfo, ::DigitalOpus::MB::Core::MB3_TextureCombiner_CombineTexturesIntoAtlasesCoroutineResult* result, ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data, ::DigitalOpus::MB::Core::MB3_TextureCombiner* combiner, ::DigitalOpus::MB::Core::MB2_EditorMethodsInterface* textureEditorMethods, ::System::Collections::Generic::List_1<::UnityEngine::GameObject*>* usedObjsToMesh, ::DigitalOpus::MB::Core::MB2_LogLevel LOG_LEVEL);
    // static private DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.CreateAtlasForProperty[] CalculateAllTexturesAreNullAndSameColor(DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data, DigitalOpus.MB.Core.MB2_LogLevel LOG_LEVEL)
    // Offset: 0x15CEBDC
    static ::ArrayW<::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateAtlasForProperty> CalculateAllTexturesAreNullAndSameColor(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data, ::DigitalOpus::MB::Core::MB2_LogLevel LOG_LEVEL);
    // System.Collections.IEnumerator CalculateIdealSizesForTexturesInAtlasAndPadding(DigitalOpus.MB.Core.ProgressUpdateDelegate progressInfo, DigitalOpus.MB.Core.MB3_TextureCombiner/DigitalOpus.MB.Core.CombineTexturesIntoAtlasesCoroutineResult result, DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data, DigitalOpus.MB.Core.MB3_TextureCombiner combiner, DigitalOpus.MB.Core.MB2_EditorMethodsInterface textureEditorMethods, DigitalOpus.MB.Core.MB2_LogLevel LOG_LEVEL)
    // Offset: 0x15CF14C
    ::System::Collections::IEnumerator* CalculateIdealSizesForTexturesInAtlasAndPadding(::DigitalOpus::MB::Core::ProgressUpdateDelegate* progressInfo, ::DigitalOpus::MB::Core::MB3_TextureCombiner_CombineTexturesIntoAtlasesCoroutineResult* result, ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data, ::DigitalOpus::MB::Core::MB3_TextureCombiner* combiner, ::DigitalOpus::MB::Core::MB2_EditorMethodsInterface* textureEditorMethods, ::DigitalOpus::MB::Core::MB2_LogLevel LOG_LEVEL);
    // DigitalOpus.MB.Core.AtlasPackingResult[] RunTexturePackerOnly(DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data, System.Boolean doSplitIntoMultiAtlasIfTooBig, MB_AtlasesAndRects resultAtlasesAndRects, DigitalOpus.MB.Core.MB_ITextureCombinerPacker texturePacker, DigitalOpus.MB.Core.MB2_LogLevel LOG_LEVEL)
    // Offset: 0x15CF1F8
    ::ArrayW<::DigitalOpus::MB::Core::AtlasPackingResult*> RunTexturePackerOnly(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data, bool doSplitIntoMultiAtlasIfTooBig, ::GlobalNamespace::MB_AtlasesAndRects* resultAtlasesAndRects, ::DigitalOpus::MB::Core::MB_ITextureCombinerPacker* texturePacker, ::DigitalOpus::MB::Core::MB2_LogLevel LOG_LEVEL);
    // DigitalOpus.MB.Core.MB_ITextureCombinerPacker CreatePacker(System.Boolean onlyOneTextureInAtlasReuseTextures, DigitalOpus.MB.Core.MB2_PackingAlgorithmEnum packingAlgorithm)
    // Offset: 0x15CF9F0
    ::DigitalOpus::MB::Core::MB_ITextureCombinerPacker* CreatePacker(bool onlyOneTextureInAtlasReuseTextures, ::DigitalOpus::MB::Core::MB2_PackingAlgorithmEnum packingAlgorithm);
    // System.Collections.IEnumerator __Step3_BuildAndSaveAtlasesAndStoreResults(DigitalOpus.MB.Core.MB3_TextureCombiner/DigitalOpus.MB.Core.CombineTexturesIntoAtlasesCoroutineResult result, DigitalOpus.MB.Core.ProgressUpdateDelegate progressInfo, DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data, DigitalOpus.MB.Core.MB3_TextureCombiner combiner, DigitalOpus.MB.Core.MB_ITextureCombinerPacker packer, DigitalOpus.MB.Core.AtlasPackingResult atlasPackingResult, DigitalOpus.MB.Core.MB2_EditorMethodsInterface textureEditorMethods, MB_AtlasesAndRects resultAtlasesAndRects, System.Text.StringBuilder report, DigitalOpus.MB.Core.MB2_LogLevel LOG_LEVEL)
    // Offset: 0x15CFBEC
    ::System::Collections::IEnumerator* __Step3_BuildAndSaveAtlasesAndStoreResults(::DigitalOpus::MB::Core::MB3_TextureCombiner_CombineTexturesIntoAtlasesCoroutineResult* result, ::DigitalOpus::MB::Core::ProgressUpdateDelegate* progressInfo, ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data, ::DigitalOpus::MB::Core::MB3_TextureCombiner* combiner, ::DigitalOpus::MB::Core::MB_ITextureCombinerPacker* packer, ::DigitalOpus::MB::Core::AtlasPackingResult* atlasPackingResult, ::DigitalOpus::MB::Core::MB2_EditorMethodsInterface* textureEditorMethods, ::GlobalNamespace::MB_AtlasesAndRects* resultAtlasesAndRects, ::System::Text::StringBuilder* report, ::DigitalOpus::MB::Core::MB2_LogLevel LOG_LEVEL);
    // private System.Void FillAtlasPackingResultAuxillaryData(DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data, DigitalOpus.MB.Core.AtlasPackingResult[] atlasPackingResults)
    // Offset: 0x15CF33C
    void FillAtlasPackingResultAuxillaryData(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data, ::ArrayW<::DigitalOpus::MB::Core::AtlasPackingResult*> atlasPackingResults);
    // private System.Void FillResultAtlasesAndRects(DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data, DigitalOpus.MB.Core.AtlasPackingResult atlasPackingResult, MB_AtlasesAndRects resultAtlasesAndRects, UnityEngine.Texture2D[] atlases)
    // Offset: 0x15CF6CC
    void FillResultAtlasesAndRects(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data, ::DigitalOpus::MB::Core::AtlasPackingResult* atlasPackingResult, ::GlobalNamespace::MB_AtlasesAndRects* resultAtlasesAndRects, ::ArrayW<::UnityEngine::Texture2D*> atlases);
    // System.Text.StringBuilder GenerateReport(DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data)
    // Offset: 0x15CFE60
    ::System::Text::StringBuilder* GenerateReport(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data);
    // static DigitalOpus.MB.Core.MB2_TexturePacker CreateTexturePacker(DigitalOpus.MB.Core.MB2_PackingAlgorithmEnum _packingAlgorithm)
    // Offset: 0x15CAA74
    static ::DigitalOpus::MB::Core::MB2_TexturePacker* CreateTexturePacker(::DigitalOpus::MB::Core::MB2_PackingAlgorithmEnum _packingAlgorithm);
    // static UnityEngine.Vector2 GetAdjustedForScaleAndOffset2Dimensions(DigitalOpus.MB.Core.MeshBakerMaterialTexture source, UnityEngine.Vector2 obUVoffset, UnityEngine.Vector2 obUVscale, DigitalOpus.MB.Core.MB3_TextureCombinerPipeline/DigitalOpus.MB.Core.TexturePipelineData data, DigitalOpus.MB.Core.MB2_LogLevel LOG_LEVEL)
    // Offset: 0x15CD0DC
    static ::UnityEngine::Vector2 GetAdjustedForScaleAndOffset2Dimensions(::DigitalOpus::MB::Core::MeshBakerMaterialTexture* source, ::UnityEngine::Vector2 obUVoffset, ::UnityEngine::Vector2 obUVscale, ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData* data, ::DigitalOpus::MB::Core::MB2_LogLevel LOG_LEVEL);
    // static UnityEngine.Color32 ConvertNormalFormatFromUnity_ToStandard(UnityEngine.Color32 c)
    // Offset: 0x15D09CC
    static ::UnityEngine::Color32 ConvertNormalFormatFromUnity_ToStandard(::UnityEngine::Color32 c);
    // static System.Void GetMaterialScaleAndOffset(UnityEngine.Material mat, System.String propertyName, out UnityEngine.Vector2 offset, out UnityEngine.Vector2 scale)
    // Offset: 0x15D0B08
    static void GetMaterialScaleAndOffset(::UnityEngine::Material* mat, ::StringW propertyName, ByRef<::UnityEngine::Vector2> offset, ByRef<::UnityEngine::Vector2> scale);
    // static System.Single GetSubmeshArea(UnityEngine.Mesh m, System.Int32 submeshIdx)
    // Offset: 0x15D0CD4
    static float GetSubmeshArea(::UnityEngine::Mesh* m, int submeshIdx);
    // static System.Boolean IsPowerOfTwo(System.Int32 x)
    // Offset: 0x15D0F20
    static bool IsPowerOfTwo(int x);
  }; // DigitalOpus.MB.Core.MB3_TextureCombinerPipeline
  #pragma pack(pop)
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateAtlasForProperty, "DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/CreateAtlasForProperty");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_ShouldWeCreateAtlasForThisProperty
// Il2CppName: _ShouldWeCreateAtlasForThisProperty
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(int, bool, ::ArrayW<::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateAtlasForProperty>)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_ShouldWeCreateAtlasForThisProperty)> {
  static const MethodInfo* get() {
    static auto* propertyIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* considerNonTextureProperties = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* allTexturesAreNullAndSameColor = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/CreateAtlasForProperty"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "_ShouldWeCreateAtlasForThisProperty", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{propertyIndex, considerNonTextureProperties, allTexturesAreNullAndSameColor});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_DoAnySrcMatsHaveProperty
// Il2CppName: _DoAnySrcMatsHaveProperty
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(int, ::ArrayW<::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateAtlasForProperty>)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_DoAnySrcMatsHaveProperty)> {
  static const MethodInfo* get() {
    static auto* propertyIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* allTexturesAreNullAndSameColor = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/CreateAtlasForProperty"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "_DoAnySrcMatsHaveProperty", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{propertyIndex, allTexturesAreNullAndSameColor});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_CollectPropertyNames
// Il2CppName: _CollectPropertyNames
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*, ::DigitalOpus::MB::Core::MB2_LogLevel)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_CollectPropertyNames)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    static auto* LOG_LEVEL = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_LogLevel")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "_CollectPropertyNames", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data, LOG_LEVEL});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_CollectPropertyNames
// Il2CppName: _CollectPropertyNames
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::System::Collections::Generic::List_1<::DigitalOpus::MB::Core::ShaderTextureProperty*>*, ::System::Collections::Generic::List_1<::DigitalOpus::MB::Core::ShaderTextureProperty*>*, ::System::Collections::Generic::List_1<::StringW>*, ::UnityEngine::Material*, ::DigitalOpus::MB::Core::MB2_LogLevel)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::_CollectPropertyNames)> {
  static const MethodInfo* get() {
    static auto* texPropertyNames = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "ShaderTextureProperty")})->byval_arg;
    static auto* _customShaderPropNames = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "ShaderTextureProperty")})->byval_arg;
    static auto* texPropsToIgnore = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "String")})->byval_arg;
    static auto* resultMaterial = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* LOG_LEVEL = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_LogLevel")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "_CollectPropertyNames", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{texPropertyNames, _customShaderPropNames, texPropsToIgnore, resultMaterial, LOG_LEVEL});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GetTextureConsideringStandardShaderKeywords
// Il2CppName: GetTextureConsideringStandardShaderKeywords
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Texture* (*)(::StringW, ::UnityEngine::Material*, ::StringW)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GetTextureConsideringStandardShaderKeywords)> {
  static const MethodInfo* get() {
    static auto* shaderName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* mat = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* propertyName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "GetTextureConsideringStandardShaderKeywords", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{shaderName, mat, propertyName});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::__Step1_CollectDistinctMatTexturesAndUsedObjects
// Il2CppName: __Step1_CollectDistinctMatTexturesAndUsedObjects
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::*)(::DigitalOpus::MB::Core::ProgressUpdateDelegate*, ::DigitalOpus::MB::Core::MB3_TextureCombiner_CombineTexturesIntoAtlasesCoroutineResult*, ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*, ::DigitalOpus::MB::Core::MB3_TextureCombiner*, ::DigitalOpus::MB::Core::MB2_EditorMethodsInterface*, ::System::Collections::Generic::List_1<::UnityEngine::GameObject*>*, ::DigitalOpus::MB::Core::MB2_LogLevel)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::__Step1_CollectDistinctMatTexturesAndUsedObjects)> {
  static const MethodInfo* get() {
    static auto* progressInfo = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "ProgressUpdateDelegate")->byval_arg;
    static auto* result = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombiner/CombineTexturesIntoAtlasesCoroutineResult")->byval_arg;
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    static auto* combiner = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombiner")->byval_arg;
    static auto* textureEditorMethods = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_EditorMethodsInterface")->byval_arg;
    static auto* usedObjsToMesh = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")})->byval_arg;
    static auto* LOG_LEVEL = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_LogLevel")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "__Step1_CollectDistinctMatTexturesAndUsedObjects", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{progressInfo, result, data, combiner, textureEditorMethods, usedObjsToMesh, LOG_LEVEL});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CalculateAllTexturesAreNullAndSameColor
// Il2CppName: CalculateAllTexturesAreNullAndSameColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateAtlasForProperty> (*)(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*, ::DigitalOpus::MB::Core::MB2_LogLevel)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CalculateAllTexturesAreNullAndSameColor)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    static auto* LOG_LEVEL = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_LogLevel")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "CalculateAllTexturesAreNullAndSameColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data, LOG_LEVEL});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CalculateIdealSizesForTexturesInAtlasAndPadding
// Il2CppName: CalculateIdealSizesForTexturesInAtlasAndPadding
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::*)(::DigitalOpus::MB::Core::ProgressUpdateDelegate*, ::DigitalOpus::MB::Core::MB3_TextureCombiner_CombineTexturesIntoAtlasesCoroutineResult*, ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*, ::DigitalOpus::MB::Core::MB3_TextureCombiner*, ::DigitalOpus::MB::Core::MB2_EditorMethodsInterface*, ::DigitalOpus::MB::Core::MB2_LogLevel)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CalculateIdealSizesForTexturesInAtlasAndPadding)> {
  static const MethodInfo* get() {
    static auto* progressInfo = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "ProgressUpdateDelegate")->byval_arg;
    static auto* result = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombiner/CombineTexturesIntoAtlasesCoroutineResult")->byval_arg;
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    static auto* combiner = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombiner")->byval_arg;
    static auto* textureEditorMethods = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_EditorMethodsInterface")->byval_arg;
    static auto* LOG_LEVEL = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_LogLevel")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "CalculateIdealSizesForTexturesInAtlasAndPadding", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{progressInfo, result, data, combiner, textureEditorMethods, LOG_LEVEL});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::RunTexturePackerOnly
// Il2CppName: RunTexturePackerOnly
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::DigitalOpus::MB::Core::AtlasPackingResult*> (DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::*)(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*, bool, ::GlobalNamespace::MB_AtlasesAndRects*, ::DigitalOpus::MB::Core::MB_ITextureCombinerPacker*, ::DigitalOpus::MB::Core::MB2_LogLevel)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::RunTexturePackerOnly)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    static auto* doSplitIntoMultiAtlasIfTooBig = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* resultAtlasesAndRects = &::il2cpp_utils::GetClassFromName("", "MB_AtlasesAndRects")->byval_arg;
    static auto* texturePacker = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB_ITextureCombinerPacker")->byval_arg;
    static auto* LOG_LEVEL = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_LogLevel")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "RunTexturePackerOnly", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data, doSplitIntoMultiAtlasIfTooBig, resultAtlasesAndRects, texturePacker, LOG_LEVEL});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreatePacker
// Il2CppName: CreatePacker
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::DigitalOpus::MB::Core::MB_ITextureCombinerPacker* (DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::*)(bool, ::DigitalOpus::MB::Core::MB2_PackingAlgorithmEnum)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreatePacker)> {
  static const MethodInfo* get() {
    static auto* onlyOneTextureInAtlasReuseTextures = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* packingAlgorithm = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_PackingAlgorithmEnum")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "CreatePacker", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onlyOneTextureInAtlasReuseTextures, packingAlgorithm});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::__Step3_BuildAndSaveAtlasesAndStoreResults
// Il2CppName: __Step3_BuildAndSaveAtlasesAndStoreResults
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::*)(::DigitalOpus::MB::Core::MB3_TextureCombiner_CombineTexturesIntoAtlasesCoroutineResult*, ::DigitalOpus::MB::Core::ProgressUpdateDelegate*, ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*, ::DigitalOpus::MB::Core::MB3_TextureCombiner*, ::DigitalOpus::MB::Core::MB_ITextureCombinerPacker*, ::DigitalOpus::MB::Core::AtlasPackingResult*, ::DigitalOpus::MB::Core::MB2_EditorMethodsInterface*, ::GlobalNamespace::MB_AtlasesAndRects*, ::System::Text::StringBuilder*, ::DigitalOpus::MB::Core::MB2_LogLevel)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::__Step3_BuildAndSaveAtlasesAndStoreResults)> {
  static const MethodInfo* get() {
    static auto* result = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombiner/CombineTexturesIntoAtlasesCoroutineResult")->byval_arg;
    static auto* progressInfo = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "ProgressUpdateDelegate")->byval_arg;
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    static auto* combiner = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombiner")->byval_arg;
    static auto* packer = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB_ITextureCombinerPacker")->byval_arg;
    static auto* atlasPackingResult = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "AtlasPackingResult")->byval_arg;
    static auto* textureEditorMethods = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_EditorMethodsInterface")->byval_arg;
    static auto* resultAtlasesAndRects = &::il2cpp_utils::GetClassFromName("", "MB_AtlasesAndRects")->byval_arg;
    static auto* report = &::il2cpp_utils::GetClassFromName("System.Text", "StringBuilder")->byval_arg;
    static auto* LOG_LEVEL = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_LogLevel")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "__Step3_BuildAndSaveAtlasesAndStoreResults", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{result, progressInfo, data, combiner, packer, atlasPackingResult, textureEditorMethods, resultAtlasesAndRects, report, LOG_LEVEL});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::FillAtlasPackingResultAuxillaryData
// Il2CppName: FillAtlasPackingResultAuxillaryData
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::*)(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*, ::ArrayW<::DigitalOpus::MB::Core::AtlasPackingResult*>)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::FillAtlasPackingResultAuxillaryData)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    static auto* atlasPackingResults = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "AtlasPackingResult"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "FillAtlasPackingResultAuxillaryData", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data, atlasPackingResults});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::FillResultAtlasesAndRects
// Il2CppName: FillResultAtlasesAndRects
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::*)(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*, ::DigitalOpus::MB::Core::AtlasPackingResult*, ::GlobalNamespace::MB_AtlasesAndRects*, ::ArrayW<::UnityEngine::Texture2D*>)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::FillResultAtlasesAndRects)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    static auto* atlasPackingResult = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "AtlasPackingResult")->byval_arg;
    static auto* resultAtlasesAndRects = &::il2cpp_utils::GetClassFromName("", "MB_AtlasesAndRects")->byval_arg;
    static auto* atlases = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Texture2D"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "FillResultAtlasesAndRects", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data, atlasPackingResult, resultAtlasesAndRects, atlases});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GenerateReport
// Il2CppName: GenerateReport
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Text::StringBuilder* (DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::*)(::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GenerateReport)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "GenerateReport", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateTexturePacker
// Il2CppName: CreateTexturePacker
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::DigitalOpus::MB::Core::MB2_TexturePacker* (*)(::DigitalOpus::MB::Core::MB2_PackingAlgorithmEnum)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::CreateTexturePacker)> {
  static const MethodInfo* get() {
    static auto* _packingAlgorithm = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_PackingAlgorithmEnum")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "CreateTexturePacker", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{_packingAlgorithm});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GetAdjustedForScaleAndOffset2Dimensions
// Il2CppName: GetAdjustedForScaleAndOffset2Dimensions
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector2 (*)(::DigitalOpus::MB::Core::MeshBakerMaterialTexture*, ::UnityEngine::Vector2, ::UnityEngine::Vector2, ::DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::TexturePipelineData*, ::DigitalOpus::MB::Core::MB2_LogLevel)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GetAdjustedForScaleAndOffset2Dimensions)> {
  static const MethodInfo* get() {
    static auto* source = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MeshBakerMaterialTexture")->byval_arg;
    static auto* obUVoffset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector2")->byval_arg;
    static auto* obUVscale = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector2")->byval_arg;
    static auto* data = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB3_TextureCombinerPipeline/TexturePipelineData")->byval_arg;
    static auto* LOG_LEVEL = &::il2cpp_utils::GetClassFromName("DigitalOpus.MB.Core", "MB2_LogLevel")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "GetAdjustedForScaleAndOffset2Dimensions", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{source, obUVoffset, obUVscale, data, LOG_LEVEL});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::ConvertNormalFormatFromUnity_ToStandard
// Il2CppName: ConvertNormalFormatFromUnity_ToStandard
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Color32 (*)(::UnityEngine::Color32)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::ConvertNormalFormatFromUnity_ToStandard)> {
  static const MethodInfo* get() {
    static auto* c = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "ConvertNormalFormatFromUnity_ToStandard", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{c});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GetMaterialScaleAndOffset
// Il2CppName: GetMaterialScaleAndOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::UnityEngine::Material*, ::StringW, ByRef<::UnityEngine::Vector2>, ByRef<::UnityEngine::Vector2>)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GetMaterialScaleAndOffset)> {
  static const MethodInfo* get() {
    static auto* mat = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* propertyName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* offset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector2")->this_arg;
    static auto* scale = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector2")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "GetMaterialScaleAndOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mat, propertyName, offset, scale});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GetSubmeshArea
// Il2CppName: GetSubmeshArea
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (*)(::UnityEngine::Mesh*, int)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::GetSubmeshArea)> {
  static const MethodInfo* get() {
    static auto* m = &::il2cpp_utils::GetClassFromName("UnityEngine", "Mesh")->byval_arg;
    static auto* submeshIdx = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "GetSubmeshArea", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{m, submeshIdx});
  }
};
// Writing MetadataGetter for method: DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::IsPowerOfTwo
// Il2CppName: IsPowerOfTwo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(int)>(&DigitalOpus::MB::Core::MB3_TextureCombinerPipeline::IsPowerOfTwo)> {
  static const MethodInfo* get() {
    static auto* x = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(DigitalOpus::MB::Core::MB3_TextureCombinerPipeline*), "IsPowerOfTwo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{x});
  }
};
