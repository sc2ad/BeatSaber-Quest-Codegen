// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include <initializer_list>
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
// Including type: System.Collections.Generic.IList`1
#include "System/Collections/Generic/IList_1.hpp"
// Including type: System.Collections.Generic.IReadOnlyList`1
#include "System/Collections/Generic/IReadOnlyList_1.hpp"
// Including type: System.IDisposable
#include "System/IDisposable.hpp"
// Including type: Unity.Collections.NativeArray`1
#include "Unity/Collections/NativeArray_1.hpp"
// Including type: System.UInt64
#include "System/UInt64.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine::InputSystem
namespace UnityEngine::InputSystem {
  // Skipping declaration: Enumerator because it is already included!
  // Forward declaring type: InputControl
  class InputControl;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Skipping declaration: IEnumerable`1 because it is already included!
  // Forward declaring type: IComparer`1<T>
  template<typename T>
  class IComparer_1;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Skipping declaration: IEnumerator because it is already included!
}
// Completed forward declares
// Type namespace: UnityEngine.InputSystem
namespace UnityEngine::InputSystem {
  // Forward declaring type: InputControlList`1<TControl>
  template<typename TControl>
  struct InputControlList_1;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE_GENERIC_STRUCT(::UnityEngine::InputSystem::InputControlList_1, "UnityEngine.InputSystem", "InputControlList`1");
// Type namespace: UnityEngine.InputSystem
namespace UnityEngine::InputSystem {
  // WARNING Size may be invalid!
  // WARNING Layout: Sequential may not be correctly taken into account!
  // Autogenerated type: UnityEngine.InputSystem.InputControlList`1
  // [TokenAttribute] Offset: FFFFFFFF
  // [DefaultMemberAttribute] Offset: 957664
  // [DebuggerDisplayAttribute] Offset: 957664
  template<typename TControl>
  struct InputControlList_1/*, public ::System::ValueType, public ::System::Collections::Generic::IList_1<TControl>, public ::System::Collections::Generic::IReadOnlyList_1<TControl>, public ::System::IDisposable*/ {
    public:
    // Nested type: ::UnityEngine::InputSystem::InputControlList_1::Enumerator<TControl>
    struct Enumerator;
    // WARNING Size may be invalid!
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.InputSystem.InputControlList`1/UnityEngine.InputSystem.Enumerator
    // [TokenAttribute] Offset: FFFFFFFF
    struct Enumerator : public ::il2cpp_utils::il2cpp_type_check::NestedType/*, public ::System::ValueType, public ::System::Collections::Generic::IEnumerator_1<TControl>*/ {
      public:
      using declaring_type = InputControlList_1<TControl>;
      static constexpr std::string_view NESTED_NAME = "Enumerator";
      static constexpr bool IS_VALUE_TYPE = true;
      public:
      // private readonly System.UInt64* m_Indices
      // Size: 0x8
      // Offset: 0x0
      uint64_t* m_Indices;
      // Field size check
      static_assert(sizeof(uint64_t*) == 0x8);
      // private readonly System.Int32 m_Count
      // Size: 0x4
      // Offset: 0x0
      int m_Count;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // private System.Int32 m_Current
      // Size: 0x4
      // Offset: 0x0
      int m_Current;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: Enumerator
      constexpr Enumerator(uint64_t* m_Indices_ = {}, int m_Count_ = {}, int m_Current_ = {}) noexcept : m_Indices{m_Indices_}, m_Count{m_Count_}, m_Current{m_Current_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating interface conversion operator: operator ::System::Collections::Generic::IEnumerator_1<TControl>
      operator ::System::Collections::Generic::IEnumerator_1<TControl>() noexcept {
        return *reinterpret_cast<::System::Collections::Generic::IEnumerator_1<TControl>*>(this);
      }
      // Autogenerated instance field getter
      // Get instance field: private readonly System.UInt64* m_Indices
      [[deprecated("Use field access instead!")]] uint64_t*& dyn_m_Indices() {
        static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Enumerator::dyn_m_Indices");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Indices"))->offset;
        return *reinterpret_cast<uint64_t**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: private readonly System.Int32 m_Count
      [[deprecated("Use field access instead!")]] int& dyn_m_Count() {
        static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Enumerator::dyn_m_Count");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Count"))->offset;
        return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: private System.Int32 m_Current
      [[deprecated("Use field access instead!")]] int& dyn_m_Current() {
        static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Enumerator::dyn_m_Current");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Current"))->offset;
        return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // public TControl get_Current()
      // Offset: 0xFFFFFFFFFFFFFFFF
      TControl get_Current() {
        static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Enumerator::get_Current");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::UnityEngine::InputSystem::InputControlList_1<TControl>::Enumerator), -1));
        return ::il2cpp_utils::RunMethodRethrow<TControl, false>(this, ___internal__method);
      }
      // private System.Object System.Collections.IEnumerator.get_Current()
      // Offset: 0xFFFFFFFFFFFFFFFF
      ::Il2CppObject* System_Collections_IEnumerator_get_Current() {
        static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Enumerator::System.Collections.IEnumerator.get_Current");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::UnityEngine::InputSystem::InputControlList_1<TControl>::Enumerator), -1));
        return ::il2cpp_utils::RunMethodRethrow<::Il2CppObject*, false>(this, ___internal__method);
      }
      // public System.Void .ctor(UnityEngine.InputSystem.InputControlList`1<TControl> list)
      // Offset: 0xFFFFFFFFFFFFFFFF
      Enumerator(::UnityEngine::InputSystem::InputControlList_1<TControl> list) {
        static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Enumerator::.ctor");
        static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, ".ctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(list)})));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, list);
      }
      // public System.Boolean MoveNext()
      // Offset: 0xFFFFFFFFFFFFFFFF
      bool MoveNext() {
        static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Enumerator::MoveNext");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::UnityEngine::InputSystem::InputControlList_1<TControl>::Enumerator), -1));
        return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method);
      }
      // public System.Void Reset()
      // Offset: 0xFFFFFFFFFFFFFFFF
      void Reset() {
        static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Enumerator::Reset");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::UnityEngine::InputSystem::InputControlList_1<TControl>::Enumerator), -1));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
      }
      // public System.Void Dispose()
      // Offset: 0xFFFFFFFFFFFFFFFF
      void Dispose() {
        static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Enumerator::Dispose");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::UnityEngine::InputSystem::InputControlList_1<TControl>::Enumerator), -1));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
      }
    }; // UnityEngine.InputSystem.InputControlList`1/UnityEngine.InputSystem.Enumerator
    // Could not write size check! Type: UnityEngine.InputSystem.InputControlList`1/UnityEngine.InputSystem.Enumerator is generic, or has no fields that are valid for size checks!
    public:
    // private System.Int32 m_Count
    // Size: 0x4
    // Offset: 0x0
    int m_Count;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private Unity.Collections.NativeArray`1<System.UInt64> m_Indices
    // Size: 0xFFFFFFFF
    // Offset: 0x0
    ::Unity::Collections::NativeArray_1<uint64_t> m_Indices;
    // private readonly Unity.Collections.Allocator m_Allocator
    // Size: 0x4
    // Offset: 0x0
    ::Unity::Collections::Allocator m_Allocator;
    // Field size check
    static_assert(sizeof(::Unity::Collections::Allocator) == 0x4);
    public:
    // Creating value type constructor for type: InputControlList_1
    constexpr InputControlList_1(int m_Count_ = {}, ::Unity::Collections::NativeArray_1<uint64_t> m_Indices_ = {}, ::Unity::Collections::Allocator m_Allocator_ = {}) noexcept : m_Count{m_Count_}, m_Indices{m_Indices_}, m_Allocator{m_Allocator_} {}
    // Creating interface conversion operator: operator ::System::ValueType
    operator ::System::ValueType() noexcept {
      return *reinterpret_cast<::System::ValueType*>(this);
    }
    // Creating interface conversion operator: operator ::System::Collections::Generic::IList_1<TControl>
    operator ::System::Collections::Generic::IList_1<TControl>() noexcept {
      return *reinterpret_cast<::System::Collections::Generic::IList_1<TControl>*>(this);
    }
    // Creating interface conversion operator: operator ::System::Collections::Generic::IReadOnlyList_1<TControl>
    operator ::System::Collections::Generic::IReadOnlyList_1<TControl>() noexcept {
      return *reinterpret_cast<::System::Collections::Generic::IReadOnlyList_1<TControl>*>(this);
    }
    // Creating interface conversion operator: operator ::System::IDisposable
    operator ::System::IDisposable() noexcept {
      return *reinterpret_cast<::System::IDisposable*>(this);
    }
    // Autogenerated static field getter
    // Get static field: static private System.UInt64 kInvalidIndex
    static uint64_t _get_kInvalidIndex() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::_get_kInvalidIndex");
      return THROW_UNLESS(il2cpp_utils::GetFieldValue<uint64_t>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<InputControlList_1<TControl>>::get(), "kInvalidIndex"));
    }
    // Autogenerated static field setter
    // Set static field: static private System.UInt64 kInvalidIndex
    static void _set_kInvalidIndex(uint64_t value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::_set_kInvalidIndex");
      THROW_UNLESS(il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<InputControlList_1<TControl>>::get(), "kInvalidIndex", value));
    }
    // Autogenerated instance field getter
    // Get instance field: private System.Int32 m_Count
    [[deprecated("Use field access instead!")]] int& dyn_m_Count() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::dyn_m_Count");
      auto ___internal__instance = *this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Count"))->offset;
      return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private Unity.Collections.NativeArray`1<System.UInt64> m_Indices
    [[deprecated("Use field access instead!")]] ::Unity::Collections::NativeArray_1<uint64_t>& dyn_m_Indices() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::dyn_m_Indices");
      auto ___internal__instance = *this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Indices"))->offset;
      return *reinterpret_cast<::Unity::Collections::NativeArray_1<uint64_t>*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private readonly Unity.Collections.Allocator m_Allocator
    [[deprecated("Use field access instead!")]] ::Unity::Collections::Allocator& dyn_m_Allocator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::dyn_m_Allocator");
      auto ___internal__instance = *this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Allocator"))->offset;
      return *reinterpret_cast<::Unity::Collections::Allocator*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // public System.Int32 get_Count()
    // Offset: 0xFFFFFFFFFFFFFFFF
    int get_Count() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::get_Count");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      return ::il2cpp_utils::RunMethodRethrow<int, false>(this, ___internal__method);
    }
    // public System.Int32 get_Capacity()
    // Offset: 0xFFFFFFFFFFFFFFFF
    int get_Capacity() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::get_Capacity");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "get_Capacity", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      return ::il2cpp_utils::RunMethodRethrow<int, false>(this, ___internal__method);
    }
    // public System.Void set_Capacity(System.Int32 value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void set_Capacity(int value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::set_Capacity");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "set_Capacity", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(value)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, value);
    }
    // public System.Boolean get_IsReadOnly()
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool get_IsReadOnly() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::get_IsReadOnly");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method);
    }
    // public TControl get_Item(System.Int32 index)
    // Offset: 0xFFFFFFFFFFFFFFFF
    TControl get_Item(int index) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::get_Item");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      return ::il2cpp_utils::RunMethodRethrow<TControl, false>(this, ___internal__method, index);
    }
    // public System.Void set_Item(System.Int32 index, TControl value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void set_Item(int index, TControl value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::set_Item");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, index, value);
    }
    // public System.Void .ctor(Unity.Collections.Allocator allocator, System.Int32 initialCapacity)
    // Offset: 0xFFFFFFFFFFFFFFFF
    InputControlList_1(::Unity::Collections::Allocator allocator, int initialCapacity) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::.ctor");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, ".ctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(allocator), ::il2cpp_utils::ExtractType(initialCapacity)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, allocator, initialCapacity);
    }
    // public System.Void .ctor(System.Collections.Generic.IEnumerable`1<TControl> values, Unity.Collections.Allocator allocator)
    // Offset: 0xFFFFFFFFFFFFFFFF
    InputControlList_1(::System::Collections::Generic::IEnumerable_1<TControl>* values, ::Unity::Collections::Allocator allocator) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::.ctor");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, ".ctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(values), ::il2cpp_utils::ExtractType(allocator)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, values, allocator);
    }
    // public System.Void .ctor(params TControl[] values)
    // Offset: 0xFFFFFFFFFFFFFFFF
    InputControlList_1(::ArrayW<TControl> values) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::.ctor");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, ".ctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(values)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, values);
    }
    // public System.Void Add(TControl item)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Add(TControl item) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Add");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, item);
    }
    // public System.Void AddSlice(TList list, System.Int32 count, System.Int32 destinationIndex, System.Int32 sourceIndex)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TList>
    void AddSlice(TList list, int count, int destinationIndex, int sourceIndex) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TList>, ::System::Collections::Generic::IReadOnlyList_1<TControl>>);
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::AddSlice");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "AddSlice", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TList>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(list), ::il2cpp_utils::ExtractType(count), ::il2cpp_utils::ExtractType(destinationIndex), ::il2cpp_utils::ExtractType(sourceIndex)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TList>::get()}));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___generic__method, list, count, destinationIndex, sourceIndex);
    }
    // public System.Void AddRange(System.Collections.Generic.IEnumerable`1<TControl> list, System.Int32 count, System.Int32 destinationIndex)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void AddRange(::System::Collections::Generic::IEnumerable_1<TControl>* list, int count, int destinationIndex) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::AddRange");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "AddRange", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(list), ::il2cpp_utils::ExtractType(count), ::il2cpp_utils::ExtractType(destinationIndex)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, list, count, destinationIndex);
    }
    // public System.Boolean Remove(TControl item)
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool Remove(TControl item) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Remove");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, item);
    }
    // public System.Void RemoveAt(System.Int32 index)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void RemoveAt(int index) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::RemoveAt");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, index);
    }
    // public System.Void CopyTo(TControl[] array, System.Int32 arrayIndex)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void CopyTo(::ArrayW<TControl> array, int arrayIndex) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::CopyTo");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, array, arrayIndex);
    }
    // public System.Int32 IndexOf(TControl item)
    // Offset: 0xFFFFFFFFFFFFFFFF
    int IndexOf(TControl item) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::IndexOf");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      return ::il2cpp_utils::RunMethodRethrow<int, false>(this, ___internal__method, item);
    }
    // public System.Void Insert(System.Int32 index, TControl item)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Insert(int index, TControl item) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Insert");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, index, item);
    }
    // public System.Void Clear()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Clear() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Clear");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
    // public System.Boolean Contains(TControl item)
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool Contains(TControl item) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Contains");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, item);
    }
    // public System.Void SwapElements(System.Int32 index1, System.Int32 index2)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void SwapElements(int index1, int index2) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::SwapElements");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "SwapElements", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(index1), ::il2cpp_utils::ExtractType(index2)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, index1, index2);
    }
    // public System.Void Sort(System.Int32 startIndex, System.Int32 count, TCompare comparer)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class TCompare>
    void Sort(int startIndex, int count, TCompare comparer) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<TCompare>, ::System::Collections::Generic::IComparer_1<TControl>>);
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Sort");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "Sort", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TCompare>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(startIndex), ::il2cpp_utils::ExtractType(count), ::il2cpp_utils::ExtractType(comparer)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<TCompare>::get()}));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___generic__method, startIndex, count, comparer);
    }
    // public TControl[] ToArray(System.Boolean dispose)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::ArrayW<TControl> ToArray(bool dispose) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::ToArray");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "ToArray", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(dispose)})));
      return ::il2cpp_utils::RunMethodRethrow<::ArrayW<TControl>, false>(this, ___internal__method, dispose);
    }
    // System.Void AppendTo(ref TControl[] array, ref System.Int32 count)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void AppendTo(ByRef<::ArrayW<TControl>> array, ByRef<int> count) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::AppendTo");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "AppendTo", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(array), ::il2cpp_utils::ExtractType(count)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, byref(array), byref(count));
    }
    // public System.Void Dispose()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Dispose() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::Dispose");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
    // public System.Collections.Generic.IEnumerator`1<TControl> GetEnumerator()
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::System::Collections::Generic::IEnumerator_1<TControl>* GetEnumerator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::GetEnumerator");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::IEnumerator_1<TControl>*, false>(this, ___internal__method);
    }
    // private System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::System::Collections::IEnumerator* System_Collections_IEnumerable_GetEnumerator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::System.Collections.IEnumerable.GetEnumerator");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::UnityEngine::InputSystem::InputControlList_1<TControl>), -1));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::IEnumerator*, false>(this, ___internal__method);
    }
    // static private System.UInt64 ToIndex(TControl control)
    // Offset: 0xFFFFFFFFFFFFFFFF
    static uint64_t ToIndex(TControl control) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::ToIndex");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<InputControlList_1<TControl>>::get(), "ToIndex", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(control)})));
      return ::il2cpp_utils::RunMethodRethrow<uint64_t, false>(static_cast<Il2CppObject*>(nullptr), ___internal__method, control);
    }
    // static private TControl FromIndex(System.UInt64 index)
    // Offset: 0xFFFFFFFFFFFFFFFF
    static TControl FromIndex(uint64_t index) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::FromIndex");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<InputControlList_1<TControl>>::get(), "FromIndex", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(index)})));
      return ::il2cpp_utils::RunMethodRethrow<TControl, false>(static_cast<Il2CppObject*>(nullptr), ___internal__method, index);
    }
    // public override System.String ToString()
    // Offset: 0xFFFFFFFFFFFFFFFF
    // Implemented from: System.ValueType
    // Base method: System.String ValueType::ToString()
    ::StringW ToString() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::InputSystem::InputControlList_1::ToString");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(*this, classof(::System::ValueType*), -1));
      return ::il2cpp_utils::RunMethodRethrow<::StringW, false>(this, ___internal__method);
    }
  }; // UnityEngine.InputSystem.InputControlList`1
  // Could not write size check! Type: UnityEngine.InputSystem.InputControlList`1 is generic, or has no fields that are valid for size checks!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
