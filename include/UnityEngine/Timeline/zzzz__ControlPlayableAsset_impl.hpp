#pragma once
#include "UnityEngine/Playables/zzzz__PlayableAsset_impl.hpp"
#include "UnityEngine/Timeline/zzzz__ControlPlayableAsset_def.hpp"
#include "UnityEngine/Playables/zzzz__PlayableDirector_def.hpp"
#include "UnityEngine/zzzz__MonoBehaviour_def.hpp"
#include "UnityEngine/Playables/zzzz__PlayableGraph_def.hpp"
#include "UnityEngine/zzzz__Transform_def.hpp"
#include "UnityEngine/Timeline/zzzz__IPropertyCollector_def.hpp"
#include "System/Collections/Generic/zzzz__ICollection_1_def.hpp"
#include "UnityEngine/zzzz__ExposedReference_1_def.hpp"
#include "System/Collections/Generic/zzzz__IEnumerable_1_def.hpp"
#include "UnityEngine/Timeline/zzzz__ITimelineClipAsset_def.hpp"
#include "UnityEngine/Timeline/zzzz__IPropertyPreview_def.hpp"
#include "System/Collections/Generic/zzzz__IList_1_def.hpp"
#include "UnityEngine/Timeline/zzzz__ActivationControlPlayable_def.hpp"
#include "UnityEngine/Playables/zzzz__PlayableAsset_def.hpp"
#include "System/Collections/Generic/zzzz__List_1_def.hpp"
#include "System/Collections/Generic/zzzz__HashSet_1_def.hpp"
#include "UnityEngine/zzzz__GameObject_def.hpp"
#include "UnityEngine/Playables/zzzz__Playable_def.hpp"
#include "UnityEngine/Timeline/zzzz__ClipCaps_def.hpp"
#include "UnityEngine/zzzz__ParticleSystem_def.hpp"
#include "System/Collections/zzzz__IEnumerator_def.hpp"
#include "System/zzzz__IDisposable_def.hpp"
#include "System/Collections/Generic/zzzz__IEnumerator_1_def.hpp"
#include "System/Collections/zzzz__IEnumerable_def.hpp"
//  Writing Method size for method: UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39._ctor
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::*)(int32_t)>(&UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::_ctor)> {
  constexpr static std::size_t size = 0x34;
  constexpr static std::size_t addrs = 0x2accb18;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            ".ctor",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<int32_t>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39.System_IDisposable_Dispose
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::*)()>(&UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_IDisposable_Dispose)> {
  constexpr static std::size_t size = 0x4;
  constexpr static std::size_t addrs = 0x2ace368;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.IDisposable.Dispose",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39.MoveNext
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::*)()>(&UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::MoveNext)> {
  constexpr static std::size_t size = 0x13c;
  constexpr static std::size_t addrs = 0x2ace36c;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "MoveNext",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39.System_Collections_Generic_IEnumerator_UnityEngine_MonoBehaviour__get_Current
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::MonoBehaviour (UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::*)()>(&UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_Generic_IEnumerator_UnityEngine_MonoBehaviour__get_Current)> {
  constexpr static std::size_t size = 0x8;
  constexpr static std::size_t addrs = 0x2ace4a8;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.Generic.IEnumerator<UnityEngine.MonoBehaviour>.get_Current",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39.System_Collections_IEnumerator_Reset
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::*)()>(&UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_IEnumerator_Reset)> {
  constexpr static std::size_t size = 0x40;
  constexpr static std::size_t addrs = 0x2ace4b0;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.IEnumerator.Reset",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39.System_Collections_IEnumerator_get_Current
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::bs_hook::Il2CppWrapperType (UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::*)()>(&UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_IEnumerator_get_Current)> {
  constexpr static std::size_t size = 0x8;
  constexpr static std::size_t addrs = 0x2ace4f0;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.IEnumerator.get_Current",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39.System_Collections_Generic_IEnumerable_UnityEngine_MonoBehaviour__GetEnumerator
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::IEnumerator_1<UnityEngine::MonoBehaviour> (UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::*)()>(&UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_Generic_IEnumerable_UnityEngine_MonoBehaviour__GetEnumerator)> {
  constexpr static std::size_t size = 0xa4;
  constexpr static std::size_t addrs = 0x2ace4f8;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.Generic.IEnumerable<UnityEngine.MonoBehaviour>.GetEnumerator",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39.System_Collections_IEnumerable_GetEnumerator
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::IEnumerator (UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::*)()>(&UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_IEnumerable_GetEnumerator)> {
  constexpr static std::size_t size = 0x4;
  constexpr static std::size_t addrs = 0x2ace59c;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.IEnumerable.GetEnumerator",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
/// @brief Convert operator to System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>
constexpr  UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::operator System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>() const noexcept {
return System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>(::bs_hook::Il2CppWrapperType::instance);
}
/// @brief Convert operator to System::Collections::IEnumerable
constexpr  UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::operator System::Collections::IEnumerable() const noexcept {
return System::Collections::IEnumerable(::bs_hook::Il2CppWrapperType::instance);
}
/// @brief Convert operator to System::Collections::Generic::IEnumerator_1<UnityEngine::MonoBehaviour>
constexpr  UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::operator System::Collections::Generic::IEnumerator_1<UnityEngine::MonoBehaviour>() const noexcept {
return System::Collections::Generic::IEnumerator_1<UnityEngine::MonoBehaviour>(::bs_hook::Il2CppWrapperType::instance);
}
/// @brief Convert operator to System::Collections::IEnumerator
constexpr  UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::operator System::Collections::IEnumerator() const noexcept {
return System::Collections::IEnumerator(::bs_hook::Il2CppWrapperType::instance);
}
/// @brief Convert operator to System::IDisposable
constexpr  UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::operator System::IDisposable() const noexcept {
return System::IDisposable(::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__set___1__state(int32_t value)  {
::cordl_internals::setInstanceField<int32_t, 0x10>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<int32_t>(value));
}
constexpr int32_t UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__get___1__state() const {
return ::cordl_internals::getInstanceField<int32_t, 0x10>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__set___2__current(UnityEngine::MonoBehaviour value)  {
::cordl_internals::setInstanceField<UnityEngine::MonoBehaviour, 0x18>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<UnityEngine::MonoBehaviour>(value));
}
constexpr UnityEngine::MonoBehaviour UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__get___2__current() const {
return ::cordl_internals::getInstanceField<UnityEngine::MonoBehaviour, 0x18>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__set___l__initialThreadId(int32_t value)  {
::cordl_internals::setInstanceField<int32_t, 0x20>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<int32_t>(value));
}
constexpr int32_t UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__get___l__initialThreadId() const {
return ::cordl_internals::getInstanceField<int32_t, 0x20>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__set_root(UnityEngine::GameObject value)  {
::cordl_internals::setInstanceField<UnityEngine::GameObject, 0x28>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<UnityEngine::GameObject>(value));
}
constexpr UnityEngine::GameObject UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__get_root() const {
return ::cordl_internals::getInstanceField<UnityEngine::GameObject, 0x28>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__set___3__root(UnityEngine::GameObject value)  {
::cordl_internals::setInstanceField<UnityEngine::GameObject, 0x30>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<UnityEngine::GameObject>(value));
}
constexpr UnityEngine::GameObject UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__get___3__root() const {
return ::cordl_internals::getInstanceField<UnityEngine::GameObject, 0x30>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__set___7__wrap1(::ArrayW<UnityEngine::MonoBehaviour> value)  {
::cordl_internals::setInstanceField<::ArrayW<UnityEngine::MonoBehaviour>, 0x38>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<::ArrayW<UnityEngine::MonoBehaviour>>(value));
}
constexpr ::ArrayW<UnityEngine::MonoBehaviour> UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__get___7__wrap1() const {
return ::cordl_internals::getInstanceField<::ArrayW<UnityEngine::MonoBehaviour>, 0x38>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__set___7__wrap2(int32_t value)  {
::cordl_internals::setInstanceField<int32_t, 0x40>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<int32_t>(value));
}
constexpr int32_t UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::__get___7__wrap2() const {
return ::cordl_internals::getInstanceField<int32_t, 0x40>(this->::bs_hook::Il2CppWrapperType::instance);
}
// Ctor Parameters [CppParam { name: "__1__state", ty: "int32_t", modifiers: "", def_value: None }]
 UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39(int32_t __1__state)  : ::bs_hook::Il2CppWrapperType(THROW_UNLESS(::il2cpp_utils::New<UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>(__1__state))) {}
 void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::_ctor(int32_t __1__state)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            ".ctor",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<int32_t>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method, __1__state);
}
 void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_IDisposable_Dispose()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.IDisposable.Dispose",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method);
}
 bool UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::MoveNext()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "MoveNext",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<bool, false>(const_cast<void*>(instance), ___internal_method);
}
 UnityEngine::MonoBehaviour UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_Generic_IEnumerator_UnityEngine_MonoBehaviour__get_Current()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.Generic.IEnumerator<UnityEngine.MonoBehaviour>.get_Current",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<UnityEngine::MonoBehaviour, false>(const_cast<void*>(instance), ___internal_method);
}
 void UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_IEnumerator_Reset()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.IEnumerator.Reset",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method);
}
 ::bs_hook::Il2CppWrapperType UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_IEnumerator_get_Current()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.IEnumerator.get_Current",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<::bs_hook::Il2CppWrapperType, false>(const_cast<void*>(instance), ___internal_method);
}
 System::Collections::Generic::IEnumerator_1<UnityEngine::MonoBehaviour> UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_Generic_IEnumerable_UnityEngine_MonoBehaviour__GetEnumerator()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.Generic.IEnumerable<UnityEngine.MonoBehaviour>.GetEnumerator",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<System::Collections::Generic::IEnumerator_1<UnityEngine::MonoBehaviour>, false>(const_cast<void*>(instance), ___internal_method);
}
 System::Collections::IEnumerator UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39::System_Collections_IEnumerable_GetEnumerator()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::UnityEngine__Timeline__ControlPlayableAsset___GetControlableScripts_d__39>::get(),
                            "System.Collections.IEnumerable.GetEnumerator",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<System::Collections::IEnumerator, false>(const_cast<void*>(instance), ___internal_method);
}
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.get_controllingDirectors
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::Timeline::ControlPlayableAsset::*)()>(&UnityEngine::Timeline::ControlPlayableAsset::get_controllingDirectors)> {
  constexpr static std::size_t size = 0x8;
  constexpr static std::size_t addrs = 0x2aca4ac;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "get_controllingDirectors",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.set_controllingDirectors
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::ControlPlayableAsset::*)(bool)>(&UnityEngine::Timeline::ControlPlayableAsset::set_controllingDirectors)> {
  constexpr static std::size_t size = 0xc;
  constexpr static std::size_t addrs = 0x2aca4b4;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "set_controllingDirectors",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<bool>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.get_controllingParticles
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::Timeline::ControlPlayableAsset::*)()>(&UnityEngine::Timeline::ControlPlayableAsset::get_controllingParticles)> {
  constexpr static std::size_t size = 0x8;
  constexpr static std::size_t addrs = 0x2aca4c0;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "get_controllingParticles",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.set_controllingParticles
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::ControlPlayableAsset::*)(bool)>(&UnityEngine::Timeline::ControlPlayableAsset::set_controllingParticles)> {
  constexpr static std::size_t size = 0xc;
  constexpr static std::size_t addrs = 0x2aca4c8;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "set_controllingParticles",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<bool>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.OnEnable
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::ControlPlayableAsset::*)()>(&UnityEngine::Timeline::ControlPlayableAsset::OnEnable)> {
  constexpr static std::size_t size = 0x2c;
  constexpr static std::size_t addrs = 0x2aca4d4;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "OnEnable",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.get_duration
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<double_t (UnityEngine::Timeline::ControlPlayableAsset::*)()>(&UnityEngine::Timeline::ControlPlayableAsset::get_duration)> {
  constexpr static std::size_t size = 0x8;
  constexpr static std::size_t addrs = 0x2aca500;

  inline static const ::MethodInfo* methodInfo() {
    
                            static auto* ___internal_method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(
                                classof(UnityEngine::Timeline::ControlPlayableAsset),
                                 ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                                  7
                                ));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.get_clipCaps
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Timeline::ClipCaps (UnityEngine::Timeline::ControlPlayableAsset::*)()>(&UnityEngine::Timeline::ControlPlayableAsset::get_clipCaps)> {
  constexpr static std::size_t size = 0xc;
  constexpr static std::size_t addrs = 0x2aca508;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "get_clipCaps",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.CreatePlayable
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Playables::Playable (UnityEngine::Timeline::ControlPlayableAsset::*)(UnityEngine::Playables::PlayableGraph, UnityEngine::GameObject)>(&UnityEngine::Timeline::ControlPlayableAsset::CreatePlayable)> {
  constexpr static std::size_t size = 0x808;
  constexpr static std::size_t addrs = 0x2aca514;

  inline static const ::MethodInfo* methodInfo() {
    
                            static auto* ___internal_method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(
                                classof(UnityEngine::Timeline::ControlPlayableAsset),
                                 ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                                  6
                                ));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.ConnectPlayablesToMixer
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Playables::Playable (*)(UnityEngine::Playables::PlayableGraph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable>)>(&UnityEngine::Timeline::ControlPlayableAsset::ConnectPlayablesToMixer)> {
  constexpr static std::size_t size = 0x168;
  constexpr static std::size_t addrs = 0x2acc678;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "ConnectPlayablesToMixer",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.CreateActivationPlayable
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::ControlPlayableAsset::*)(UnityEngine::GameObject, UnityEngine::Playables::PlayableGraph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable>)>(&UnityEngine::Timeline::ControlPlayableAsset::CreateActivationPlayable)> {
  constexpr static std::size_t size = 0x158;
  constexpr static std::size_t addrs = 0x2acb798;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "CreateActivationPlayable",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::GameObject>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.SearchHierarchyAndConnectParticleSystem
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::ControlPlayableAsset::*)(System::Collections::Generic::IEnumerable_1<UnityEngine::ParticleSystem>, UnityEngine::Playables::PlayableGraph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable>)>(&UnityEngine::Timeline::ControlPlayableAsset::SearchHierarchyAndConnectParticleSystem)> {
  constexpr static std::size_t size = 0x438;
  constexpr static std::size_t addrs = 0x2acbd9c;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "SearchHierarchyAndConnectParticleSystem",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::ParticleSystem>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.SearchHierarchyAndConnectDirector
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::ControlPlayableAsset::*)(System::Collections::Generic::IEnumerable_1<UnityEngine::Playables::PlayableDirector>, UnityEngine::Playables::PlayableGraph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable>, bool)>(&UnityEngine::Timeline::ControlPlayableAsset::SearchHierarchyAndConnectDirector)> {
  constexpr static std::size_t size = 0x4ac;
  constexpr static std::size_t addrs = 0x2acb8f0;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "SearchHierarchyAndConnectDirector",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::Playables::PlayableDirector>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<bool>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.SearchHierarchyAndConnectControlableScripts
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>, UnityEngine::Playables::PlayableGraph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable>)>(&UnityEngine::Timeline::ControlPlayableAsset::SearchHierarchyAndConnectControlableScripts)> {
  constexpr static std::size_t size = 0x42c;
  constexpr static std::size_t addrs = 0x2acc24c;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "SearchHierarchyAndConnectControlableScripts",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.ConnectMixerAndPlayable
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(UnityEngine::Playables::PlayableGraph, UnityEngine::Playables::Playable, UnityEngine::Playables::Playable, int32_t)>(&UnityEngine::Timeline::ControlPlayableAsset::ConnectMixerAndPlayable)> {
  constexpr static std::size_t size = 0xc8;
  constexpr static std::size_t addrs = 0x2acc7e0;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "ConnectMixerAndPlayable",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::Playable>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::Playable>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<int32_t>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.GetControlableScripts
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour> (*)(UnityEngine::GameObject)>(&UnityEngine::Timeline::ControlPlayableAsset::GetControlableScripts)> {
  constexpr static std::size_t size = 0x78;
  constexpr static std::size_t addrs = 0x2acc1d4;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "GetControlableScripts",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::GameObject>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.UpdateDurationAndLoopFlag
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::ControlPlayableAsset::*)(System::Collections::Generic::IList_1<UnityEngine::Playables::PlayableDirector>, System::Collections::Generic::IList_1<UnityEngine::ParticleSystem>)>(&UnityEngine::Timeline::ControlPlayableAsset::UpdateDurationAndLoopFlag)> {
  constexpr static std::size_t size = 0x90c;
  constexpr static std::size_t addrs = 0x2acae8c;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "UpdateDurationAndLoopFlag",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IList_1<UnityEngine::Playables::PlayableDirector>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IList_1<UnityEngine::ParticleSystem>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.GetControllableParticleSystems
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<System::Collections::Generic::IList_1<UnityEngine::ParticleSystem> (UnityEngine::Timeline::ControlPlayableAsset::*)(UnityEngine::GameObject)>(&UnityEngine::Timeline::ControlPlayableAsset::GetControllableParticleSystems)> {
  constexpr static std::size_t size = 0x170;
  constexpr static std::size_t addrs = 0x2acad1c;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "GetControllableParticleSystems",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::GameObject>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.GetControllableParticleSystems
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(UnityEngine::Transform, System::Collections::Generic::ICollection_1<UnityEngine::ParticleSystem>, System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem>)>(&UnityEngine::Timeline::ControlPlayableAsset::GetControllableParticleSystems)> {
  constexpr static std::size_t size = 0x1e8;
  constexpr static std::size_t addrs = 0x2accb58;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "GetControllableParticleSystems",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Transform>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::ICollection_1<UnityEngine::ParticleSystem>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.CacheSubEmitters
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(UnityEngine::ParticleSystem, System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem>)>(&UnityEngine::Timeline::ControlPlayableAsset::CacheSubEmitters)> {
  constexpr static std::size_t size = 0x114;
  constexpr static std::size_t addrs = 0x2accd40;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "CacheSubEmitters",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::ParticleSystem>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.GatherProperties
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::ControlPlayableAsset::*)(UnityEngine::Playables::PlayableDirector, UnityEngine::Timeline::IPropertyCollector)>(&UnityEngine::Timeline::ControlPlayableAsset::GatherProperties)> {
  constexpr static std::size_t size = 0x30c;
  constexpr static std::size_t addrs = 0x2acce54;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "GatherProperties",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableDirector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.PreviewParticles
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(UnityEngine::Timeline::IPropertyCollector, System::Collections::Generic::IEnumerable_1<UnityEngine::ParticleSystem>)>(&UnityEngine::Timeline::ControlPlayableAsset::PreviewParticles)> {
  constexpr static std::size_t size = 0x460;
  constexpr static std::size_t addrs = 0x2acd160;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "PreviewParticles",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::ParticleSystem>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.PreviewActivation
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(UnityEngine::Timeline::IPropertyCollector, System::Collections::Generic::IEnumerable_1<UnityEngine::GameObject>)>(&UnityEngine::Timeline::ControlPlayableAsset::PreviewActivation)> {
  constexpr static std::size_t size = 0x37c;
  constexpr static std::size_t addrs = 0x2acd5c0;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "PreviewActivation",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::GameObject>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.PreviewTimeControl
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(UnityEngine::Timeline::IPropertyCollector, UnityEngine::Playables::PlayableDirector, System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>)>(&UnityEngine::Timeline::ControlPlayableAsset::PreviewTimeControl)> {
  constexpr static std::size_t size = 0x41c;
  constexpr static std::size_t addrs = 0x2acd93c;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "PreviewTimeControl",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableDirector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset.PreviewDirectors
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(UnityEngine::Timeline::IPropertyCollector, System::Collections::Generic::IEnumerable_1<UnityEngine::Playables::PlayableDirector>)>(&UnityEngine::Timeline::ControlPlayableAsset::PreviewDirectors)> {
  constexpr static std::size_t size = 0x3c8;
  constexpr static std::size_t addrs = 0x2acdd58;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "PreviewDirectors",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::Playables::PlayableDirector>>::get()}
                        )));
    return ___internal_method;
  }
};
//  Writing Method size for method: UnityEngine::Timeline::ControlPlayableAsset._ctor
template<>

struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::ControlPlayableAsset::*)()>(&UnityEngine::Timeline::ControlPlayableAsset::_ctor)> {
  constexpr static std::size_t size = 0x84;
  constexpr static std::size_t addrs = 0x2ace120;

  inline static const ::MethodInfo* methodInfo() {
    static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            ".ctor",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
    return ___internal_method;
  }
};
/// @brief Convert operator to UnityEngine::Timeline::IPropertyPreview
constexpr  UnityEngine::Timeline::ControlPlayableAsset::operator UnityEngine::Timeline::IPropertyPreview() const noexcept {
return UnityEngine::Timeline::IPropertyPreview(::bs_hook::Il2CppWrapperType::instance);
}
/// @brief Convert operator to UnityEngine::Timeline::ITimelineClipAsset
constexpr  UnityEngine::Timeline::ControlPlayableAsset::operator UnityEngine::Timeline::ITimelineClipAsset() const noexcept {
return UnityEngine::Timeline::ITimelineClipAsset(::bs_hook::Il2CppWrapperType::instance);
}
 void UnityEngine::Timeline::ControlPlayableAsset::__set_k_EmptyDirectorsList(System::Collections::Generic::List_1<UnityEngine::Playables::PlayableDirector> value)  {
::cordl_internals::setStaticField<System::Collections::Generic::List_1<UnityEngine::Playables::PlayableDirector>, "k_EmptyDirectorsList", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>(std::forward<System::Collections::Generic::List_1<UnityEngine::Playables::PlayableDirector>>(value));
}
 System::Collections::Generic::List_1<UnityEngine::Playables::PlayableDirector> UnityEngine::Timeline::ControlPlayableAsset::__get_k_EmptyDirectorsList()  {
return ::cordl_internals::getStaticField<System::Collections::Generic::List_1<UnityEngine::Playables::PlayableDirector>, "k_EmptyDirectorsList", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>();
}
 void UnityEngine::Timeline::ControlPlayableAsset::__set_k_EmptyParticlesList(System::Collections::Generic::List_1<UnityEngine::ParticleSystem> value)  {
::cordl_internals::setStaticField<System::Collections::Generic::List_1<UnityEngine::ParticleSystem>, "k_EmptyParticlesList", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>(std::forward<System::Collections::Generic::List_1<UnityEngine::ParticleSystem>>(value));
}
 System::Collections::Generic::List_1<UnityEngine::ParticleSystem> UnityEngine::Timeline::ControlPlayableAsset::__get_k_EmptyParticlesList()  {
return ::cordl_internals::getStaticField<System::Collections::Generic::List_1<UnityEngine::ParticleSystem>, "k_EmptyParticlesList", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>();
}
 void UnityEngine::Timeline::ControlPlayableAsset::__set_s_SubEmitterCollector(System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem> value)  {
::cordl_internals::setStaticField<System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem>, "s_SubEmitterCollector", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>(std::forward<System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem>>(value));
}
 System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem> UnityEngine::Timeline::ControlPlayableAsset::__get_s_SubEmitterCollector()  {
return ::cordl_internals::getStaticField<System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem>, "s_SubEmitterCollector", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>();
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_sourceGameObject(UnityEngine::ExposedReference_1<UnityEngine::GameObject> value)  {
::cordl_internals::setInstanceField<UnityEngine::ExposedReference_1<UnityEngine::GameObject>, 0x18>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<UnityEngine::ExposedReference_1<UnityEngine::GameObject>>(value));
}
constexpr UnityEngine::ExposedReference_1<UnityEngine::GameObject> UnityEngine::Timeline::ControlPlayableAsset::__get_sourceGameObject() const {
return ::cordl_internals::getInstanceField<UnityEngine::ExposedReference_1<UnityEngine::GameObject>, 0x18>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_prefabGameObject(UnityEngine::GameObject value)  {
::cordl_internals::setInstanceField<UnityEngine::GameObject, 0x28>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<UnityEngine::GameObject>(value));
}
constexpr UnityEngine::GameObject UnityEngine::Timeline::ControlPlayableAsset::__get_prefabGameObject() const {
return ::cordl_internals::getInstanceField<UnityEngine::GameObject, 0x28>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_updateParticle(bool value)  {
::cordl_internals::setInstanceField<bool, 0x30>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<bool>(value));
}
constexpr bool UnityEngine::Timeline::ControlPlayableAsset::__get_updateParticle() const {
return ::cordl_internals::getInstanceField<bool, 0x30>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_particleRandomSeed(uint32_t value)  {
::cordl_internals::setInstanceField<uint32_t, 0x34>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<uint32_t>(value));
}
constexpr uint32_t UnityEngine::Timeline::ControlPlayableAsset::__get_particleRandomSeed() const {
return ::cordl_internals::getInstanceField<uint32_t, 0x34>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_updateDirector(bool value)  {
::cordl_internals::setInstanceField<bool, 0x38>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<bool>(value));
}
constexpr bool UnityEngine::Timeline::ControlPlayableAsset::__get_updateDirector() const {
return ::cordl_internals::getInstanceField<bool, 0x38>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_updateITimeControl(bool value)  {
::cordl_internals::setInstanceField<bool, 0x39>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<bool>(value));
}
constexpr bool UnityEngine::Timeline::ControlPlayableAsset::__get_updateITimeControl() const {
return ::cordl_internals::getInstanceField<bool, 0x39>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_searchHierarchy(bool value)  {
::cordl_internals::setInstanceField<bool, 0x3a>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<bool>(value));
}
constexpr bool UnityEngine::Timeline::ControlPlayableAsset::__get_searchHierarchy() const {
return ::cordl_internals::getInstanceField<bool, 0x3a>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_active(bool value)  {
::cordl_internals::setInstanceField<bool, 0x3b>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<bool>(value));
}
constexpr bool UnityEngine::Timeline::ControlPlayableAsset::__get_active() const {
return ::cordl_internals::getInstanceField<bool, 0x3b>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_postPlayback(UnityEngine::Timeline::UnityEngine__Timeline__ActivationControlPlayable__PostPlaybackState value)  {
::cordl_internals::setInstanceField<UnityEngine::Timeline::UnityEngine__Timeline__ActivationControlPlayable__PostPlaybackState, 0x3c>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<UnityEngine::Timeline::UnityEngine__Timeline__ActivationControlPlayable__PostPlaybackState>(value));
}
constexpr UnityEngine::Timeline::UnityEngine__Timeline__ActivationControlPlayable__PostPlaybackState UnityEngine::Timeline::ControlPlayableAsset::__get_postPlayback() const {
return ::cordl_internals::getInstanceField<UnityEngine::Timeline::UnityEngine__Timeline__ActivationControlPlayable__PostPlaybackState, 0x3c>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_m_ControlDirectorAsset(UnityEngine::Playables::PlayableAsset value)  {
::cordl_internals::setInstanceField<UnityEngine::Playables::PlayableAsset, 0x40>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<UnityEngine::Playables::PlayableAsset>(value));
}
constexpr UnityEngine::Playables::PlayableAsset UnityEngine::Timeline::ControlPlayableAsset::__get_m_ControlDirectorAsset() const {
return ::cordl_internals::getInstanceField<UnityEngine::Playables::PlayableAsset, 0x40>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_m_Duration(double_t value)  {
::cordl_internals::setInstanceField<double_t, 0x48>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<double_t>(value));
}
constexpr double_t UnityEngine::Timeline::ControlPlayableAsset::__get_m_Duration() const {
return ::cordl_internals::getInstanceField<double_t, 0x48>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set_m_SupportLoop(bool value)  {
::cordl_internals::setInstanceField<bool, 0x50>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<bool>(value));
}
constexpr bool UnityEngine::Timeline::ControlPlayableAsset::__get_m_SupportLoop() const {
return ::cordl_internals::getInstanceField<bool, 0x50>(this->::bs_hook::Il2CppWrapperType::instance);
}
 void UnityEngine::Timeline::ControlPlayableAsset::__set_s_ProcessedDirectors(System::Collections::Generic::HashSet_1<UnityEngine::Playables::PlayableDirector> value)  {
::cordl_internals::setStaticField<System::Collections::Generic::HashSet_1<UnityEngine::Playables::PlayableDirector>, "s_ProcessedDirectors", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>(std::forward<System::Collections::Generic::HashSet_1<UnityEngine::Playables::PlayableDirector>>(value));
}
 System::Collections::Generic::HashSet_1<UnityEngine::Playables::PlayableDirector> UnityEngine::Timeline::ControlPlayableAsset::__get_s_ProcessedDirectors()  {
return ::cordl_internals::getStaticField<System::Collections::Generic::HashSet_1<UnityEngine::Playables::PlayableDirector>, "s_ProcessedDirectors", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>();
}
 void UnityEngine::Timeline::ControlPlayableAsset::__set_s_CreatedPrefabs(System::Collections::Generic::HashSet_1<UnityEngine::GameObject> value)  {
::cordl_internals::setStaticField<System::Collections::Generic::HashSet_1<UnityEngine::GameObject>, "s_CreatedPrefabs", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>(std::forward<System::Collections::Generic::HashSet_1<UnityEngine::GameObject>>(value));
}
 System::Collections::Generic::HashSet_1<UnityEngine::GameObject> UnityEngine::Timeline::ControlPlayableAsset::__get_s_CreatedPrefabs()  {
return ::cordl_internals::getStaticField<System::Collections::Generic::HashSet_1<UnityEngine::GameObject>, "s_CreatedPrefabs", ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get>();
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set__controllingDirectors_k__BackingField(bool value)  {
::cordl_internals::setInstanceField<bool, 0x51>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<bool>(value));
}
constexpr bool UnityEngine::Timeline::ControlPlayableAsset::__get__controllingDirectors_k__BackingField() const {
return ::cordl_internals::getInstanceField<bool, 0x51>(this->::bs_hook::Il2CppWrapperType::instance);
}
constexpr void UnityEngine::Timeline::ControlPlayableAsset::__set__controllingParticles_k__BackingField(bool value)  {
::cordl_internals::setInstanceField<bool, 0x52>(this->::bs_hook::Il2CppWrapperType::instance, std::forward<bool>(value));
}
constexpr bool UnityEngine::Timeline::ControlPlayableAsset::__get__controllingParticles_k__BackingField() const {
return ::cordl_internals::getInstanceField<bool, 0x52>(this->::bs_hook::Il2CppWrapperType::instance);
}
 bool UnityEngine::Timeline::ControlPlayableAsset::get_controllingDirectors()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "get_controllingDirectors",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<bool, false>(const_cast<void*>(instance), ___internal_method);
}
 void UnityEngine::Timeline::ControlPlayableAsset::set_controllingDirectors(bool value)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "set_controllingDirectors",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<bool>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method, value);
}
 bool UnityEngine::Timeline::ControlPlayableAsset::get_controllingParticles()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "get_controllingParticles",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<bool, false>(const_cast<void*>(instance), ___internal_method);
}
 void UnityEngine::Timeline::ControlPlayableAsset::set_controllingParticles(bool value)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "set_controllingParticles",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<bool>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method, value);
}
 void UnityEngine::Timeline::ControlPlayableAsset::OnEnable()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "OnEnable",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method);
}
 double_t UnityEngine::Timeline::ControlPlayableAsset::get_duration()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "get_duration",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<double_t, false>(const_cast<void*>(instance), ___internal_method);
}
 UnityEngine::Timeline::ClipCaps UnityEngine::Timeline::ControlPlayableAsset::get_clipCaps()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "get_clipCaps",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<UnityEngine::Timeline::ClipCaps, false>(const_cast<void*>(instance), ___internal_method);
}
 UnityEngine::Playables::Playable UnityEngine::Timeline::ControlPlayableAsset::CreatePlayable(UnityEngine::Playables::PlayableGraph graph, UnityEngine::GameObject go)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "CreatePlayable",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::GameObject>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<UnityEngine::Playables::Playable, false>(const_cast<void*>(instance), ___internal_method, graph, go);
}
 UnityEngine::Playables::Playable UnityEngine::Timeline::ControlPlayableAsset::ConnectPlayablesToMixer(UnityEngine::Playables::PlayableGraph graph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable> playables)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "ConnectPlayablesToMixer",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<UnityEngine::Playables::Playable, false>(nullptr, ___internal_method, graph, playables);
}
 void UnityEngine::Timeline::ControlPlayableAsset::CreateActivationPlayable(UnityEngine::GameObject root, UnityEngine::Playables::PlayableGraph graph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable> outplayables)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "CreateActivationPlayable",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::GameObject>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method, root, graph, outplayables);
}
 void UnityEngine::Timeline::ControlPlayableAsset::SearchHierarchyAndConnectParticleSystem(System::Collections::Generic::IEnumerable_1<UnityEngine::ParticleSystem> particleSystems, UnityEngine::Playables::PlayableGraph graph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable> outplayables)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "SearchHierarchyAndConnectParticleSystem",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::ParticleSystem>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method, particleSystems, graph, outplayables);
}
 void UnityEngine::Timeline::ControlPlayableAsset::SearchHierarchyAndConnectDirector(System::Collections::Generic::IEnumerable_1<UnityEngine::Playables::PlayableDirector> directors, UnityEngine::Playables::PlayableGraph graph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable> outplayables, bool disableSelfReferences)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "SearchHierarchyAndConnectDirector",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::Playables::PlayableDirector>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<bool>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method, directors, graph, outplayables, disableSelfReferences);
}
 void UnityEngine::Timeline::ControlPlayableAsset::SearchHierarchyAndConnectControlableScripts(System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour> controlableScripts, UnityEngine::Playables::PlayableGraph graph, System::Collections::Generic::List_1<UnityEngine::Playables::Playable> outplayables)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "SearchHierarchyAndConnectControlableScripts",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::List_1<UnityEngine::Playables::Playable>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(nullptr, ___internal_method, controlableScripts, graph, outplayables);
}
 void UnityEngine::Timeline::ControlPlayableAsset::ConnectMixerAndPlayable(UnityEngine::Playables::PlayableGraph graph, UnityEngine::Playables::Playable mixer, UnityEngine::Playables::Playable playable, int32_t portIndex)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "ConnectMixerAndPlayable",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableGraph>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::Playable>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::Playable>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<int32_t>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(nullptr, ___internal_method, graph, mixer, playable, portIndex);
}
template<typename T>
 System::Collections::Generic::IList_1<T> UnityEngine::Timeline::ControlPlayableAsset::GetComponent(UnityEngine::GameObject gameObject)  {
static auto* ___internal_method_base = THROW_UNLESS((::il2cpp_utils::FindMethod(
                        ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                        "GetComponent",
                        std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()},
                        ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::GameObject>::get()}
                    )));
static auto* ___internal_method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(
                        ___internal_method_base,
                         std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}
                        ));
return ::cordl_internals::RunMethodRethrow<System::Collections::Generic::IList_1<T>, false>(const_cast<void*>(instance), ___internal_method, gameObject);
}
 System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour> UnityEngine::Timeline::ControlPlayableAsset::GetControlableScripts(UnityEngine::GameObject root)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "GetControlableScripts",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::GameObject>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>, false>(nullptr, ___internal_method, root);
}
 void UnityEngine::Timeline::ControlPlayableAsset::UpdateDurationAndLoopFlag(System::Collections::Generic::IList_1<UnityEngine::Playables::PlayableDirector> directors, System::Collections::Generic::IList_1<UnityEngine::ParticleSystem> particleSystems)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "UpdateDurationAndLoopFlag",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IList_1<UnityEngine::Playables::PlayableDirector>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IList_1<UnityEngine::ParticleSystem>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method, directors, particleSystems);
}
 System::Collections::Generic::IList_1<UnityEngine::ParticleSystem> UnityEngine::Timeline::ControlPlayableAsset::GetControllableParticleSystems(UnityEngine::GameObject go)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "GetControllableParticleSystems",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::GameObject>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<System::Collections::Generic::IList_1<UnityEngine::ParticleSystem>, false>(const_cast<void*>(instance), ___internal_method, go);
}
 void UnityEngine::Timeline::ControlPlayableAsset::GetControllableParticleSystems(UnityEngine::Transform t, System::Collections::Generic::ICollection_1<UnityEngine::ParticleSystem> roots, System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem> subEmitters)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "GetControllableParticleSystems",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Transform>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::ICollection_1<UnityEngine::ParticleSystem>>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(nullptr, ___internal_method, t, roots, subEmitters);
}
 void UnityEngine::Timeline::ControlPlayableAsset::CacheSubEmitters(UnityEngine::ParticleSystem ps, System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem> subEmitters)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "CacheSubEmitters",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::ParticleSystem>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::HashSet_1<UnityEngine::ParticleSystem>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(nullptr, ___internal_method, ps, subEmitters);
}
 void UnityEngine::Timeline::ControlPlayableAsset::GatherProperties(UnityEngine::Playables::PlayableDirector director, UnityEngine::Timeline::IPropertyCollector driver)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "GatherProperties",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableDirector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method, director, driver);
}
 void UnityEngine::Timeline::ControlPlayableAsset::PreviewParticles(UnityEngine::Timeline::IPropertyCollector driver, System::Collections::Generic::IEnumerable_1<UnityEngine::ParticleSystem> particles)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "PreviewParticles",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::ParticleSystem>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(nullptr, ___internal_method, driver, particles);
}
 void UnityEngine::Timeline::ControlPlayableAsset::PreviewActivation(UnityEngine::Timeline::IPropertyCollector driver, System::Collections::Generic::IEnumerable_1<UnityEngine::GameObject> objects)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "PreviewActivation",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::GameObject>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(nullptr, ___internal_method, driver, objects);
}
 void UnityEngine::Timeline::ControlPlayableAsset::PreviewTimeControl(UnityEngine::Timeline::IPropertyCollector driver, UnityEngine::Playables::PlayableDirector director, System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour> scripts)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "PreviewTimeControl",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Playables::PlayableDirector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::MonoBehaviour>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(nullptr, ___internal_method, driver, director, scripts);
}
 void UnityEngine::Timeline::ControlPlayableAsset::PreviewDirectors(UnityEngine::Timeline::IPropertyCollector driver, System::Collections::Generic::IEnumerable_1<UnityEngine::Playables::PlayableDirector> directors)  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            "PreviewDirectors",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<UnityEngine::Timeline::IPropertyCollector>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_type<System::Collections::Generic::IEnumerable_1<UnityEngine::Playables::PlayableDirector>>::get()}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(nullptr, ___internal_method, driver, directors);
}
// Ctor Parameters []
 UnityEngine::Timeline::ControlPlayableAsset::ControlPlayableAsset()  : UnityEngine::Playables::PlayableAsset(THROW_UNLESS(::il2cpp_utils::New<ControlPlayableAsset>())) {}
 void UnityEngine::Timeline::ControlPlayableAsset::_ctor()  {
static auto* ___internal_method = THROW_UNLESS((::il2cpp_utils::FindMethod(
                            ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<UnityEngine::Timeline::ControlPlayableAsset>::get(),
                            ".ctor",
                            std::vector<Il2CppClass*>{},
                            ::std::vector<const Il2CppType*>{}
                        )));
return ::cordl_internals::RunMethodRethrow<void, false>(const_cast<void*>(instance), ___internal_method);
}
