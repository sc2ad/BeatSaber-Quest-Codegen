// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.Playables.PlayableAsset
#include "UnityEngine/Playables/PlayableAsset.hpp"
// Including type: UnityEngine.Timeline.ITimelineClipAsset
#include "UnityEngine/Timeline/ITimelineClipAsset.hpp"
// Including type: UnityEngine.Timeline.IPropertyPreview
#include "UnityEngine/Timeline/IPropertyPreview.hpp"
// Including type: UnityEngine.ISerializationCallbackReceiver
#include "UnityEngine/ISerializationCallbackReceiver.hpp"
// Including type: System.Int32
#include "System/Int32.hpp"
// Including type: System.Enum
#include "System/Enum.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine::Timeline
namespace UnityEngine::Timeline {
  // Forward declaring type: MarkerTrack
  class MarkerTrack;
  // Forward declaring type: TrackAsset
  class TrackAsset;
  // Skipping declaration: DurationMode because it is already included!
  // Forward declaring type: ClipCaps
  struct ClipCaps;
  // Forward declaring type: IPropertyCollector
  class IPropertyCollector;
  // Forward declaring type: DiscreteTime
  struct DiscreteTime;
  // Forward declaring type: TimelineClip
  class TimelineClip;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: IEnumerable`1<T>
  template<typename T>
  class IEnumerable_1;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Skipping declaration: ScriptableObject because it is already included!
  // Forward declaring type: GameObject
  class GameObject;
}
// Forward declaring namespace: UnityEngine::Playables
namespace UnityEngine::Playables {
  // Forward declaring type: PlayableDirector
  class PlayableDirector;
  // Forward declaring type: Playable
  struct Playable;
  // Forward declaring type: PlayableGraph
  struct PlayableGraph;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Type
  class Type;
}
// Completed forward declares
// Type namespace: UnityEngine.Timeline
namespace UnityEngine::Timeline {
  // Forward declaring type: TimelineAsset
  class TimelineAsset;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::UnityEngine::Timeline::TimelineAsset);
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::Timeline::TimelineAsset*, "UnityEngine.Timeline", "TimelineAsset");
// Type namespace: UnityEngine.Timeline
namespace UnityEngine::Timeline {
  // Size: 0x60
  #pragma pack(push, 1)
  // Autogenerated type: UnityEngine.Timeline.TimelineAsset
  // [TokenAttribute] Offset: FFFFFFFF
  // [ExcludeFromPresetAttribute] Offset: FFFFFFFF
  class TimelineAsset : public ::UnityEngine::Playables::PlayableAsset/*, public ::UnityEngine::Timeline::ITimelineClipAsset, public ::UnityEngine::Timeline::IPropertyPreview, public ::UnityEngine::ISerializationCallbackReceiver*/ {
    public:
    // Nested type: ::UnityEngine::Timeline::TimelineAsset::Versions
    struct Versions;
    // Nested type: ::UnityEngine::Timeline::TimelineAsset::TimelineAssetUpgrade
    class TimelineAssetUpgrade;
    // Nested type: ::UnityEngine::Timeline::TimelineAsset::MediaType
    struct MediaType;
    // Nested type: ::UnityEngine::Timeline::TimelineAsset::DurationMode
    struct DurationMode;
    // Nested type: ::UnityEngine::Timeline::TimelineAsset::EditorSettings
    class EditorSettings;
    // Nested type: ::UnityEngine::Timeline::TimelineAsset::$get_outputs$d__27
    class $get_outputs$d__27;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode
    // [TokenAttribute] Offset: FFFFFFFF
    struct DurationMode/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: DurationMode
      constexpr DurationMode(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating interface conversion operator: i_Enum
      inline ::System::Enum* i_Enum() noexcept {
        return reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode BasedOnClips
      static constexpr const int BasedOnClips = 0;
      // Get static field: static public UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode BasedOnClips
      static ::UnityEngine::Timeline::TimelineAsset::DurationMode _get_BasedOnClips();
      // Set static field: static public UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode BasedOnClips
      static void _set_BasedOnClips(::UnityEngine::Timeline::TimelineAsset::DurationMode value);
      // static field const value: static public UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode FixedLength
      static constexpr const int FixedLength = 1;
      // Get static field: static public UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode FixedLength
      static ::UnityEngine::Timeline::TimelineAsset::DurationMode _get_FixedLength();
      // Set static field: static public UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode FixedLength
      static void _set_FixedLength(::UnityEngine::Timeline::TimelineAsset::DurationMode value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode
    #pragma pack(pop)
    static check_size<sizeof(TimelineAsset::DurationMode), 0 + sizeof(int)> __UnityEngine_Timeline_TimelineAsset_DurationModeSizeCheck;
    static_assert(sizeof(TimelineAsset::DurationMode) == 0x4);
    public:
    // private System.Int32 m_Version
    // Size: 0x4
    // Offset: 0x18
    int m_Version;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: m_Version and: m_Tracks
    char __padding0[0x4] = {};
    // private System.Collections.Generic.List`1<UnityEngine.ScriptableObject> m_Tracks
    // Size: 0x8
    // Offset: 0x20
    ::System::Collections::Generic::List_1<::UnityEngine::ScriptableObject*>* m_Tracks;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::ScriptableObject*>*) == 0x8);
    // private System.Double m_FixedDuration
    // Size: 0x8
    // Offset: 0x28
    double m_FixedDuration;
    // Field size check
    static_assert(sizeof(double) == 0x8);
    // private UnityEngine.Timeline.TrackAsset[] m_CacheOutputTracks
    // Size: 0x8
    // Offset: 0x30
    ::ArrayW<::UnityEngine::Timeline::TrackAsset*> m_CacheOutputTracks;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Timeline::TrackAsset*>) == 0x8);
    // private System.Collections.Generic.List`1<UnityEngine.Timeline.TrackAsset> m_CacheRootTracks
    // Size: 0x8
    // Offset: 0x38
    ::System::Collections::Generic::List_1<::UnityEngine::Timeline::TrackAsset*>* m_CacheRootTracks;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Timeline::TrackAsset*>*) == 0x8);
    // private System.Collections.Generic.List`1<UnityEngine.Timeline.TrackAsset> m_CacheFlattenedTracks
    // Size: 0x8
    // Offset: 0x40
    ::System::Collections::Generic::List_1<::UnityEngine::Timeline::TrackAsset*>* m_CacheFlattenedTracks;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Timeline::TrackAsset*>*) == 0x8);
    // private UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.EditorSettings m_EditorSettings
    // Size: 0x8
    // Offset: 0x48
    ::UnityEngine::Timeline::TimelineAsset::EditorSettings* m_EditorSettings;
    // Field size check
    static_assert(sizeof(::UnityEngine::Timeline::TimelineAsset::EditorSettings*) == 0x8);
    // private UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode m_DurationMode
    // Size: 0x4
    // Offset: 0x50
    ::UnityEngine::Timeline::TimelineAsset::DurationMode m_DurationMode;
    // Field size check
    static_assert(sizeof(::UnityEngine::Timeline::TimelineAsset::DurationMode) == 0x4);
    // Padding between fields: m_DurationMode and: m_MarkerTrack
    char __padding7[0x4] = {};
    // private UnityEngine.Timeline.MarkerTrack m_MarkerTrack
    // Size: 0x8
    // Offset: 0x58
    ::UnityEngine::Timeline::MarkerTrack* m_MarkerTrack;
    // Field size check
    static_assert(sizeof(::UnityEngine::Timeline::MarkerTrack*) == 0x8);
    public:
    // Creating interface conversion operator: operator ::UnityEngine::Timeline::ITimelineClipAsset
    operator ::UnityEngine::Timeline::ITimelineClipAsset() noexcept {
      return *reinterpret_cast<::UnityEngine::Timeline::ITimelineClipAsset*>(this);
    }
    // Creating interface conversion operator: i_ITimelineClipAsset
    inline ::UnityEngine::Timeline::ITimelineClipAsset* i_ITimelineClipAsset() noexcept {
      return reinterpret_cast<::UnityEngine::Timeline::ITimelineClipAsset*>(this);
    }
    // Creating interface conversion operator: operator ::UnityEngine::Timeline::IPropertyPreview
    operator ::UnityEngine::Timeline::IPropertyPreview() noexcept {
      return *reinterpret_cast<::UnityEngine::Timeline::IPropertyPreview*>(this);
    }
    // Creating interface conversion operator: i_IPropertyPreview
    inline ::UnityEngine::Timeline::IPropertyPreview* i_IPropertyPreview() noexcept {
      return reinterpret_cast<::UnityEngine::Timeline::IPropertyPreview*>(this);
    }
    // Creating interface conversion operator: operator ::UnityEngine::ISerializationCallbackReceiver
    operator ::UnityEngine::ISerializationCallbackReceiver() noexcept {
      return *reinterpret_cast<::UnityEngine::ISerializationCallbackReceiver*>(this);
    }
    // Creating interface conversion operator: i_ISerializationCallbackReceiver
    inline ::UnityEngine::ISerializationCallbackReceiver* i_ISerializationCallbackReceiver() noexcept {
      return reinterpret_cast<::UnityEngine::ISerializationCallbackReceiver*>(this);
    }
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // static field const value: static private System.Int32 k_LatestVersion
    static constexpr const int k_LatestVersion = 0;
    // Get static field: static private System.Int32 k_LatestVersion
    static int _get_k_LatestVersion();
    // Set static field: static private System.Int32 k_LatestVersion
    static void _set_k_LatestVersion(int value);
    // Get instance field reference: private System.Int32 m_Version
    [[deprecated("Use field access instead!")]] int& dyn_m_Version();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.ScriptableObject> m_Tracks
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::ScriptableObject*>*& dyn_m_Tracks();
    // Get instance field reference: private System.Double m_FixedDuration
    [[deprecated("Use field access instead!")]] double& dyn_m_FixedDuration();
    // Get instance field reference: private UnityEngine.Timeline.TrackAsset[] m_CacheOutputTracks
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Timeline::TrackAsset*>& dyn_m_CacheOutputTracks();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.Timeline.TrackAsset> m_CacheRootTracks
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::Timeline::TrackAsset*>*& dyn_m_CacheRootTracks();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.Timeline.TrackAsset> m_CacheFlattenedTracks
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::Timeline::TrackAsset*>*& dyn_m_CacheFlattenedTracks();
    // Get instance field reference: private UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.EditorSettings m_EditorSettings
    [[deprecated("Use field access instead!")]] ::UnityEngine::Timeline::TimelineAsset::EditorSettings*& dyn_m_EditorSettings();
    // Get instance field reference: private UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode m_DurationMode
    [[deprecated("Use field access instead!")]] ::UnityEngine::Timeline::TimelineAsset::DurationMode& dyn_m_DurationMode();
    // Get instance field reference: private UnityEngine.Timeline.MarkerTrack m_MarkerTrack
    [[deprecated("Use field access instead!")]] ::UnityEngine::Timeline::MarkerTrack*& dyn_m_MarkerTrack();
    // public UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.EditorSettings get_editorSettings()
    // Offset: 0x1DC338C
    ::UnityEngine::Timeline::TimelineAsset::EditorSettings* get_editorSettings();
    // public System.Double get_fixedDuration()
    // Offset: 0x1DC37C8
    double get_fixedDuration();
    // public System.Void set_fixedDuration(System.Double value)
    // Offset: 0x1DC3898
    void set_fixedDuration(double value);
    // public UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode get_durationMode()
    // Offset: 0x1DC3918
    ::UnityEngine::Timeline::TimelineAsset::DurationMode get_durationMode();
    // public System.Void set_durationMode(UnityEngine.Timeline.TimelineAsset/UnityEngine.Timeline.DurationMode value)
    // Offset: 0x1DC3920
    void set_durationMode(::UnityEngine::Timeline::TimelineAsset::DurationMode value);
    // public UnityEngine.Timeline.ClipCaps get_clipCaps()
    // Offset: 0x1DC3998
    ::UnityEngine::Timeline::ClipCaps get_clipCaps();
    // public System.Int32 get_outputTrackCount()
    // Offset: 0x1DC3CA4
    int get_outputTrackCount();
    // public System.Int32 get_rootTrackCount()
    // Offset: 0x1DC4088
    int get_rootTrackCount();
    // System.Collections.Generic.IEnumerable`1<UnityEngine.Timeline.TrackAsset> get_flattenedTracks()
    // Offset: 0x1DC4504
    ::System::Collections::Generic::IEnumerable_1<::UnityEngine::Timeline::TrackAsset*>* get_flattenedTracks();
    // public UnityEngine.Timeline.MarkerTrack get_markerTrack()
    // Offset: 0x1DC48D0
    ::UnityEngine::Timeline::MarkerTrack* get_markerTrack();
    // System.Collections.Generic.List`1<UnityEngine.ScriptableObject> get_trackObjects()
    // Offset: 0x1DC48D8
    ::System::Collections::Generic::List_1<::UnityEngine::ScriptableObject*>* get_trackObjects();
    // public System.Void .ctor()
    // Offset: 0x1DC5FAC
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static TimelineAsset* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::Timeline::TimelineAsset::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<TimelineAsset*, creationType>()));
    }
    // private System.Void UpgradeToLatestVersion()
    // Offset: 0x1DC3388
    void UpgradeToLatestVersion();
    // private System.Void OnValidate()
    // Offset: 0x1DC432C
    void OnValidate();
    // static System.Single GetValidFramerate(System.Single framerate)
    // Offset: 0x1DC4360
    static float GetValidFramerate(float framerate);
    // public UnityEngine.Timeline.TrackAsset GetRootTrack(System.Int32 index)
    // Offset: 0x1DC4410
    ::UnityEngine::Timeline::TrackAsset* GetRootTrack(int index);
    // public System.Collections.Generic.IEnumerable`1<UnityEngine.Timeline.TrackAsset> GetRootTracks()
    // Offset: 0x1DC3C80
    ::System::Collections::Generic::IEnumerable_1<::UnityEngine::Timeline::TrackAsset*>* GetRootTracks();
    // public UnityEngine.Timeline.TrackAsset GetOutputTrack(System.Int32 index)
    // Offset: 0x1DC4490
    ::UnityEngine::Timeline::TrackAsset* GetOutputTrack(int index);
    // public System.Collections.Generic.IEnumerable`1<UnityEngine.Timeline.TrackAsset> GetOutputTracks()
    // Offset: 0x1DC44E0
    ::System::Collections::Generic::IEnumerable_1<::UnityEngine::Timeline::TrackAsset*>* GetOutputTracks();
    // private System.Void UpdateRootTrackCache()
    // Offset: 0x1DC40E0
    void UpdateRootTrackCache();
    // private System.Void UpdateOutputTrackCache()
    // Offset: 0x1DC3CD4
    void UpdateOutputTrackCache();
    // System.Void AddTrackInternal(UnityEngine.Timeline.TrackAsset track)
    // Offset: 0x1DC48E0
    void AddTrackInternal(::UnityEngine::Timeline::TrackAsset* track);
    // System.Void RemoveTrack(UnityEngine.Timeline.TrackAsset track)
    // Offset: 0x1DC4968
    void RemoveTrack(::UnityEngine::Timeline::TrackAsset* track);
    // private System.Void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
    // Offset: 0x1DC4BD8
    void UnityEngine_ISerializationCallbackReceiver_OnBeforeSerialize();
    // private System.Void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
    // Offset: 0x1DC4BE0
    void UnityEngine_ISerializationCallbackReceiver_OnAfterDeserialize();
    // private System.Void __internalAwake()
    // Offset: 0x1DC4BEC
    void __internalAwake();
    // public System.Void GatherProperties(UnityEngine.Playables.PlayableDirector director, UnityEngine.Timeline.IPropertyCollector driver)
    // Offset: 0x1DBA298
    void GatherProperties(::UnityEngine::Playables::PlayableDirector* director, ::UnityEngine::Timeline::IPropertyCollector* driver);
    // public System.Void CreateMarkerTrack()
    // Offset: 0x1DC4D34
    void CreateMarkerTrack();
    // System.Void Invalidate()
    // Offset: 0x1DC495C
    void Invalidate();
    // System.Void UpdateFixedDurationWithItemsDuration()
    // Offset: 0x1DC4E00
    void UpdateFixedDurationWithItemsDuration();
    // private UnityEngine.Timeline.DiscreteTime CalculateItemsDuration()
    // Offset: 0x1DC346C
    ::UnityEngine::Timeline::DiscreteTime CalculateItemsDuration();
    // static private System.Void AddSubTracksRecursive(UnityEngine.Timeline.TrackAsset track, ref System.Collections.Generic.List`1<UnityEngine.Timeline.TrackAsset> allTracks)
    // Offset: 0x1DC4608
    static void AddSubTracksRecursive(::UnityEngine::Timeline::TrackAsset* track, ByRef<::System::Collections::Generic::List_1<::UnityEngine::Timeline::TrackAsset*>*> allTracks);
    // public UnityEngine.Timeline.TrackAsset CreateTrack(System.Type type, UnityEngine.Timeline.TrackAsset parent, System.String name)
    // Offset: 0x1DC4E7C
    ::UnityEngine::Timeline::TrackAsset* CreateTrack(::System::Type* type, ::UnityEngine::Timeline::TrackAsset* parent, ::StringW name);
    // public T CreateTrack(UnityEngine.Timeline.TrackAsset parent, System.String trackName)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T CreateTrack(::UnityEngine::Timeline::TrackAsset* parent, ::StringW trackName) {
      static_assert(std::is_convertible_v<T, ::UnityEngine::Timeline::TrackAsset*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::Timeline::TimelineAsset::CreateTrack");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "CreateTrack", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(parent), ::il2cpp_utils::ExtractType(trackName)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, parent, trackName);
    }
    // public T CreateTrack(System.String trackName)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T CreateTrack(::StringW trackName) {
      static_assert(std::is_convertible_v<T, ::UnityEngine::Timeline::TrackAsset*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::Timeline::TimelineAsset::CreateTrack");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "CreateTrack", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(trackName)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method, trackName);
    }
    // public T CreateTrack()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T CreateTrack() {
      static_assert(std::is_convertible_v<T, ::UnityEngine::Timeline::TrackAsset*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::Timeline::TimelineAsset::CreateTrack");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "CreateTrack", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method);
    }
    // public System.Boolean DeleteClip(UnityEngine.Timeline.TimelineClip clip)
    // Offset: 0x1DC5440
    bool DeleteClip(::UnityEngine::Timeline::TimelineClip* clip);
    // public System.Boolean DeleteTrack(UnityEngine.Timeline.TrackAsset track)
    // Offset: 0x1DC5790
    bool DeleteTrack(::UnityEngine::Timeline::TrackAsset* track);
    // System.Void MoveLastTrackBefore(UnityEngine.Timeline.TrackAsset asset)
    // Offset: 0x1DC5D94
    void MoveLastTrackBefore(::UnityEngine::Timeline::TrackAsset* asset);
    // UnityEngine.Timeline.TrackAsset AllocateTrack(UnityEngine.Timeline.TrackAsset trackAssetParent, System.String trackName, System.Type trackType)
    // Offset: 0x1DC5208
    ::UnityEngine::Timeline::TrackAsset* AllocateTrack(::UnityEngine::Timeline::TrackAsset* trackAssetParent, ::StringW trackName, ::System::Type* trackType);
    // private System.Void DeleteRecordedAnimation(UnityEngine.Timeline.TrackAsset track)
    // Offset: 0x1DC5C28
    void DeleteRecordedAnimation(::UnityEngine::Timeline::TrackAsset* track);
    // private System.Void DeleteRecordedAnimation(UnityEngine.Timeline.TimelineClip clip)
    // Offset: 0x1DC5624
    void DeleteRecordedAnimation(::UnityEngine::Timeline::TimelineClip* clip);
    // public override System.Double get_duration()
    // Offset: 0x1DC3394
    // Implemented from: UnityEngine.Playables.PlayableAsset
    // Base method: System.Double PlayableAsset::get_duration()
    double get_duration();
    // public override System.Collections.Generic.IEnumerable`1<UnityEngine.Playables.PlayableBinding> get_outputs()
    // Offset: 0x1DC3928
    // Implemented from: UnityEngine.Playables.PlayableAsset
    // Base method: System.Collections.Generic.IEnumerable`1<UnityEngine.Playables.PlayableBinding> PlayableAsset::get_outputs()
    ::System::Collections::Generic::IEnumerable_1<::UnityEngine::Playables::PlayableBinding>* get_outputs();
    // public override UnityEngine.Playables.Playable CreatePlayable(UnityEngine.Playables.PlayableGraph graph, UnityEngine.GameObject go)
    // Offset: 0x1DC4A78
    // Implemented from: UnityEngine.Playables.PlayableAsset
    // Base method: UnityEngine.Playables.Playable PlayableAsset::CreatePlayable(UnityEngine.Playables.PlayableGraph graph, UnityEngine.GameObject go)
    ::UnityEngine::Playables::Playable CreatePlayable(::UnityEngine::Playables::PlayableGraph graph, ::UnityEngine::GameObject* go);
  }; // UnityEngine.Timeline.TimelineAsset
  #pragma pack(pop)
  static check_size<sizeof(TimelineAsset), 88 + sizeof(::UnityEngine::Timeline::MarkerTrack*)> __UnityEngine_Timeline_TimelineAssetSizeCheck;
  static_assert(sizeof(TimelineAsset) == 0x60);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::Timeline::TimelineAsset::DurationMode, "UnityEngine.Timeline", "TimelineAsset/DurationMode");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_editorSettings
// Il2CppName: get_editorSettings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::TimelineAsset::EditorSettings* (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_editorSettings)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_editorSettings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_fixedDuration
// Il2CppName: get_fixedDuration
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<double (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_fixedDuration)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_fixedDuration", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::set_fixedDuration
// Il2CppName: set_fixedDuration
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)(double)>(&UnityEngine::Timeline::TimelineAsset::set_fixedDuration)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Double")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "set_fixedDuration", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_durationMode
// Il2CppName: get_durationMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::TimelineAsset::DurationMode (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_durationMode)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_durationMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::set_durationMode
// Il2CppName: set_durationMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Timeline::TimelineAsset::DurationMode)>(&UnityEngine::Timeline::TimelineAsset::set_durationMode)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TimelineAsset/DurationMode")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "set_durationMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_clipCaps
// Il2CppName: get_clipCaps
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::ClipCaps (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_clipCaps)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_clipCaps", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_outputTrackCount
// Il2CppName: get_outputTrackCount
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_outputTrackCount)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_outputTrackCount", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_rootTrackCount
// Il2CppName: get_rootTrackCount
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_rootTrackCount)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_rootTrackCount", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_flattenedTracks
// Il2CppName: get_flattenedTracks
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerable_1<::UnityEngine::Timeline::TrackAsset*>* (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_flattenedTracks)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_flattenedTracks", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_markerTrack
// Il2CppName: get_markerTrack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::MarkerTrack* (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_markerTrack)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_markerTrack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_trackObjects
// Il2CppName: get_trackObjects
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::List_1<::UnityEngine::ScriptableObject*>* (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_trackObjects)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_trackObjects", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::UpgradeToLatestVersion
// Il2CppName: UpgradeToLatestVersion
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::UpgradeToLatestVersion)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "UpgradeToLatestVersion", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::OnValidate
// Il2CppName: OnValidate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::OnValidate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "OnValidate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::GetValidFramerate
// Il2CppName: GetValidFramerate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (*)(float)>(&UnityEngine::Timeline::TimelineAsset::GetValidFramerate)> {
  static const MethodInfo* get() {
    static auto* framerate = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "GetValidFramerate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{framerate});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::GetRootTrack
// Il2CppName: GetRootTrack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::TrackAsset* (UnityEngine::Timeline::TimelineAsset::*)(int)>(&UnityEngine::Timeline::TimelineAsset::GetRootTrack)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "GetRootTrack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::GetRootTracks
// Il2CppName: GetRootTracks
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerable_1<::UnityEngine::Timeline::TrackAsset*>* (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::GetRootTracks)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "GetRootTracks", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::GetOutputTrack
// Il2CppName: GetOutputTrack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::TrackAsset* (UnityEngine::Timeline::TimelineAsset::*)(int)>(&UnityEngine::Timeline::TimelineAsset::GetOutputTrack)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "GetOutputTrack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::GetOutputTracks
// Il2CppName: GetOutputTracks
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerable_1<::UnityEngine::Timeline::TrackAsset*>* (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::GetOutputTracks)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "GetOutputTracks", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::UpdateRootTrackCache
// Il2CppName: UpdateRootTrackCache
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::UpdateRootTrackCache)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "UpdateRootTrackCache", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::UpdateOutputTrackCache
// Il2CppName: UpdateOutputTrackCache
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::UpdateOutputTrackCache)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "UpdateOutputTrackCache", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::AddTrackInternal
// Il2CppName: AddTrackInternal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Timeline::TrackAsset*)>(&UnityEngine::Timeline::TimelineAsset::AddTrackInternal)> {
  static const MethodInfo* get() {
    static auto* track = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "AddTrackInternal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{track});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::RemoveTrack
// Il2CppName: RemoveTrack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Timeline::TrackAsset*)>(&UnityEngine::Timeline::TimelineAsset::RemoveTrack)> {
  static const MethodInfo* get() {
    static auto* track = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "RemoveTrack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{track});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::UnityEngine_ISerializationCallbackReceiver_OnBeforeSerialize
// Il2CppName: UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::UnityEngine_ISerializationCallbackReceiver_OnBeforeSerialize)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::UnityEngine_ISerializationCallbackReceiver_OnAfterDeserialize
// Il2CppName: UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::UnityEngine_ISerializationCallbackReceiver_OnAfterDeserialize)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::__internalAwake
// Il2CppName: __internalAwake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::__internalAwake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "__internalAwake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::GatherProperties
// Il2CppName: GatherProperties
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Playables::PlayableDirector*, ::UnityEngine::Timeline::IPropertyCollector*)>(&UnityEngine::Timeline::TimelineAsset::GatherProperties)> {
  static const MethodInfo* get() {
    static auto* director = &::il2cpp_utils::GetClassFromName("UnityEngine.Playables", "PlayableDirector")->byval_arg;
    static auto* driver = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "IPropertyCollector")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "GatherProperties", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{director, driver});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::CreateMarkerTrack
// Il2CppName: CreateMarkerTrack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::CreateMarkerTrack)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "CreateMarkerTrack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::Invalidate
// Il2CppName: Invalidate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::Invalidate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "Invalidate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::UpdateFixedDurationWithItemsDuration
// Il2CppName: UpdateFixedDurationWithItemsDuration
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::UpdateFixedDurationWithItemsDuration)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "UpdateFixedDurationWithItemsDuration", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::CalculateItemsDuration
// Il2CppName: CalculateItemsDuration
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::DiscreteTime (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::CalculateItemsDuration)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "CalculateItemsDuration", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::AddSubTracksRecursive
// Il2CppName: AddSubTracksRecursive
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::UnityEngine::Timeline::TrackAsset*, ByRef<::System::Collections::Generic::List_1<::UnityEngine::Timeline::TrackAsset*>*>)>(&UnityEngine::Timeline::TimelineAsset::AddSubTracksRecursive)> {
  static const MethodInfo* get() {
    static auto* track = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")->byval_arg;
    static auto* allTracks = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")})->this_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "AddSubTracksRecursive", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{track, allTracks});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::CreateTrack
// Il2CppName: CreateTrack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::TrackAsset* (UnityEngine::Timeline::TimelineAsset::*)(::System::Type*, ::UnityEngine::Timeline::TrackAsset*, ::StringW)>(&UnityEngine::Timeline::TimelineAsset::CreateTrack)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* parent = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")->byval_arg;
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "CreateTrack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, parent, name});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::CreateTrack
// Il2CppName: CreateTrack
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::CreateTrack
// Il2CppName: CreateTrack
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::CreateTrack
// Il2CppName: CreateTrack
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::DeleteClip
// Il2CppName: DeleteClip
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Timeline::TimelineClip*)>(&UnityEngine::Timeline::TimelineAsset::DeleteClip)> {
  static const MethodInfo* get() {
    static auto* clip = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TimelineClip")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "DeleteClip", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{clip});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::DeleteTrack
// Il2CppName: DeleteTrack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Timeline::TrackAsset*)>(&UnityEngine::Timeline::TimelineAsset::DeleteTrack)> {
  static const MethodInfo* get() {
    static auto* track = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "DeleteTrack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{track});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::MoveLastTrackBefore
// Il2CppName: MoveLastTrackBefore
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Timeline::TrackAsset*)>(&UnityEngine::Timeline::TimelineAsset::MoveLastTrackBefore)> {
  static const MethodInfo* get() {
    static auto* asset = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "MoveLastTrackBefore", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{asset});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::AllocateTrack
// Il2CppName: AllocateTrack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Timeline::TrackAsset* (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Timeline::TrackAsset*, ::StringW, ::System::Type*)>(&UnityEngine::Timeline::TimelineAsset::AllocateTrack)> {
  static const MethodInfo* get() {
    static auto* trackAssetParent = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")->byval_arg;
    static auto* trackName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* trackType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "AllocateTrack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{trackAssetParent, trackName, trackType});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::DeleteRecordedAnimation
// Il2CppName: DeleteRecordedAnimation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Timeline::TrackAsset*)>(&UnityEngine::Timeline::TimelineAsset::DeleteRecordedAnimation)> {
  static const MethodInfo* get() {
    static auto* track = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TrackAsset")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "DeleteRecordedAnimation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{track});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::DeleteRecordedAnimation
// Il2CppName: DeleteRecordedAnimation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Timeline::TimelineClip*)>(&UnityEngine::Timeline::TimelineAsset::DeleteRecordedAnimation)> {
  static const MethodInfo* get() {
    static auto* clip = &::il2cpp_utils::GetClassFromName("UnityEngine.Timeline", "TimelineClip")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "DeleteRecordedAnimation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{clip});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_duration
// Il2CppName: get_duration
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<double (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_duration)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_duration", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::get_outputs
// Il2CppName: get_outputs
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::IEnumerable_1<::UnityEngine::Playables::PlayableBinding>* (UnityEngine::Timeline::TimelineAsset::*)()>(&UnityEngine::Timeline::TimelineAsset::get_outputs)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "get_outputs", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::Timeline::TimelineAsset::CreatePlayable
// Il2CppName: CreatePlayable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Playables::Playable (UnityEngine::Timeline::TimelineAsset::*)(::UnityEngine::Playables::PlayableGraph, ::UnityEngine::GameObject*)>(&UnityEngine::Timeline::TimelineAsset::CreatePlayable)> {
  static const MethodInfo* get() {
    static auto* graph = &::il2cpp_utils::GetClassFromName("UnityEngine.Playables", "PlayableGraph")->byval_arg;
    static auto* go = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::Timeline::TimelineAsset*), "CreatePlayable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{graph, go});
  }
};
