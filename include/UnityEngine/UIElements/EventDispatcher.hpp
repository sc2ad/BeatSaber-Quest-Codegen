// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine::UIElements
namespace UnityEngine::UIElements {
  // Forward declaring type: PointerDispatchState
  class PointerDispatchState;
  // Forward declaring type: ObjectPool`1<T>
  template<typename T>
  class ObjectPool_1;
  // Forward declaring type: IEventDispatchingStrategy
  class IEventDispatchingStrategy;
  // Forward declaring type: EventBase
  class EventBase;
  // Forward declaring type: IPanel
  class IPanel;
  // Forward declaring type: DispatchMode
  struct DispatchMode;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Queue`1<T>
  template<typename T>
  class Queue_1;
  // Forward declaring type: Stack`1<T>
  template<typename T>
  class Stack_1;
}
// Completed forward declares
// Type namespace: UnityEngine.UIElements
namespace UnityEngine::UIElements {
  // Forward declaring type: EventDispatcher
  class EventDispatcher;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::UnityEngine::UIElements::EventDispatcher);
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::UIElements::EventDispatcher*, "UnityEngine.UIElements", "EventDispatcher");
// Type namespace: UnityEngine.UIElements
namespace UnityEngine::UIElements {
  // Size: 0x39
  #pragma pack(push, 1)
  // Autogenerated type: UnityEngine.UIElements.EventDispatcher
  // [TokenAttribute] Offset: FFFFFFFF
  class EventDispatcher : public ::Il2CppObject {
    public:
    // Nested type: ::UnityEngine::UIElements::EventDispatcher::EventRecord
    struct EventRecord;
    // Nested type: ::UnityEngine::UIElements::EventDispatcher::DispatchContext
    struct DispatchContext;
    // Size: 0x10
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.EventRecord
    // [TokenAttribute] Offset: FFFFFFFF
    struct EventRecord/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.UIElements.EventBase m_Event
      // Size: 0x8
      // Offset: 0x0
      ::UnityEngine::UIElements::EventBase* m_Event;
      // Field size check
      static_assert(sizeof(::UnityEngine::UIElements::EventBase*) == 0x8);
      // public UnityEngine.UIElements.IPanel m_Panel
      // Size: 0x8
      // Offset: 0x8
      ::UnityEngine::UIElements::IPanel* m_Panel;
      // Field size check
      static_assert(sizeof(::UnityEngine::UIElements::IPanel*) == 0x8);
      public:
      // Creating value type constructor for type: EventRecord
      constexpr EventRecord(::UnityEngine::UIElements::EventBase* m_Event_ = {}, ::UnityEngine::UIElements::IPanel* m_Panel_ = {}) noexcept : m_Event{m_Event_}, m_Panel{m_Panel_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.UIElements.EventBase m_Event
      [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::EventBase*& dyn_m_Event();
      // Get instance field reference: public UnityEngine.UIElements.IPanel m_Panel
      [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::IPanel*& dyn_m_Panel();
    }; // UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.EventRecord
    #pragma pack(pop)
    static check_size<sizeof(EventDispatcher::EventRecord), 8 + sizeof(::UnityEngine::UIElements::IPanel*)> __UnityEngine_UIElements_EventDispatcher_EventRecordSizeCheck;
    static_assert(sizeof(EventDispatcher::EventRecord) == 0x10);
    // Size: 0x10
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.DispatchContext
    // [TokenAttribute] Offset: FFFFFFFF
    struct DispatchContext/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.UInt32 m_GateCount
      // Size: 0x4
      // Offset: 0x0
      uint m_GateCount;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // Padding between fields: m_GateCount and: m_Queue
      char __padding0[0x4] = {};
      // public System.Collections.Generic.Queue`1<UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.EventRecord> m_Queue
      // Size: 0x8
      // Offset: 0x8
      ::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>* m_Queue;
      // Field size check
      static_assert(sizeof(::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>*) == 0x8);
      public:
      // Creating value type constructor for type: DispatchContext
      constexpr DispatchContext(uint m_GateCount_ = {}, ::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>* m_Queue_ = {}) noexcept : m_GateCount{m_GateCount_}, m_Queue{m_Queue_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.UInt32 m_GateCount
      [[deprecated("Use field access instead!")]] uint& dyn_m_GateCount();
      // Get instance field reference: public System.Collections.Generic.Queue`1<UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.EventRecord> m_Queue
      [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>*& dyn_m_Queue();
    }; // UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.DispatchContext
    #pragma pack(pop)
    static check_size<sizeof(EventDispatcher::DispatchContext), 8 + sizeof(::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>*)> __UnityEngine_UIElements_EventDispatcher_DispatchContextSizeCheck;
    static_assert(sizeof(EventDispatcher::DispatchContext) == 0x10);
    public:
    // private System.Collections.Generic.List`1<UnityEngine.UIElements.IEventDispatchingStrategy> m_DispatchingStrategies
    // Size: 0x8
    // Offset: 0x10
    ::System::Collections::Generic::List_1<::UnityEngine::UIElements::IEventDispatchingStrategy*>* m_DispatchingStrategies;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::UIElements::IEventDispatchingStrategy*>*) == 0x8);
    // private System.Collections.Generic.Queue`1<UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.EventRecord> m_Queue
    // Size: 0x8
    // Offset: 0x18
    ::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>* m_Queue;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>*) == 0x8);
    // [DebuggerBrowsableAttribute] Offset: 0x9401F4
    // private readonly UnityEngine.UIElements.PointerDispatchState <pointerState>k__BackingField
    // Size: 0x8
    // Offset: 0x20
    ::UnityEngine::UIElements::PointerDispatchState* pointerState;
    // Field size check
    static_assert(sizeof(::UnityEngine::UIElements::PointerDispatchState*) == 0x8);
    // private System.UInt32 m_GateCount
    // Size: 0x4
    // Offset: 0x28
    uint m_GateCount;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // Padding between fields: m_GateCount and: m_DispatchContexts
    char __padding3[0x4] = {};
    // private System.Collections.Generic.Stack`1<UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.DispatchContext> m_DispatchContexts
    // Size: 0x8
    // Offset: 0x30
    ::System::Collections::Generic::Stack_1<::UnityEngine::UIElements::EventDispatcher::DispatchContext>* m_DispatchContexts;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Stack_1<::UnityEngine::UIElements::EventDispatcher::DispatchContext>*) == 0x8);
    // private System.Boolean m_Immediate
    // Size: 0x1
    // Offset: 0x38
    bool m_Immediate;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Get static field: static private readonly UnityEngine.UIElements.ObjectPool`1<System.Collections.Generic.Queue`1<UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.EventRecord>> k_EventQueuePool
    static ::UnityEngine::UIElements::ObjectPool_1<::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>*>* _get_k_EventQueuePool();
    // Set static field: static private readonly UnityEngine.UIElements.ObjectPool`1<System.Collections.Generic.Queue`1<UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.EventRecord>> k_EventQueuePool
    static void _set_k_EventQueuePool(::UnityEngine::UIElements::ObjectPool_1<::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>*>* value);
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.UIElements.IEventDispatchingStrategy> m_DispatchingStrategies
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::UIElements::IEventDispatchingStrategy*>*& dyn_m_DispatchingStrategies();
    // Get instance field reference: private System.Collections.Generic.Queue`1<UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.EventRecord> m_Queue
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Queue_1<::UnityEngine::UIElements::EventDispatcher::EventRecord>*& dyn_m_Queue();
    // Get instance field reference: private readonly UnityEngine.UIElements.PointerDispatchState <pointerState>k__BackingField
    [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::PointerDispatchState*& dyn_$pointerState$k__BackingField();
    // Get instance field reference: private System.UInt32 m_GateCount
    [[deprecated("Use field access instead!")]] uint& dyn_m_GateCount();
    // Get instance field reference: private System.Collections.Generic.Stack`1<UnityEngine.UIElements.EventDispatcher/UnityEngine.UIElements.DispatchContext> m_DispatchContexts
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Stack_1<::UnityEngine::UIElements::EventDispatcher::DispatchContext>*& dyn_m_DispatchContexts();
    // Get instance field reference: private System.Boolean m_Immediate
    [[deprecated("Use field access instead!")]] bool& dyn_m_Immediate();
    // UnityEngine.UIElements.PointerDispatchState get_pointerState()
    // Offset: 0xDA1770
    ::UnityEngine::UIElements::PointerDispatchState* get_pointerState();
    // private System.Boolean get_dispatchImmediately()
    // Offset: 0xDA1B28
    bool get_dispatchImmediately();
    // System.Void .ctor()
    // Offset: 0xDA1778
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static EventDispatcher* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::EventDispatcher::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<EventDispatcher*, creationType>()));
    }
    // static private System.Void .cctor()
    // Offset: 0xDA256C
    static void _cctor();
    // System.Void Dispatch(UnityEngine.UIElements.EventBase evt, UnityEngine.UIElements.IPanel panel, UnityEngine.UIElements.DispatchMode dispatchMode)
    // Offset: 0xD9C584
    void Dispatch(::UnityEngine::UIElements::EventBase* evt, ::UnityEngine::UIElements::IPanel* panel, ::UnityEngine::UIElements::DispatchMode dispatchMode);
    // System.Void CloseGate()
    // Offset: 0xDA1E78
    void CloseGate();
    // System.Void OpenGate()
    // Offset: 0xDA1E88
    void OpenGate();
    // private System.Void ProcessEventQueue()
    // Offset: 0xDA1F20
    void ProcessEventQueue();
    // private System.Void ProcessEvent(UnityEngine.UIElements.EventBase evt, UnityEngine.UIElements.IPanel panel)
    // Offset: 0xDA1B48
    void ProcessEvent(::UnityEngine::UIElements::EventBase* evt, ::UnityEngine::UIElements::IPanel* panel);
    // private System.Void ApplyDispatchingStrategies(UnityEngine.UIElements.EventBase evt, UnityEngine.UIElements.IPanel panel, System.Boolean imguiEventIsInitiallyUsed)
    // Offset: 0xDA22C4
    void ApplyDispatchingStrategies(::UnityEngine::UIElements::EventBase* evt, ::UnityEngine::UIElements::IPanel* panel, bool imguiEventIsInitiallyUsed);
  }; // UnityEngine.UIElements.EventDispatcher
  #pragma pack(pop)
  static check_size<sizeof(EventDispatcher), 56 + sizeof(bool)> __UnityEngine_UIElements_EventDispatcherSizeCheck;
  static_assert(sizeof(EventDispatcher) == 0x39);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::UIElements::EventDispatcher::DispatchContext, "UnityEngine.UIElements", "EventDispatcher/DispatchContext");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::UIElements::EventDispatcher::EventRecord, "UnityEngine.UIElements", "EventDispatcher/EventRecord");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::get_pointerState
// Il2CppName: get_pointerState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::UIElements::PointerDispatchState* (UnityEngine::UIElements::EventDispatcher::*)()>(&UnityEngine::UIElements::EventDispatcher::get_pointerState)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::EventDispatcher*), "get_pointerState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::get_dispatchImmediately
// Il2CppName: get_dispatchImmediately
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::UIElements::EventDispatcher::*)()>(&UnityEngine::UIElements::EventDispatcher::get_dispatchImmediately)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::EventDispatcher*), "get_dispatchImmediately", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::UIElements::EventDispatcher::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::EventDispatcher*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::Dispatch
// Il2CppName: Dispatch
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::EventDispatcher::*)(::UnityEngine::UIElements::EventBase*, ::UnityEngine::UIElements::IPanel*, ::UnityEngine::UIElements::DispatchMode)>(&UnityEngine::UIElements::EventDispatcher::Dispatch)> {
  static const MethodInfo* get() {
    static auto* evt = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "EventBase")->byval_arg;
    static auto* panel = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "IPanel")->byval_arg;
    static auto* dispatchMode = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "DispatchMode")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::EventDispatcher*), "Dispatch", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{evt, panel, dispatchMode});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::CloseGate
// Il2CppName: CloseGate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::EventDispatcher::*)()>(&UnityEngine::UIElements::EventDispatcher::CloseGate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::EventDispatcher*), "CloseGate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::OpenGate
// Il2CppName: OpenGate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::EventDispatcher::*)()>(&UnityEngine::UIElements::EventDispatcher::OpenGate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::EventDispatcher*), "OpenGate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::ProcessEventQueue
// Il2CppName: ProcessEventQueue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::EventDispatcher::*)()>(&UnityEngine::UIElements::EventDispatcher::ProcessEventQueue)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::EventDispatcher*), "ProcessEventQueue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::ProcessEvent
// Il2CppName: ProcessEvent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::EventDispatcher::*)(::UnityEngine::UIElements::EventBase*, ::UnityEngine::UIElements::IPanel*)>(&UnityEngine::UIElements::EventDispatcher::ProcessEvent)> {
  static const MethodInfo* get() {
    static auto* evt = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "EventBase")->byval_arg;
    static auto* panel = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "IPanel")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::EventDispatcher*), "ProcessEvent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{evt, panel});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::EventDispatcher::ApplyDispatchingStrategies
// Il2CppName: ApplyDispatchingStrategies
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::EventDispatcher::*)(::UnityEngine::UIElements::EventBase*, ::UnityEngine::UIElements::IPanel*, bool)>(&UnityEngine::UIElements::EventDispatcher::ApplyDispatchingStrategies)> {
  static const MethodInfo* get() {
    static auto* evt = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "EventBase")->byval_arg;
    static auto* panel = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "IPanel")->byval_arg;
    static auto* imguiEventIsInitiallyUsed = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::EventDispatcher*), "ApplyDispatchingStrategies", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{evt, panel, imguiEventIsInitiallyUsed});
  }
};
